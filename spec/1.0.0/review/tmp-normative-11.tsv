4152	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.1 Core Principles	* Schema semantics MUST be **closed-world**, **deterministic**, and **free of heuristics**.
4154	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.1 Core Principles	Schema validation, schema expansion, and derived-artifact generation MUST satisfy the schema-first requirements defined in §9.
4163	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Traits	A `Schema` Concept MUST declare the following Traits:
4190	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Traits	The canonical namespace label for this schema. The value MUST be a camelCase name (§4.1). This label is used by importing documents to construct qualified names (§4.1.1) that reference Concept and Trait definitions from this schema. Each schema's `namespace` value MUST be unique among all schemas loaded together (governing schema plus imported schemas); if two schemas declare the same `namespace` value, processing MUST fail with a `SchemaError` (§14).
4199	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	A `Schema` MUST satisfy the mode-conditional child-Concept rules defined in §9.4.
4203	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` MUST contain exactly one `ConceptDefinitions` child Concept.
4213	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` MUST NOT contain `RdfGraph`.
4217	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` MUST contain exactly one `RdfGraph` child Concept.
4218	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` MUST NOT contain any of the following child Concepts:
4227	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` in `$CanonicalMode` is allowed to contain a `SchemaImports` child Concept. The parser MUST merge imported SHACL shapes at the RDF level.
4233	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Semantic Requirements	* Any schema whose structure or semantics cannot be interpreted deterministically under this specification MUST be rejected with a `SchemaError` (§14).
4243	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImports`	`SchemaImports` MUST only appear as a direct child of a root Concept.
4245	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImports`	A root Concept MUST NOT contain more than one `SchemaImports` child.
4247	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImports`	If `SchemaImports` appears on a non-root Concept, the document MUST be rejected with a `ParseError` (§14).
4255	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImports` > Canonical Ordering	Within a `SchemaImports` block, `SchemaImport` children MUST be sorted alphabetically by their canonical `namespace` value (lexicographic ascending) in canonical form.
4263	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Traits	The IRI of the imported schema. This MUST be the `Schema.id` of an imported schema provided via the `importedSchemas` input (§12.2). The value MUST be an IRI Reference Value.
4267	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Traits	The namespace label used in qualified names (§4.1.1) to reference Concepts and Traits from this imported schema. The value MUST be a camelCase name (§4.1). In canonical form, this value MUST be normalized to the imported schema's declared `namespace` Trait value (§10.4).
4271	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Semantic Requirements	* The `reference` IRI MUST appear as a key in the `importedSchemas` map provided to `validate()` (§12.2). If the IRI is not present in `importedSchemas`, processing MUST fail with a `SchemaError` (§14).
4272	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Semantic Requirements	* After namespace label normalization, all `SchemaImport` entries within a `SchemaImports` block MUST have distinct canonical `namespace` values. If two entries produce the same canonical namespace label, processing MUST fail with a `SchemaError` (§14).
4273	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Semantic Requirements	* A qualified name using a namespace label MUST resolve to a Concept or Trait definition within the corresponding imported schema. If the qualified name references a Concept or Trait not defined in the imported schema, processing MUST fail with a `SchemaError` (§14).
4279	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > Governing Schema as Default Namespace	Trait names on Concept instances in data documents MUST be unqualified. The Concept definition (from the governing schema or the imported schema that defines the Concept) determines which `TraitDefinition` each Trait name refers to.
4281	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > Governing Schema as Default Namespace	Enumerated Tokens (`$Value`) and Lookup Tokens (`~key`) MUST NOT be namespace-qualified. The Trait's constraint determines the `EnumeratedValueSet`; the document's resolution table (§9.8) resolves Lookup Tokens.
4285	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > Namespace Qualification in Schema Documents	In schema documents, references to Concepts and Traits from imported schemas in meta-language constructs (`RequiresTrait`, `AllowsTrait`, `AllowsChildConcept`, `RequiresChildConcept`, `ForbidsChildConcept`, `ForbidsTrait`, `conceptSelector`, etc.) MUST use qualified names (`namespace:name`). Local definitions MUST be unqualified.
4291	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > Data Documents with Imports	The `SchemaImports` in a data document MUST be consistent with the governing schema: any schema imported by the data document MUST also be imported by the governing schema (or be the governing schema itself).
4342	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.2 `ContentRules` > Children > `AllowsContent`	`whitespaceMode` MUST be one of:
4344	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.2 `ContentRules` > Children > `AllowsContent`	* `$Preformatted` — content whitespace is significant and MUST be preserved exactly
4345	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.2 `ContentRules` > Children > `AllowsContent`	* `$Flow` — content whitespace is not significant; Codex-conforming tools MUST collapse runs of whitespace to single spaces and trim leading/trailing whitespace
4398	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.3 `TraitRules` > Children > Concept-Level `AllowedValues` Narrowing	When `AllowedValues` appears as a child of `RequiresTrait` or `AllowsTrait`, it further narrows the `AllowedValues` declared on the referenced `TraitDefinition`. The concept-level allowed values MUST be a subset of the `TraitDefinition`-level allowed values. If both exist, the concept-level constraint governs.
4447	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.4 `ChildRules` > Children > `ExactlyOneChildOf`	Declares that exactly one of the listed Concept types MUST appear as a child of the governed instance.
4479	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Form	`CollectionRules` MUST be self-closing and MUST NOT have children.
4483	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Applicability	When `CollectionRules` is present, child ordering and duplication semantics MUST be enforced as declared.
4489	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics	Ordering MUST be exactly one of:
4495	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Ordered`	Source order MUST be preserved through all conforming processing.
4497	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Ordered`	Two `$Ordered` collections with identical children in different orders MUST be treated as semantically distinct.
4499	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Ordered`	Validation and comparison of `$Ordered` collections MUST be order-sensitive.
4505	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Unordered`	Conforming implementations MUST preserve source order during parsing and general processing.
4507	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Unordered`	Validation of `$Unordered` collections MUST be order-insensitive.
4509	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Unordered`	Semantic comparison of `$Unordered` collections MUST be order-insensitive: two `$Unordered` collections with identical children in different orders MUST be treated as semantically equivalent.
4511	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Unordered`	In canonical surface form, children of an `$Unordered` collection MUST be sorted according to the deterministic ordering defined in §10.4.1.
4532	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Allowed Traits	When both `defaultValueType` and `defaultValueTypes` are provided, schema processing MUST fail with a `SchemaError` (§14).
4534	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Allowed Traits	`priority` is a meta-schema concern. Implementations MUST NOT use `priority` to change validation or compilation semantics. Meta-schemas are allowed to constrain `priority` values.
4537	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Value Type Semantics	When a trait is present on a Concept instance, its value MUST conform to the declared value type.
4539	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Value Type Semantics	When `defaultValueTypes` specifies multiple types, the value MUST conform to exactly one of the listed types.
4542	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Collection Type Semantics	When a trait's value type is a parameterized collection type, each element of the collection MUST conform to the declared item type.
4546	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Collection Type Semantics	When a trait's value type is a union containing both scalar and collection types, the value MUST conform to exactly one member of the union.
4608	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types	Value type checking MUST be deterministic and MUST NOT perform implicit evaluation.
4669	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.1 Built-In Value Type Tokens	When a schema constrains a Trait value using a built-in value type token, semantic validation MUST convert that value into the corresponding typed IR value and MUST reject values that are syntactically well-formed but semantically invalid for the expected type.
4689	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.2 `ValueTypeDefinition` > Allowed Traits	`ValueTypeDefinition` names MUST be unique within the Schema.
4691	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.2 `ValueTypeDefinition` > Allowed Traits	When `validatorName` is present, schema-driven validation MUST apply the referenced validator as specified in §9.5.2 and §9.11.6.6.
4693	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.2 `ValueTypeDefinition` > Allowed Traits	When `validatorName` cannot be resolved to exactly one `ValidatorDefinition`, schema processing MUST fail with a `SchemaError` (§14).
4695	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.2 `ValueTypeDefinition` > Allowed Traits	A `ValueTypeDefinition` MUST NOT change the surface grammar of its `baseValueType`.
4731	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.3 Enumerated Value Sets > `Member` > Allowed Traits	Each `value` MUST be unique within its `EnumeratedValueSet`.
4736	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.4 Built-In Enumerated Value Sets	The following enumerated value sets are defined by the Codex language itself and MUST be recognized by all conforming implementations.
4766	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.4 Built-In Enumerated Value Sets > `Cardinality`	These enumerated sets MUST NOT be redefined by schemas.
4777	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.1 `ConstraintDefinitions` > Children	The order of `ConstraintDefinition` children MUST be preserved but MUST NOT affect semantics.
4798	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.2 `ConstraintDefinition` > Children	When either child is missing or appears more than once, schema processing MUST fail with a `SchemaError` (§14).
4810	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > Children	When `Targets` contains no children, schema processing MUST fail with a `SchemaError` (§14).
4819	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > 11.6.3.1 `TargetConcept` > Traits	The selector MUST resolve to exactly one `ConceptDefinition`.
4820	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > 11.6.3.1 `TargetConcept` > Traits	Otherwise, schema processing MUST fail with a `SchemaError` (§14).
4829	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > 11.6.3.2 `TargetContext` > Traits	When `contextSelector` is not `"Document"`, it MUST resolve to exactly one `ConceptDefinition`.
4830	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > 11.6.3.2 `TargetContext` > Traits	Otherwise, schema processing MUST fail with a `SchemaError` (§14).
4837	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.4 `Rule` > Children	Exactly one child, which MUST be one of:
4843	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.4 `Rule` > Children	When `Rule` contains zero or more than one child, schema processing MUST fail with a `SchemaError` (§14).
4845	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.4 `Rule` > Children	`Rule` nodes are purely structural and MUST NOT carry Traits.
4851	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra	Rule algebra MUST be translatable to a total, deterministic validation form.
4857	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.1 General Rules	* Rule algebra nodes MUST NOT carry Traits.
4858	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.1 General Rules	* `AllOf`, `AnyOf`, and `Not` MUST contain only `Rule` nodes as children.
4859	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.1 General Rules	* Any rule tree MUST be finite and acyclic.
4861	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.1 General Rules	When a rule algebra structure cannot be translated deterministically, schema processing MUST fail with a `SchemaError` (§14).
4917	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.6 Determinism Requirement	Rule algebra evaluation MUST be:
4922	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.6 Determinism Requirement	When rule algebra composition cannot be evaluated deterministically, schema processing MUST fail with a `SchemaError` (§14).
4928	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers	All path and quantifier semantics MUST be compatible with the instance-graph mapping defined in §9.7 and the rule-to-SPARQL translation defined in §9.11.
4934	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.1 Paths	Each path node MUST declare exactly the traits required for its form.
4983	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.2 Quantifiers	Quantifiers MUST appear only in rule nodes that explicitly bind a Path to a nested Rule (see §9.5.3).
5009	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.2 Quantifiers > `Count` > Allowed Traits	At least one of `minCount` or `maxCount` MUST be present.
5019	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	* Paths MUST select a well-defined set of elements.
5020	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	* Quantifiers MUST evaluate to a single boolean outcome.
5021	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	* When a path selector cannot be resolved uniquely, schema processing MUST fail with a `SchemaError` (§14).
5022	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	* When a quantifier cannot be evaluated without guessing, schema processing MUST fail with a `SchemaError` (§14).
5024	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	Paths and quantifiers MUST NOT be evaluated outside the schema-driven validation pipeline defined in §9.
5030	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints	When an atomic constraint cannot be expressed under the instance-graph mapping (§9.7) and the constraint-to-artifact rules (§9.9–§9.11), schema processing MUST fail with a `SchemaError` (§14).
5038	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Trait Constraints > `TraitExists`	The named Trait MUST be present.
5047	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Trait Constraints > `TraitMissing`	The named Trait MUST be absent.
5056	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Trait Constraints > `TraitEquals`	The named Trait MUST have at least one value equal to the specified value.
5073	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Trait Constraints > `TraitCardinality` > Allowed Traits	At least one of `min` or `max` MUST be present.
5111	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsOneOf`	The value MUST be one of the explicitly listed values.
5120	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueMatchesPattern`	The value MUST match a regular expression.
5147	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueLength` > Allowed Traits	At least one of `min` or `max` MUST be present.
5157	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueInNumericRange` > Allowed Traits	At least one of `min` or `max` MUST be present.
5159	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueInNumericRange` > Allowed Traits	This constraint MUST apply only to numeric value types that support ordered comparison.
5160	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueInNumericRange` > Allowed Traits	When comparison semantics are not explicitly defined for the active value type, schema processing MUST fail with a `SchemaError` (§14).
5166	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsNonEmpty`	The value MUST be present and non-empty.
5169	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsNonEmpty`	If applied to an incompatible value type, schema processing MUST fail with a `SchemaError` (§14).
5175	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsValid`	The value MUST satisfy a named validator.
5180	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsValid` > Traits	The validator MUST resolve to exactly one `ValidatorDefinition` in the governing schema.
5181	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsValid` > Traits	If resolution fails, schema processing MUST fail with a `SchemaError` (§14).
5193	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.2 Child Constraints > `ChildConstraint` > Traits	Its semantics MUST be equivalent to the corresponding explicit child-rule form defined in §11.3.4.
5205	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.2 Child Constraints > `ChildSatisfies` > Children	The rule MUST be evaluated for each matching child Concept instance.
5239	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.3 Collection Constraints > `CollectionAllowsDuplicates` > Allowed Traits	When `allowed` is `false`, `keyTrait` MUST be present.
5252	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.3 Collection Constraints > `MemberCount` > Allowed Traits	At least one of `min` or `max` MUST be present.
5261	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.3 Collection Constraints > `EachMemberSatisfies`	Each collection member MUST satisfy a nested rule.
5267	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.3 Collection Constraints > `EachMemberSatisfies` > Children	The rule MUST be evaluated for each matching collection member.
5279	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.4 Uniqueness Constraints > `UniqueConstraint` > Traits	Uniqueness semantics MUST follow the deterministic scope rules defined in §9.9.7.
5292	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.5 Order Constraints > `OrderConstraint` > Types	* `Ascending`: Elements MUST be in ascending order by the specified trait value.
5293	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.5 Order Constraints > `OrderConstraint` > Types	* `Descending`: Elements MUST be in descending order by the specified trait value.
5298	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.5 Order Constraints > `OrderConstraint` > Children	Order constraint semantics apply to `$Ordered` collections only. When an `OrderConstraint` is applied to an `$Unordered` collection, schema processing MUST fail with a `SchemaError` (§14).
5310	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceTargetsEntity`: Target MUST be an Entity. The `conceptSelector` and `traitName` traits MUST NOT be present.
5311	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceMustResolve`: Reference MUST resolve. The `conceptSelector` and `traitName` traits MUST NOT be present.
5312	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceSingleton`: At most one reference Trait MUST be present. The `conceptSelector` and `traitName` traits MUST NOT be present.
5313	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceTargetsConcept`: Target MUST be a specific Concept type. The `conceptSelector` trait MUST be present.
5314	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceTraitAllowed`: A specific reference Trait is allowed. The `traitName` trait MUST be present.
5316	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	Reference constraint semantics MUST follow §9.9.9–§9.9.12 exactly.
5328	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	* `MustBeEntity`: Instance MUST be an Entity. The `scope`, `pattern`, and `flags` traits MUST NOT be present.
5329	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	* `MustNotBeEntity`: Instance MUST NOT be an Entity. The `scope`, `pattern`, and `flags` traits MUST NOT be present.
5330	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	* `IdentifierUniqueness`: Identifiers MUST be unique within scope. The `scope` trait MUST be present. The `pattern` and `flags` traits MUST NOT be present.
5331	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	* `IdentifierForm`: Identifier MUST match pattern. The `pattern` trait MUST be present. The `scope` trait MUST NOT be present.
5333	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	Identity constraint semantics MUST follow the entity and identity model defined in §§3.5 and 6.
5335	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	`IdentityConstraint(type=MustBeEntity)` MUST report an `IdentityError` (§14) unless the focus Concept instance is an Entity under §3.5.
5337	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	`IdentityConstraint(type=MustNotBeEntity)` MUST report an `IdentityError` (§14) if the focus Concept instance declares an `id` Trait.
5340	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	Its semantics MUST be identical to `UniqueConstraint(trait=id, scope=S)` as defined in §9.9.7 (where `id` refers to `codex:declaredId`).
5343	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	When the focus Concept instance is an Entity, its declared `id` value MUST match the regular expression `p` under SPARQL 1.1 `REGEX` semantics (see §9.5.1).
5345	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	When `pattern` is not provided for `IdentityConstraint(type=IdentifierForm)`, schema processing MUST fail with a `SchemaError` (§14).
5358	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.8 Context Constraints > `ContextConstraint` > Types	* `OnlyValidUnderParent`: Requires the immediate parent is of the type specified by the `TargetContext` in this constraint's `Targets` block. The `ContextConstraint` itself MUST NOT have a `contextSelector` trait.
5359	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.8 Context Constraints > `ContextConstraint` > Types	* `OnlyValidUnderContext`: Requires an ancestor of the specified type exists in the parent chain. The `contextSelector` trait MUST be present.
5361	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.8 Context Constraints > `ContextConstraint` > Types	Context constraint semantics MUST follow §9.9.8.
5373	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.10 Content Constraints > `ContentConstraint` > Types	* `ForbidsContent`: Requires content is absent. The `pattern` and `flags` traits MUST NOT be present.
5374	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.10 Content Constraints > `ContentConstraint` > Types	* `ContentRequired`: Requires content exists. The `pattern` and `flags` traits MUST NOT be present.
5375	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.10 Content Constraints > `ContentConstraint` > Types	* `ContentMatchesPattern`: Requires content matches a pattern. The `pattern` trait MUST be present. The `flags` trait is allowed.
5377	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.10 Content Constraints > `ContentConstraint` > Types	Content constraint semantics MUST follow the content model defined in §3.4 and the validation rules defined in §9.9.5.
5440	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.11 Relationship to External Systems	* Any derived representation (including SHACL, SHACL-SPARQL, or OWL) MUST be a pure, deterministic projection of the Codex schema.
5441	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.11 Relationship to External Systems	* Derived artifacts MUST NOT introduce semantics, defaults, inference rules, or interpretation not explicitly defined by:
5445	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.11 Relationship to External Systems	* Derived artifacts MUST NOT override, weaken, or contradict Codex validation semantics.
5446	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.11 Relationship to External Systems	* When a Codex constraint or rule cannot be expressed faithfully in the chosen external system, derivation MUST fail with a `SchemaError` (§14) rather than approximate.
