<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Codex Semantic Markup Language</title>

	<!-- Your Prism CSS -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
	<link rel="stylesheet" href="/assets/css/style.css" media="all">
</head>

<body>
	<p>Status: NORMATIVE<br />
Lock State: UNLOCKED<br />
Version: 1.0.0<br />
Editor: Charles F. Munat</p>

<h1 id="codex-language-specification--version-100">Codex Language Specification — Version 1.0.0</h1>

<p>This document is the authoritative language specification for Codex 1.0.0.</p>

<p>All normative requirements for Codex 1.0.0 MUST appear exactly once in this document.</p>

<hr />

<h2 id="1-front-matter">1. Front Matter</h2>

<h3 id="11-scope">1.1 Scope</h3>

<p>This specification normatively defines:</p>

<ul>
  <li>the core language model (Concepts, Traits, Values, Content, and Entities)</li>
  <li>naming and identifier constraints</li>
  <li>literal value spellings</li>
  <li>surface form syntax and structural rules for <code class="language-plaintext highlighter-rouge">.cdx</code> documents</li>
  <li>formatting and canonicalization requirements</li>
  <li>schema-first parsing architecture</li>
  <li>schema definition, schema loading/bootstrapping, and schema versioning rules</li>
  <li>reference trait semantics</li>
  <li>well-formedness and schema validation error classification</li>
</ul>

<p>Well-formedness checking does not require a schema; semantic validation does. See §2.5 for this distinction.</p>

<hr />

<h3 id="12-non-goals">1.2 Non-Goals</h3>

<p>Codex 1.0.0 does not define:</p>

<ul>
  <li>a programming, scripting, or templating language</li>
  <li>an execution model, runtime, or pipeline orchestration</li>
  <li>storage, querying, indexing, inference, or rendering behavior</li>
  <li>identifier base scoping, dereferencing, or external/base resolution mechanisms</li>
  <li>schema distribution, registry protocols, or migration mechanisms</li>
</ul>

<p>Those concerns belong to consuming systems and tooling.</p>

<h3 id="13-normativity-and-conformance">1.3 Normativity and Conformance</h3>

<p>This document uses the capitalized keywords <strong>MUST</strong> and <strong>MUST NOT</strong> to indicate requirements.</p>

<p>Any statement that uses <strong>MUST</strong> or <strong>MUST NOT</strong> is normative.</p>

<p>Unless explicitly stated otherwise:</p>

<ul>
  <li>All sections are normative unless explicitly labeled <strong>Informative</strong>.</li>
  <li>Text labeled <strong>Informative</strong> is explanatory and does not define requirements.</li>
  <li>Examples are illustrative and non-normative.</li>
</ul>

<p>All statements that do not use <strong>MUST</strong> or <strong>MUST NOT</strong> are informative unless they appear in a normative section and define required behavior through other unambiguous language.</p>

<p>A conforming implementation satisfies every normative requirement in this specification. Given identical inputs, all conforming implementations MUST produce identical outputs.</p>

<h4 id="131-consistency-guarantee">1.3.1 Consistency Guarantee</h4>

<p>This specification contains no internal conflicts.</p>

<p>Appendix A.1 (EBNF) formalizes the syntactic rules described in the prose. The prose defines semantic meaning and processing obligations. These two forms address distinct concerns and do not conflict.</p>

<p>The bootstrap schemas (<code class="language-plaintext highlighter-rouge">bootstrap-schema/schema.cdx</code> and <code class="language-plaintext highlighter-rouge">bootstrap-schema/simplified/schema.cdx</code>) instantiate the schema-definition rules defined in this specification. They are derived artifacts, not independent sources of authority.</p>

<p>If an implementer discovers an apparent conflict between any parts of this specification or between this specification and the bootstrap schemas, that conflict is a defect. Implementers MUST NOT guess which source prevails. Implementers MUST report the defect.</p>

<hr />

<h2 id="2-language-invariants">2. Language Invariants</h2>

<h3 id="21-declarative-and-closed-world-model">2.1 Declarative and Closed-World Model</h3>

<p>Codex is a declarative language with closed-world semantics.</p>

<p>A conforming implementation MUST treat something not explicitly declared as not present.</p>

<p>An implementation MUST NOT infer meaning from omission, shape, or other non-specified cues.</p>

<p>An implementation MUST NOT assume defaults unless explicitly defined by this specification or by the governing schema.</p>

<p>Structural ordering (of Traits, children, and collection elements) carries no semantic meaning to Codex itself. Schemas define whether ordering is semantically significant for specific constructs. Implementations MUST preserve structural ordering both for round-trippability (see §2.6) and to support schema-defined ordering constraints.</p>

<h3 id="22-determinism-and-explainability">2.2 Determinism and Explainability</h3>

<p>Given the same inputs, a conforming implementation MUST produce the same results.</p>

<p>Required inputs are:</p>

<ul>
  <li>document bytes</li>
  <li>governing schema (for validation; not required for well-formedness checking)</li>
  <li>document base IRI (for instance graph mapping; see §9.7)</li>
</ul>

<p>In particular:</p>

<ul>
  <li>Parsing MUST be deterministic.</li>
  <li>Well-formedness checking MUST be deterministic.</li>
  <li>Schema validation MUST be deterministic.</li>
  <li>Canonicalization MUST be deterministic.</li>
</ul>

<p>An implementation MUST NOT exhibit non-deterministic or heuristic behavior.</p>

<p>For any well-formedness, schema validation, or canonicalization result, an implementation MUST be able to attribute the result to:</p>

<ul>
  <li>the rule applied, and</li>
  <li>the specific declaration(s) or input construct(s) that caused the result.</li>
</ul>

<h3 id="23-separation-of-responsibility">2.3 Separation of Responsibility</h3>

<p>Codex enforces separation between:</p>

<ul>
  <li>language and surface form rules,</li>
  <li>schema-defined meaning and constraints,</li>
  <li>formatting/canonicalization,</li>
  <li>semantic validation, and</li>
  <li>consuming-system behavior (storage, querying, inference, rendering, execution).</li>
</ul>

<p>Accordingly:</p>

<ul>
  <li>Parsing MUST determine only the syntactic structure of the document.</li>
  <li>Formatting and canonicalization MUST be mechanical and MUST NOT perform schema evaluation.</li>
  <li>Semantic validation MUST evaluate schema rules (including content-mode interpretation, constraints, value types, identity, and references) and MUST NOT be performed implicitly during parsing.</li>
</ul>

<h3 id="24-target-agnosticism">2.4 Target Agnosticism</h3>

<p>Codex is target-agnostic. A Codex document can be transformed into other representations (RDF/SHACL, JSON, TOML, etc.).</p>

<p>Codex constructs and Codex-conforming tool behavior MUST NOT assume or require any particular target format, runtime, storage backend, inference system, rendering model, or execution semantics.</p>

<h3 id="25-well-formedness-and-validity">2.5 Well-Formedness and Validity</h3>

<p>Codex distinguishes two independent questions:</p>

<ul>
  <li><strong>Well-formedness</strong>: whether a document is syntactically and structurally correct under this specification’s surface-form grammar and structural rules.</li>
  <li><strong>Validity</strong>: whether a well-formed document satisfies the semantic rules of a governing schema (including typing, authorization, value types, identity, references, and constraints).</li>
</ul>

<p>Accordingly:</p>

<ul>
  <li>A conforming implementation MUST be able to parse and check well-formedness without a governing schema.</li>
  <li>A conforming implementation MUST NOT perform schema validation without an explicit governing schema.</li>
</ul>

<p>Well-formedness checking includes mechanically recognizing and classifying Value spellings into their Value kinds (and any grammar-defined subkinds) by applying this specification’s surface-form grammar (§5 and Appendix A).</p>

<p>Expected types and type constraints for Trait values are schema-defined; checking a Trait value against its expected <code class="language-plaintext highlighter-rouge">ValueType</code> is part of schema validation and therefore requires an explicit governing schema.</p>

<p>The bootstrap schema-of-schemas provides a built-in governing schema only for schema documents (§12.4) and MUST NOT be used as a fallback governing schema for instance documents.</p>

<p>In this document, the term <strong>schema validation</strong> refers only to the schema-based semantic phase. When referring to the schema-free phase, this document uses <strong>parse</strong> and <strong>check well-formedness</strong>.</p>

<h3 id="26-round-trippability">2.6 Round-Trippability</h3>

<p>Round-trippability applies to the canonical form, not raw input. Raw input may use arbitrary whitespace or non-canonical formatting. Canonicalization (similar to <code class="language-plaintext highlighter-rouge">gofmt</code>) normalizes raw input to a single canonical surface form. Round-tripping preserves this canonical form.</p>

<p>A conforming implementation MUST support round-tripping: a canonicalized Codex document, after transformation to RDF triples, storage, retrieval via SPARQL, and reconstruction, MUST produce a byte-identical canonicalized document.</p>

<p>This invariant ensures that Codex serves as a lossless serialization format for RDF data. Structural ordering, annotations, and all surface-form details MUST survive the round-trip.</p>

<p>To guarantee round-trippability, a conforming implementation MUST provide the following capabilities:</p>

<ul>
  <li>canonicalization (raw bytes → canonical surface form)</li>
  <li>parsing (canonical surface form → AST)</li>
  <li>validation (AST + schema → IR)</li>
  <li>triple serialization (IR → RDF/SHACL triples)</li>
  <li>triple reconstruction (SPARQL query results → canonical Codex)</li>
</ul>

<p>These capabilities MUST compose such that: for any valid input, canonicalizing the reconstructed output produces a byte-identical result to canonicalizing the original input.</p>

<hr />

<h2 id="3-core-model">3. Core Model</h2>

<h3 id="31-concept">3.1 Concept</h3>

<p>A Concept is a named declarative construct and the primary structural unit of a Codex document.</p>

<p>A Concept instance MUST have exactly one Concept name.</p>

<p>A Concept instance MUST declare zero or more Traits.</p>

<p>A Concept instance MUST be in exactly one of two body modes:</p>

<ul>
  <li><strong>children mode</strong>: the Concept instance contains zero or more child Concepts and no Content.</li>
  <li><strong>content mode</strong>: the Concept instance contains Content and no child Concepts.</li>
</ul>

<h3 id="32-trait">3.2 Trait</h3>

<p>A Trait binds a Trait name to a Value.</p>

<p>A Trait instance MUST be declared on exactly one containing Concept instance.</p>

<p>A Trait instance MUST NOT have independent identity.</p>

<p>Trait meaning and permissibility MUST be defined by the governing schema.</p>

<h3 id="33-value">3.3 Value</h3>

<p>A Value is a literal datum.</p>

<p>A Value instance MUST be expressed using one of the literal spellings defined by this specification.</p>

<p>A Value instance MUST be treated as declarative and immutable.</p>

<p>Codex-conforming tools MUST parse Value spellings mechanically and MUST NOT evaluate Values as expressions.</p>

<p>The meaning of a Value beyond its literal form MUST be defined by the governing schema or consuming system.</p>

<h3 id="34-content">3.4 Content</h3>

<p>Content is opaque narrative text carried by a Concept.</p>

<p>Content MUST NOT be treated as a Value.</p>

<p>Content MUST NOT be typed, evaluated, or interpreted as Concepts, Traits, Values, or Annotations.</p>

<p>Content MUST be preserved through Codex-conforming processing, subject only to the surface-form normalization and canonicalization rules defined by this specification.</p>

<h3 id="35-entity">3.5 Entity</h3>

<p>An Entity is a Concept instance with explicit identity.</p>

<p>A Concept instance is an Entity if and only if the governing schema declares <code class="language-plaintext highlighter-rouge">$MustBeEntity</code> for that Concept via its <code class="language-plaintext highlighter-rouge">entityEligibility</code> rule.</p>

<p>The governing schema MUST declare exactly one <code class="language-plaintext highlighter-rouge">entityEligibility</code> value for each Concept. The valid values are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$MustBeEntity</code>: each instance of that Concept MUST declare an <code class="language-plaintext highlighter-rouge">id</code> Trait.</li>
  <li><code class="language-plaintext highlighter-rouge">$MustNotBeEntity</code>: each instance of that Concept MUST NOT declare an <code class="language-plaintext highlighter-rouge">id</code> Trait.</li>
</ul>

<p>If the governing schema does not declare <code class="language-plaintext highlighter-rouge">entityEligibility</code> for a Concept, schema validation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>Codex-conforming formatting and canonicalization MUST NOT synthesize identity by adding an <code class="language-plaintext highlighter-rouge">id</code> Trait or inventing an identifier value.</p>

<h3 id="36-marker">3.6 Marker</h3>

<p>A Marker is a syntactic delimiter for Concept instances in the surface form.</p>

<p>Markers MUST be one of:</p>

<ul>
  <li>an opening marker,</li>
  <li>a closing marker, or</li>
  <li>a self-closing marker.</li>
</ul>

<p>Markers MUST delimit Concept structure and nesting.</p>

<p>Each closing marker MUST match the most recent unclosed opening marker. If a closing marker does not match, or if any opening marker remains unclosed at end of input, the document MUST be rejected with a <code class="language-plaintext highlighter-rouge">ParseError</code> (§14).</p>

<p>A self-closing marker MUST represent a Concept with no children and no Content.</p>

<h3 id="37-annotation">3.7 Annotation</h3>

<p>An Annotation is author-supplied editorial metadata.</p>

<p>Annotations MUST NOT affect parsing, schema validation outcomes, or domain semantics.</p>

<p>Annotations MUST be preserved through Codex-conforming processing, subject only
to the surface-form normalization and canonicalization rules defined by this
specification.</p>

<hr />

<h2 id="4-naming-rules">4. Naming Rules</h2>

<p>This section defines requirements for Concept names and Trait names.
Some requirements in this section are normative but not mechanically enforceable; such requirements bind schema authors and govern conformance, even where implementations cannot detect all violations.</p>

<h3 id="41-name-forms">4.1 Name Forms</h3>

<p>For the purposes of Codex, this specification defines:</p>

<ul>
  <li><strong>PascalCase</strong>: a name composed only of ASCII letters and digits; the first character MUST be an ASCII uppercase letter.</li>
  <li><strong>camelCase</strong>: a name composed only of ASCII letters and digits; the first character MUST be an ASCII lowercase letter.</li>
</ul>

<p>A name MUST contain at least one character.</p>

<p>Concept names MUST use PascalCase.</p>

<p>Trait names MUST use camelCase.</p>

<p>No other casing is permitted.</p>

<h3 id="42-consecutive-uppercase-restriction">4.2 Consecutive Uppercase Restriction</h3>

<p>Concept names and Trait names MUST NOT contain three or more consecutive ASCII uppercase letters.</p>

<p>This restriction ensures that acronyms and initialisms are written as ordinary words with only the first letter capitalized (e.g., <code class="language-plaintext highlighter-rouge">AstNode</code>, not <code class="language-plaintext highlighter-rouge">ASTNode</code>). It also permits single-letter words in names (e.g., <code class="language-plaintext highlighter-rouge">ThisIsAThing</code> is valid because the transition from “A” to “Thing” produces only two consecutive uppercase letters).</p>

<h3 id="43-acronyms-and-initialisms-author-responsibility">4.3 Acronyms and Initialisms (Author Responsibility)</h3>

<p>Authors MUST write acronyms and initialisms as single words with only the first letter capitalized.</p>

<p>This requirement binds schema authors. It is not fully mechanically enforceable because implementations cannot distinguish an incorrectly written acronym from a legitimate sequence of single-letter words.</p>

<table>
  <thead>
    <tr>
      <th>Correct</th>
      <th>Incorrect</th>
      <th>Mechanical rejection (§4.2)</th>
      <th>Author intent</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">AstNode</code></td>
      <td><code class="language-plaintext highlighter-rouge">ASTNode</code></td>
      <td>A-S-T-N = 4 consecutive</td>
      <td>“AST” is one word</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">HtmlParser</code></td>
      <td><code class="language-plaintext highlighter-rouge">HTMLParser</code></td>
      <td>H-T-M-L-P = 5 consecutive</td>
      <td>“HTML” is one word</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">safeHtml</code></td>
      <td><code class="language-plaintext highlighter-rouge">safeHTML</code></td>
      <td>H-T-M-L = 4 consecutive</td>
      <td>“HTML” is one word</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ioStream</code></td>
      <td><code class="language-plaintext highlighter-rouge">iOStream</code></td>
      <td>not rejected</td>
      <td>“IO” is one word</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="5-value-literal-catalog">5. Value Literal Catalog</h2>

<h3 id="51-string-values">5.1 String Values</h3>

<p>A String Value is a sequence of zero or more Unicode scalar values. An empty String Value (zero scalar values) is permitted.</p>

<p>In the Surface Form, String Values MUST be spelled as quoted string literals (see Appendix A) or backtick strings (see §5.2).</p>

<h3 id="52-backtick-strings">5.2 Backtick Strings</h3>

<p>A Backtick String is a surface-form spelling of a String Value.</p>

<p>Within a Backtick String, <code class="language-plaintext highlighter-rouge">\`</code> represents a literal <code class="language-plaintext highlighter-rouge">`</code>.</p>

<p>A backslash not immediately followed by a backtick is a literal backslash and has no special meaning.</p>

<p>After interpreting the Backtick String’s escape sequences, the resulting character sequence MUST be transformed into the resulting String Value by applying the following whitespace normalization:</p>

<ul>
  <li>Each maximal run of whitespace characters (spaces, tabs, and line breaks) MUST be replaced with a single U+0020 SPACE.</li>
  <li>Leading and trailing U+0020 SPACE MUST be removed.</li>
</ul>

<p>The resulting String Value MUST be single-line.</p>

<h3 id="53-boolean-values">5.3 Boolean Values</h3>

<p>A Boolean Value is one of two values: true or false.</p>

<p>In the Surface Form, Boolean Values MUST be spelled as the tokens <code class="language-plaintext highlighter-rouge">true</code> and <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>No other spellings are permitted.</p>

<h3 id="54-numeric-values">5.4 Numeric Values</h3>

<p>Codex performs no arithmetic and no numeric normalization. Numeric spellings MUST be preserved exactly.</p>

<p>Integer components in Numeric Value spellings MUST NOT contain leading zeros, except that the single digit <code class="language-plaintext highlighter-rouge">0</code> is permitted. A sign character (if present) is not part of the integer component.</p>

<p>This requirement applies to:</p>

<ul>
  <li>integer Numeric Values</li>
  <li>the integer component of Decimal Numbers</li>
  <li>the exponent digit sequence of Scientific Numbers</li>
  <li>the explicit precision suffix digit sequence (if present)</li>
  <li>fraction denominators</li>
</ul>

<p>In the Surface Form, Numeric Values MUST be spelled using the numeric literal grammar defined by this specification.</p>

<p>Numeric Values MUST NOT include NaN. The literal spellings <code class="language-plaintext highlighter-rouge">Infinity</code> and <code class="language-plaintext highlighter-rouge">-Infinity</code> are permitted; <code class="language-plaintext highlighter-rouge">+Infinity</code> is not permitted. When compiled to XSD, <code class="language-plaintext highlighter-rouge">Infinity</code> MUST be translated to <code class="language-plaintext highlighter-rouge">INF</code> and <code class="language-plaintext highlighter-rouge">-Infinity</code> MUST be translated to <code class="language-plaintext highlighter-rouge">-INF</code>.</p>

<p>The literal spelling <code class="language-plaintext highlighter-rouge">-0</code> is permitted and MUST be preserved distinct from <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>The meaning of a Numeric Value beyond its literal spelling MUST be defined by the governing schema or consuming system.</p>

<h4 id="541-precision-significant-numbers">5.4.1 Precision-Significant Numbers</h4>

<p>A precision-significant number is a Numeric Value spelled with a <code class="language-plaintext highlighter-rouge">p</code> suffix.</p>

<p>The declared precision (a count of decimal places) MUST be determined by one of the following mechanisms:</p>

<ul>
  <li>Inferred precision: the count of decimal places in the literal spelling, including trailing zeros. A literal with no decimal point has 0 decimal places.</li>
  <li>Explicit precision: a non-negative integer following the <code class="language-plaintext highlighter-rouge">p</code> suffix, which overrides inferred precision.</li>
</ul>

<p>Consuming systems MUST preserve the declared precision.</p>

<h3 id="55-enumerated-token-values">5.5 Enumerated Token Values</h3>

<p>An Enumerated Token Value is a Value drawn from a schema-defined closed set.</p>

<p>In the Surface Form, Enumerated Token Values MUST be spelled with a leading <code class="language-plaintext highlighter-rouge">$</code> sigil followed by a token name. The token name MUST use PascalCase.</p>

<p>Enumerated Token Values MUST NOT be treated as String Values.</p>

<p>Enumerated Token Values MUST NOT be evaluated.</p>

<h3 id="56-temporal-values">5.6 Temporal Values</h3>

<p>A Temporal Value represents a declarative temporal literal.</p>

<p>In the Surface Form, Temporal Values MUST be spelled using <code class="language-plaintext highlighter-rouge">{...}</code>.</p>

<p>Temporal Values MUST conform to the Temporal Value grammar defined by this specification (see Appendix A.1.14 and Appendix A.2.15). The Temporal Value grammar defines the complete braced literal; the Temporal Body grammar defines the content within the braces.</p>

<p>Codex itself defines no temporal evaluation, normalization, ordering, time zone interpretation, or calendrical correctness requirements for Temporal Values. In canonical surface form, Temporal Values MUST be spelled exactly as parsed (no normalization).</p>

<p>Codex-conforming tools MUST NOT derive temporal meaning, perform evaluation, apply defaults, or check real-world correctness (for example, month length or leap seconds) except as explicitly defined by the governing schema or consuming system.</p>

<h4 id="561-temporal-kind-determination">5.6.1 Temporal Kind Determination</h4>
<p>To classify a Temporal Value as a specific temporal kind (for example, <code class="language-plaintext highlighter-rouge">ZonedDateTime</code> or <code class="language-plaintext highlighter-rouge">Date</code>), tools MUST parse the braced payload using the Temporal Body grammar in Appendix A.</p>

<p>This classification is purely syntactic and depends only on the braced payload; it does not imply temporal evaluation or interpretation.</p>

<p>The temporal kind MUST be determined by the first matching alternative in the following ordered list:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">ZonedDateTime</code></li>
  <li><code class="language-plaintext highlighter-rouge">LocalDateTime</code></li>
  <li><code class="language-plaintext highlighter-rouge">Date</code></li>
  <li><code class="language-plaintext highlighter-rouge">YearMonth</code></li>
  <li><code class="language-plaintext highlighter-rouge">MonthDay</code></li>
  <li><code class="language-plaintext highlighter-rouge">Time</code></li>
  <li><code class="language-plaintext highlighter-rouge">Duration</code></li>
  <li><code class="language-plaintext highlighter-rouge">TemporalKeyword</code></li>
</ol>

<p>Temporal Values MUST NOT be treated as Enumerated Token Values, even when the braced payload is a reserved literal such as <code class="language-plaintext highlighter-rouge">now</code> or <code class="language-plaintext highlighter-rouge">today</code>.</p>

<h3 id="57-color-values">5.7 Color Values</h3>

<p>A Color Value MUST NOT be treated as a String Value.</p>

<p>Codex-conforming tools MUST NOT normalize, convert, or interpret Color Values beyond the well-formedness checks defined by this specification.</p>

<p>In the Surface Form, Color Values MUST be spelled using one of the following literal forms:</p>

<ul>
  <li>hexadecimal colors (<code class="language-plaintext highlighter-rouge">#RGB</code>, <code class="language-plaintext highlighter-rouge">#RGBA</code>, <code class="language-plaintext highlighter-rouge">#RRGGBB</code>, <code class="language-plaintext highlighter-rouge">#RRGGBBAA</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">rgb(...)</code> (with legacy alias <code class="language-plaintext highlighter-rouge">rgba(...)</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">hsl(...)</code> (with legacy alias <code class="language-plaintext highlighter-rouge">hsla(...)</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">hwb(...)</code></li>
  <li><code class="language-plaintext highlighter-rouge">lab(...)</code></li>
  <li><code class="language-plaintext highlighter-rouge">lch(...)</code></li>
  <li><code class="language-plaintext highlighter-rouge">oklab(...)</code></li>
  <li><code class="language-plaintext highlighter-rouge">oklch(...)</code></li>
  <li><code class="language-plaintext highlighter-rouge">color(...)</code></li>
  <li><code class="language-plaintext highlighter-rouge">color-mix(...)</code></li>
  <li>relative colors using <code class="language-plaintext highlighter-rouge">from &lt;color&gt;</code> within a color function</li>
  <li><code class="language-plaintext highlighter-rouge">device-cmyk(...)</code></li>
  <li>named colors using a leading <code class="language-plaintext highlighter-rouge">&amp;</code> sigil</li>
</ul>

<p>Hex digits in hexadecimal colors are case-insensitive for parsing. In canonical surface form, hexadecimal digits in Color Values MUST be lowercase.</p>

<p>Color function names are case-insensitive for parsing. In canonical surface form, color function names MUST be lowercase.</p>

<p>Color space tokens in <code class="language-plaintext highlighter-rouge">color(...)</code> are case-insensitive for parsing. In canonical surface form, color space tokens MUST be lowercase. The color space token MUST be one of:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">srgb</code></li>
  <li><code class="language-plaintext highlighter-rouge">srgb-linear</code></li>
  <li><code class="language-plaintext highlighter-rouge">display-p3</code></li>
  <li><code class="language-plaintext highlighter-rouge">a98-rgb</code></li>
  <li><code class="language-plaintext highlighter-rouge">prophoto-rgb</code></li>
  <li><code class="language-plaintext highlighter-rouge">rec2020</code></li>
  <li><code class="language-plaintext highlighter-rouge">xyz</code></li>
  <li><code class="language-plaintext highlighter-rouge">xyz-d50</code></li>
  <li><code class="language-plaintext highlighter-rouge">xyz-d65</code></li>
</ul>

<h4 id="571-named-color-values">5.7.1 Named Color Values</h4>

<p>In the Surface Form, a Named Color Value MUST be spelled as <code class="language-plaintext highlighter-rouge">&amp;</code> followed immediately by a color name.</p>

<p>The color name MUST consist only of ASCII lowercase letters (<code class="language-plaintext highlighter-rouge">a</code> through <code class="language-plaintext highlighter-rouge">z</code>).</p>

<p>The color name MUST be one of the named color keywords defined in Appendix B; an unrecognized color name is a SchemaError (§14).</p>

<h3 id="58-uuid-values">5.8 UUID Values</h3>

<p>A UUID Value is a 36-character unquoted token with the form:</p>

<p><code class="language-plaintext highlighter-rouge">xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code></p>

<p>where each <code class="language-plaintext highlighter-rouge">x</code> is a hexadecimal digit.</p>

<p>A UUID Value MUST NOT be a String Value.</p>

<p>A UUID Value MUST NOT include braces, prefixes, or other delimiters.</p>

<p>Hyphens MUST appear at character positions 9, 14, 19, and 24 (1-indexed).</p>

<p>Hexadecimal digits in UUID Values are case-insensitive for parsing. In canonical surface form, UUID Values MUST be spelled using lowercase hexadecimal digits.</p>

<p>No UUID version is mandated.</p>

<h3 id="59-iri-reference-values">5.9 IRI Reference Values</h3>

<p>An IRI Reference Value is an unquoted token representing identity or reference.</p>

<p>An IRI Reference Value MUST contain a <code class="language-plaintext highlighter-rouge">:</code> character separating the scheme from the remainder.</p>

<p>In the Surface Form, IRI Reference Values MUST be spelled using the IRI reference grammar defined by this specification.</p>

<p>IRI Reference Values MUST permit non-ASCII Unicode characters directly and MUST permit percent-encoding, as defined for IRI-references by RFC 3987: https://www.rfc-editor.org/rfc/rfc3987.</p>

<p>IRI Reference Values MUST NOT contain Unicode whitespace characters.</p>

<p>IRI Reference Values MUST NOT contain Unicode control characters.</p>

<p>IRI Reference Values MUST NOT contain Unicode bidirectional control characters.</p>

<p>IRI Reference Values MUST NOT contain Unicode private-use characters.</p>

<p>An IRI Reference Value MUST NOT be a String Value.</p>

<p>IRI Reference Values MUST be compared as opaque strings.</p>

<p>Codex-conforming tools MUST NOT dereference IRI Reference Values.</p>

<p>Where this specification defines deterministic resolution (for example, lookup-token binding and reference-constraint resolution), tools MUST apply only the mechanisms defined by this specification and MUST NOT perform any external lookup, registry query, or network dereferencing.</p>

<h3 id="510-lookup-token-values">5.10 Lookup Token Values</h3>

<p>A Lookup Token Value is an unquoted token that binds to a schema-defined value.</p>

<p>In the Surface Form, Lookup Token Values MUST be spelled as <code class="language-plaintext highlighter-rouge">~</code> followed immediately by a token name.</p>

<p>The token name MUST use camelCase.</p>

<p>A Lookup Token Value MUST NOT be a String Value.</p>

<p>Codex-conforming tools MUST NOT dereference Lookup Token Values.</p>

<h3 id="511-character-values">5.11 Character Values</h3>

<p>A Character Value represents exactly one Unicode scalar value.</p>

<p>In the Surface Form, Character Values MUST be spelled as character literals delimited by single quotes (<code class="language-plaintext highlighter-rouge">'</code>). See Appendix A for the full grammar.</p>

<p>A Character Value MUST NOT be a String Value.</p>

<p>After interpreting the character literal’s escape sequences, the resulting Character Value MUST contain exactly one Unicode scalar value.</p>

<h3 id="512-list-values">5.12 List Values</h3>

<p>A List Value is an ordered sequence of zero or more Value elements.</p>

<p>In the Surface Form, List Values MUST be spelled using square brackets (<code class="language-plaintext highlighter-rouge">[...]</code>). See Appendix A for the full grammar.</p>

<p>Each element of a List Value MUST be a Value.</p>

<p>A List Value MUST permit nesting.</p>

<p>A List Value MUST NOT require all elements to have the same Value kind.</p>

<p>A List Value MUST represent exactly the elements explicitly present in its literal spelling.</p>

<p>For schema-level type constraints on list contents, see §5.18.</p>

<h3 id="513-value-equality-for-collection-uniqueness">5.13 Value Equality for Collection Uniqueness</h3>
<p>For purposes of detecting duplicates in Set Values and Map Values, Codex-conforming tools MUST use the following Value equality relation.</p>

<p>Equality is defined over parsed Values (after interpreting escape sequences, backtick-string whitespace normalization, and other value-specific decoding rules) and MUST NOT be defined over raw source bytes.</p>

<p>Two Values are equal if and only if they have the same Value kind and satisfy the following rules (recursively where applicable):</p>

<ul>
  <li>String Values: equal if and only if they contain the same sequence of Unicode scalar values.</li>
  <li>Boolean Values: equal if and only if both are <code class="language-plaintext highlighter-rouge">true</code> or both are <code class="language-plaintext highlighter-rouge">false</code>.</li>
  <li>Numeric Values: equal if and only if their literal spellings are identical codepoint-for-codepoint.</li>
  <li>Enumerated Token Values: equal if and only if their literal spellings are identical codepoint-for-codepoint.</li>
  <li>Temporal Values: equal if and only if their literal spellings are identical codepoint-for-codepoint.</li>
  <li>Color Values: equal if and only if their literal spellings are identical, except that hexadecimal digits, color function names, and color space tokens are compared case-insensitively.</li>
  <li>UUID Values: equal if and only if they are identical after case-folding hexadecimal digits (i.e., hexadecimal digits are compared case-insensitively).</li>
  <li>IRI Reference Values: equal if and only if their spellings are identical codepoint-for-codepoint (see §5.9).</li>
  <li>Lookup Token Values: equal if and only if their literal spellings are identical codepoint-for-codepoint.</li>
  <li>Character Values: equal if and only if they contain the same Unicode scalar value.</li>
  <li>List Values and Tuple Values: equal if and only if they have the same length and corresponding elements are equal.</li>
  <li>Range Values: equal if and only if their start endpoints are equal, their end endpoints are equal, and either both omit a step or both include equal step Values.</li>
  <li>Set Values: equal if and only if they contain the same elements (under this equality relation), regardless of element order.</li>
  <li>Map Values: equal if and only if they contain the same bindings, where keys are equal and corresponding bound Values are equal, regardless of entry order.</li>
</ul>

<h3 id="514-set-values">5.14 Set Values</h3>

<p>A Set Value is an unordered collection of zero or more Value elements. Set Values have no semantic ordering; however, in canonical surface form, elements MUST be serialized in the order they appear in the source spelling.</p>

<p>In the Surface Form, Set Values MUST be spelled using the <code class="language-plaintext highlighter-rouge">set</code> keyword followed by square brackets (<code class="language-plaintext highlighter-rouge">set[...]</code>). See Appendix A for the full grammar.</p>

<p>Each element of a Set Value MUST be a Value.</p>

<p>A Set Value MUST permit nesting.</p>

<p>A Set Value MUST NOT require all elements to have the same Value kind.</p>

<p>A Set Value MUST contain no duplicate elements.</p>

<p>Duplicate elements MUST be determined using the Value equality relation in §5.13.</p>

<p>If a set literal spelling contains duplicate elements, Codex-conforming tools MUST reject that spelling with a <code class="language-plaintext highlighter-rouge">ParseError</code> (§14).</p>

<p>For schema-level type constraints on set contents, see §5.18.</p>

<h3 id="515-map-values">5.15 Map Values</h3>

<p>A Map Value is a collection of key-value pairs. Map Values have no semantic ordering; however, in canonical surface form, entries MUST be serialized in the order they appear in the source spelling.</p>

<p>In the Surface Form, Map Values MUST be spelled using the <code class="language-plaintext highlighter-rouge">map</code> keyword followed by square brackets containing <code class="language-plaintext highlighter-rouge">key: value</code> entries (<code class="language-plaintext highlighter-rouge">map[key: value, ...]</code>). See Appendix A for the full grammar.</p>

<p>A Map Value MUST permit zero entries.</p>

<p>Each entry in a Map Value MUST bind exactly one key to exactly one Value.</p>

<p>A Map Value MUST permit nesting.</p>

<p>A Map Value MUST contain no duplicate keys.</p>

<p>Duplicate keys MUST be determined using the Value equality relation in §5.13.</p>

<p>If a map literal spelling contains duplicate keys, Codex-conforming tools MUST reject that spelling with a <code class="language-plaintext highlighter-rouge">ParseError</code> (§14).</p>

<p>For schema-level type constraints on map keys and values, see §5.18.</p>

<h4 id="5151-map-keys">5.15.1 Map Keys</h4>

<p>In the Surface Form, a map key MUST be one of:</p>

<ul>
  <li>an unquoted identifier key</li>
  <li>a String Value</li>
  <li>a Character Value</li>
  <li>an integer Numeric Value</li>
  <li>an Enumerated Token Value</li>
</ul>

<p>An unquoted identifier key MUST use camelCase.</p>

<h3 id="516-tuple-values">5.16 Tuple Values</h3>

<p>A Tuple Value is an ordered sequence of one or more Value elements with positional semantics.</p>

<p>In the Surface Form, Tuple Values MUST be spelled using parentheses (<code class="language-plaintext highlighter-rouge">(...)</code>). See Appendix A for the full grammar.</p>

<p>A Tuple Value MUST contain at least one element.</p>

<p>Each element of a Tuple Value MUST be a Value.</p>

<p>A Tuple Value MUST permit nesting.</p>

<p>A Tuple Value MUST NOT require all elements to have the same Value kind.</p>

<p>For any Tuple Value used by a Trait, the governing schema MUST define the required arity and the meaning of each position.</p>

<p>For schema-level type constraints on tuple positions, see §5.18.</p>

<h3 id="517-range-values">5.17 Range Values</h3>

<p>A Range Value is a declarative interval.</p>

<p>In the Surface Form, Range Values MUST be spelled using <code class="language-plaintext highlighter-rouge">..</code> between endpoints, with an optional <code class="language-plaintext highlighter-rouge">s</code> suffix for step (<code class="language-plaintext highlighter-rouge">x..y</code> or <code class="language-plaintext highlighter-rouge">x..ysz</code> where <code class="language-plaintext highlighter-rouge">x</code> is the starting value, <code class="language-plaintext highlighter-rouge">y</code> is the ending value, and <code class="language-plaintext highlighter-rouge">z</code> is the step). See Appendix A for the full grammar.</p>

<p>A Range Value MUST contain a start endpoint and an end endpoint.</p>

<p>The start endpoint and end endpoint MUST be Values of the same base Value kind (e.g., both Integer, both String), independent of any parameterized type constraints.</p>

<p>A Range Value MUST contain either zero steps or one step.</p>

<p>If a step is present, the governing schema MUST define which Value kinds are valid for the step.</p>

<p>Range endpoints MUST be treated as inclusive.</p>

<p>Codex-conforming tools MUST NOT enumerate Range Values.</p>

<p>The semantics of a Range Value beyond these structural requirements MUST be defined by the governing schema or consuming system.</p>

<p>For schema-level type constraints on range bounds, see §5.18.</p>

<h3 id="518-parameterized-value-types">5.18 Parameterized Value Types</h3>

<p>This section defines parameterized forms of collection value types, which constrain the types of their contents.</p>

<h4 id="5181-syntax">5.18.1 Syntax</h4>

<p>A parameterized value type consists of a base type token followed by type arguments in angle brackets.</p>

<p>The following collection types support parameterization:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$List&lt;T&gt;</code> — a list where each item conforms to <code class="language-plaintext highlighter-rouge">T</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Set&lt;T&gt;</code> — a set where each item conforms to <code class="language-plaintext highlighter-rouge">T</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Map&lt;K, V&gt;</code> — a map where keys conform to <code class="language-plaintext highlighter-rouge">K</code> and values conform to <code class="language-plaintext highlighter-rouge">V</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Tuple&lt;T1, T2, ...&gt;</code> — a tuple where each position conforms to its corresponding type</li>
  <li><code class="language-plaintext highlighter-rouge">$Range&lt;T&gt;</code> — a range where bounds conform to <code class="language-plaintext highlighter-rouge">T</code></li>
</ul>

<h4 id="5182-type-arguments">5.18.2 Type Arguments</h4>

<p>A type argument MUST be one of:</p>

<ul>
  <li>A simple value type token (e.g., <code class="language-plaintext highlighter-rouge">$String</code>)</li>
  <li>A parameterized value type (e.g., <code class="language-plaintext highlighter-rouge">$List&lt;$String&gt;</code>)</li>
  <li>A type union (e.g., <code class="language-plaintext highlighter-rouge">[$String, $Integer]</code>)</li>
</ul>

<p>A type union is a bracketed, comma-separated list of value type tokens. A value conforms to a type union if it conforms to any member type.</p>

<p>Type arguments MUST NOT contain whitespace.</p>

<h4 id="5183-unparameterized-collection-types">5.18.3 Unparameterized Collection Types</h4>

<p>An unparameterized collection type (e.g., <code class="language-plaintext highlighter-rouge">$List</code> without <code class="language-plaintext highlighter-rouge">&lt;...&gt;</code>) permits items of any value type.</p>

<h4 id="5184-nesting">5.18.4 Nesting</h4>

<p>There is no limit on the nesting depth of parameterized types.</p>

<p>For example, <code class="language-plaintext highlighter-rouge">$List&lt;$List&lt;$String&gt;&gt;</code> specifies a list of lists of strings.</p>

<h4 id="5185-examples">5.18.5 Examples</h4>

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">$List&lt;$String&gt;</code></td>
      <td>List of strings</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">$List&lt;[$String, $Boolean]&gt;</code></td>
      <td>List where each item is a string or boolean</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">$Set&lt;$Integer&gt;</code></td>
      <td>Set of integers</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">$Map&lt;$String, $List&lt;$Integer&gt;&gt;</code></td>
      <td>Map from strings to lists of integers</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">$Tuple&lt;$String, $Integer, $Boolean&gt;</code></td>
      <td>3-tuple: (string, integer, boolean)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">$Range&lt;$Integer&gt;</code></td>
      <td>Range with integer bounds</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">$List</code></td>
      <td>List of any values (unparameterized)</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="6-identity">6. Identity</h2>

<h3 id="61-overview">6.1 Overview</h3>

<p>Codex provides two mechanisms for referencing Concepts:</p>

<table>
  <thead>
    <tr>
      <th>Mechanism</th>
      <th>Trait</th>
      <th>Value Type</th>
      <th>Scope</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Entity Identity</td>
      <td><code class="language-plaintext highlighter-rouge">id</code></td>
      <td>IRI Reference Value (§5.9)</td>
      <td>Global</td>
    </tr>
    <tr>
      <td>Concept Key</td>
      <td><code class="language-plaintext highlighter-rouge">key</code></td>
      <td>Lookup Token Value (§5.10)</td>
      <td>Document</td>
    </tr>
  </tbody>
</table>

<h3 id="62-entity-identity">6.2 Entity Identity</h3>

<h4 id="621-the-id-trait">6.2.1 The <code class="language-plaintext highlighter-rouge">id</code> Trait</h4>

<p>Every Entity MUST have exactly one <code class="language-plaintext highlighter-rouge">id</code> trait.</p>

<p>Every non-Entity MUST NOT have an <code class="language-plaintext highlighter-rouge">id</code> trait.</p>

<p>The value of an <code class="language-plaintext highlighter-rouge">id</code> trait MUST be an IRI Reference Value (§5.9).</p>

<p>Codex-conforming tools MUST NOT synthesize an <code class="language-plaintext highlighter-rouge">id</code> trait.</p>

<h4 id="622-uniqueness">6.2.2 Uniqueness</h4>

<p>Within a single document, each <code class="language-plaintext highlighter-rouge">id</code> value MUST be unique across all Entities. If a document contains duplicate <code class="language-plaintext highlighter-rouge">id</code> values, Codex-conforming tools MUST reject that document with an <code class="language-plaintext highlighter-rouge">IdentityError</code> (§14).</p>

<p>Codex does not define a mechanism to enforce cross-document uniqueness; however, <code class="language-plaintext highlighter-rouge">id</code> values serve as RDF subject identifiers in triple stores and are expected to be globally unique in practice.</p>

<h4 id="623-stability">6.2.3 Stability</h4>

<p>Once an <code class="language-plaintext highlighter-rouge">id</code> value is assigned to an Entity, that <code class="language-plaintext highlighter-rouge">id</code> value MUST continue to refer to the same Entity.</p>

<p>Changing an Entity’s <code class="language-plaintext highlighter-rouge">id</code> value MUST be treated as creating a new Entity.</p>

<h3 id="63-concept-keys">6.3 Concept Keys</h3>

<h4 id="631-the-key-trait">6.3.1 The <code class="language-plaintext highlighter-rouge">key</code> Trait</h4>

<p>A Concept MUST have zero or one <code class="language-plaintext highlighter-rouge">key</code> traits.</p>

<p>The value of a <code class="language-plaintext highlighter-rouge">key</code> trait MUST be a Lookup Token Value (§5.10).</p>

<p>Codex-conforming tools MUST NOT synthesize a <code class="language-plaintext highlighter-rouge">key</code> trait.</p>

<h4 id="632-uniqueness">6.3.2 Uniqueness</h4>

<p>Within a single document, each <code class="language-plaintext highlighter-rouge">key</code> value MUST be unique across all Concepts. If a document contains duplicate <code class="language-plaintext highlighter-rouge">key</code> values, Codex-conforming tools MUST reject that document with an <code class="language-plaintext highlighter-rouge">IdentityError</code> (§14).</p>

<p>Concept keys have document scope; cross-document key references are not defined by this specification.</p>

<h4 id="633-resolution">6.3.3 Resolution</h4>

<p>When a Lookup Token Value appears as a reference trait value, resolution to an Entity <code class="language-plaintext highlighter-rouge">id</code> is performed via the binding mechanism defined in §9.8.</p>

<hr />

<h2 id="7-reference-traits">7. Reference Traits</h2>

<h3 id="71-reference-traits-overview">7.1 Reference Traits Overview</h3>

<p>Codex defines exactly three reference Traits:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">reference</code></li>
  <li><code class="language-plaintext highlighter-rouge">target</code></li>
  <li><code class="language-plaintext highlighter-rouge">for</code></li>
</ul>

<p>Each reference Trait expresses a declarative relationship from a Concept instance to another Concept instance, identified by identity reference.</p>

<p>An identity reference is either an Entity <code class="language-plaintext highlighter-rouge">id</code> (an IRI Reference Value; §6.2) or a Concept <code class="language-plaintext highlighter-rouge">key</code> (a Lookup Token Value; §6.3) that is resolved as explicitly defined by this specification and the governing schema.</p>

<p>The value of each reference Trait MUST be either an IRI Reference Value (see §5.9) or a Lookup Token Value (see §5.10).</p>

<p>The value of a reference Trait MUST NOT be any other Value kind.</p>

<p>Reference Traits MUST be interpreted only as declarative relationships.</p>

<p>Reference Traits MUST NOT imply dereferencing, loading, execution, or transformation.</p>

<p>Reference Traits MUST NOT imply any automatic or external resolution beyond what is explicitly defined by this specification or the governing schema.</p>

<p>A Concept instance MUST NOT declare a reference Trait unless authorized by the governing schema.</p>

<p>Where reference Traits are authorized, the governing schema MUST define any additional semantics beyond the intent statements in this section.</p>

<p>The intent statements in §7.2–7.4 guide schema authors but are not normative requirements.</p>

<h3 id="72-reference">7.2 <code class="language-plaintext highlighter-rouge">reference</code></h3>

<p>The <code class="language-plaintext highlighter-rouge">reference</code> Trait expresses that a Concept instance mentions or depends on another Concept instance for meaning.</p>

<p>The <code class="language-plaintext highlighter-rouge">reference</code> Trait MUST NOT imply action, application, scope, execution, or transformation.</p>

<h3 id="73-target">7.3 <code class="language-plaintext highlighter-rouge">target</code></h3>

<p>The <code class="language-plaintext highlighter-rouge">target</code> Trait expresses that a Concept instance is about, applied to, or oriented toward another Concept instance.</p>

<h3 id="74-for">7.4 <code class="language-plaintext highlighter-rouge">for</code></h3>

<p>The <code class="language-plaintext highlighter-rouge">for</code> Trait expresses applicability, scope, specialization, or intended domain.</p>

<p>If a <code class="language-plaintext highlighter-rouge">for</code> reference is used to denote a Concept type, it MUST reference the <code class="language-plaintext highlighter-rouge">ConceptDefinition</code> Entity for that Concept by identity reference.</p>

<h3 id="75-singleton-rule">7.5 Singleton Rule</h3>

<p>If a governing schema requires that at most one of <code class="language-plaintext highlighter-rouge">reference</code>, <code class="language-plaintext highlighter-rouge">target</code>, or <code class="language-plaintext highlighter-rouge">for</code> be present on a Concept instance, it MUST express that requirement using <code class="language-plaintext highlighter-rouge">ReferenceConstraint(type=ReferenceSingleton)</code>.</p>

<p>If a governing schema authorizes more than one reference Trait on the same Concept instance, it MUST document the permitted combinations and the intended interpretation.</p>

<h3 id="76-examples-informative">7.6 Examples (Informative)</h3>

<p>This section is informative.</p>

<p>Example: using <code class="language-plaintext highlighter-rouge">reference</code> for a citation-like relationship.</p>

<p>In this example, <code class="language-plaintext highlighter-rouge">Footnote</code> mentions (and depends on) <code class="language-plaintext highlighter-rouge">Source</code> for meaning, but does not apply to it.</p>

<pre><code class="language-cdx">&lt;Source id=source:HobbitFirstEdition title="The Hobbit" /&gt;

&lt;Footnote
	id=note:fn1
	reference=source:HobbitFirstEdition
	text="First published in 1937."
/&gt;
</code></pre>

<p>Example: using <code class="language-plaintext highlighter-rouge">target</code> for an about/applied-to relationship.</p>

<p>In this example, <code class="language-plaintext highlighter-rouge">Tag</code> is applied to (is about) the <code class="language-plaintext highlighter-rouge">Book</code> Concept instance.</p>

<pre><code class="language-cdx">&lt;Bindings&gt;
	&lt;Bind key=~hobbit id=book:TheHobbit /&gt;
&lt;/Bindings&gt;

&lt;Book id=book:TheHobbit title="The Hobbit" /&gt;

&lt;Tag id=tag:classicFantasy target=~hobbit name=$classicFantasy /&gt;
</code></pre>

<p>Example: using <code class="language-plaintext highlighter-rouge">for</code> to scope a rule/policy to a Concept type.</p>

<p>In this example, <code class="language-plaintext highlighter-rouge">LabelPolicy</code> is not about a particular <code class="language-plaintext highlighter-rouge">Book</code> instance; it is intended to apply to the <code class="language-plaintext highlighter-rouge">Book</code> Concept type.</p>

<pre><code class="language-cdx">&lt;Bindings&gt;
	&lt;Bind key=~book id=concept:Book /&gt;
&lt;/Bindings&gt;

&lt;ConceptDefinition id=concept:Book name="Book" /&gt;

&lt;LabelPolicy id=policy:BookLabels for=concept:Book /&gt;
&lt;LabelPolicy id=policy:BookLabelsAlt for=~book /&gt;
</code></pre>

<p>Example (invalid unless explicitly authorized by schema): a single Concept instance declares both <code class="language-plaintext highlighter-rouge">reference</code> and <code class="language-plaintext highlighter-rouge">target</code>.</p>

<pre><code class="language-cdx">&lt;Link id=link:1 reference=source:HobbitFirstEdition target=book:TheHobbit /&gt;
</code></pre>

<hr />

<h2 id="8-surface-form">8. Surface Form</h2>

<h3 id="81-file-encoding">8.1 File Encoding</h3>

<p>Codex documents MUST be encoded in UTF-8 or UTF-16.</p>

<p>UTF-8 is the default encoding.</p>

<p>UTF-8 encoded files MUST NOT include a Byte Order Mark (BOM).</p>

<p>UTF-16 encoding MUST be indicated by a BOM at the start of the file:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FE FF</code> (2 bytes) indicates UTF-16 Big Endian.</li>
  <li><code class="language-plaintext highlighter-rouge">FF FE</code> (2 bytes) indicates UTF-16 Little Endian.</li>
</ul>

<p>Codex-conforming tools MUST determine the file encoding as follows:</p>

<ul>
  <li>If the file starts with <code class="language-plaintext highlighter-rouge">FE FF</code>, interpret the file as UTF-16 Big Endian.</li>
  <li>If the file starts with <code class="language-plaintext highlighter-rouge">FF FE</code>, interpret the file as UTF-16 Little Endian.</li>
  <li>Otherwise, interpret the file as UTF-8 with no BOM.</li>
</ul>

<p>Codex-conforming tools MUST reject any other encoding with a <code class="language-plaintext highlighter-rouge">ParseError</code> (§14).</p>

<h3 id="82-line-endings">8.2 Line Endings</h3>

<p>The canonical line ending is LF (<code class="language-plaintext highlighter-rouge">\n</code>, U+000A).</p>

<p>Codex-conforming tools MUST normalize CRLF (<code class="language-plaintext highlighter-rouge">\r\n</code>) sequences to LF on input.</p>

<p>Codex-conforming tools MUST reject bare CR (<code class="language-plaintext highlighter-rouge">\r</code>) with a <code class="language-plaintext highlighter-rouge">ParseError</code> (§14).</p>

<p>In canonical surface form, a Codex document MUST end with a trailing LF.</p>

<h3 id="83-indentation">8.3 Indentation</h3>

<p>Indentation is a canonical formatting requirement.</p>

<p>In canonical surface form, one tab character represents one level of nesting.</p>

<ul>
  <li>A root Concept instance MUST have no indentation (column 0).</li>
  <li>Direct children of a root Concept instance MUST be indented by exactly one tab.</li>
  <li>Each additional nesting level MUST increase indentation by exactly one additional tab.</li>
</ul>

<p>Codex-conforming formatters MUST normalize indentation before semantic validation proceeds.</p>

<p>Codex-conforming tools MUST NOT treat author indentation as authoritative.</p>

<p>In the Surface Form, indentation MUST use U+0009 TAB characters only.</p>

<p>Codex-conforming tools MUST reject any U+0020 SPACE character that appears in the indentation prefix of any of the following lines with a <code class="language-plaintext highlighter-rouge">ParseError</code> (§14):</p>

<ul>
  <li>Concept marker lines</li>
  <li>Trait lines (including multi-line trait layout)</li>
  <li>non-blank content lines</li>
</ul>

<p>If indentation cannot be normalized deterministically, Codex-conforming tools MUST fail with a <code class="language-plaintext highlighter-rouge">FormattingError</code> (§14).</p>

<h3 id="84-blank-lines">8.4 Blank Lines</h3>

<p>Blank lines are a canonical formatting requirement.</p>

<p>In canonical surface form, a Codex document MUST NOT start with a blank line.</p>

<p>Outside of content blocks (see §8.8) and annotations (see §8.9), Codex-conforming tools MUST NOT produce two consecutive blank lines in canonical surface form.</p>

<p>In canonical surface form, if no grouping or general annotations appear between two sibling Concept instances, there MUST be exactly one blank line between them.</p>

<p>For the purposes of this rule, an attached-annotation stack (see §8.9.6.1) MUST be treated as part of the Concept instance it attaches to.</p>

<p>If grouping or general annotations appear between two sibling Concept instances, blank line requirements are governed by the annotation rules (see §8.9.8).</p>

<p>In canonical surface form, blank line restrictions apply only to structure parsed as child Concepts.</p>

<p>Outside of annotations (see §8.9) and content, a blank line MUST NOT appear in any other location within a Concept instance body interpreted as containing child Concepts.</p>

<p>In canonical surface form, Codex-conforming tools MUST reject documents containing any of the following with a <code class="language-plaintext highlighter-rouge">FormattingError</code> (§14):</p>

<ul>
  <li>A blank line between a Concept instance’s opening marker and its first child.</li>
  <li>A blank line between a Concept instance’s last child and its closing marker.</li>
  <li>A blank line within a Concept instance body except between sibling children.</li>
</ul>

<p>A blank line is a line containing no characters after normalization.</p>

<p>Codex-conforming tools MUST treat a line containing only whitespace as empty after normalization.</p>

<p>Annotation blank-line rules MUST be defined by the rules for annotations (see §8.9).</p>

<p>Blank line restrictions in this section MUST NOT be applied to content.</p>

<h3 id="85-concept-markers">8.5 Concept Markers</h3>

<p>A Concept instance MUST be delimited by a Concept marker.</p>

<p>Codex defines three Concept marker forms:</p>

<ul>
  <li>Opening marker</li>
  <li>Closing marker</li>
  <li>Self-closing marker</li>
</ul>

<h4 id="851-opening-marker">8.5.1 Opening Marker</h4>

<p>An opening marker MUST be spelled as:</p>

<pre><code class="language-cdx">&lt;ConceptName&gt;
&lt;ConceptName trait=value&gt;
</code></pre>

<p><code class="language-plaintext highlighter-rouge">ConceptName</code> MUST follow the naming rules defined by this specification.</p>

<p>An opening marker includes zero or more Traits.</p>

<p>If multiple Traits are present, their order MUST be preserved.</p>

<h4 id="852-closing-marker">8.5.2 Closing Marker</h4>

<p>A closing marker MUST be spelled as:</p>

<pre><code class="language-cdx">&lt;/ConceptName&gt;
</code></pre>

<p>The closing marker MUST match the most recent unclosed opening marker (see §3.6).</p>

<p>The closing marker MUST appear on its own line after indentation.</p>

<p>Additional content MUST NOT appear on the closing marker line.</p>

<h4 id="853-self-closing-marker">8.5.3 Self-Closing Marker</h4>

<p>A self-closing marker MUST be spelled as:</p>

<pre><code class="language-cdx">&lt;ConceptName /&gt;
&lt;ConceptName trait=value /&gt;
</code></pre>

<p>A self-closing marker represents a Concept instance with no content and no child Concepts.</p>

<p>A self-closing marker includes zero or more Traits.</p>

<h4 id="854-empty-block-concepts">8.5.4 Empty Block Concepts</h4>

<p>Codex-conforming tools MUST reject the form <code class="language-plaintext highlighter-rouge">&lt;ConceptName&gt;&lt;/ConceptName&gt;</code> with a <code class="language-plaintext highlighter-rouge">ParseError</code> (§14).</p>

<p>To represent a deliberately empty Concept instance, authors MUST use self-closing form.</p>

<h3 id="86-traits">8.6 Traits</h3>

<p>A Trait MUST be spelled as:</p>

<pre><code class="language-cdx">traitName=value
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">traitName</code> MUST follow the naming rules defined by this specification.</p>

<p>The <code class="language-plaintext highlighter-rouge">value</code> MUST be a Value as defined by this specification.</p>

<p>No whitespace is permitted around <code class="language-plaintext highlighter-rouge">=</code>.</p>

<p>Traits MUST be separated by whitespace (space or newline).</p>

<p>If multiple Traits are present, their order MUST be preserved.</p>

<h4 id="861-canonical-trait-formatting">8.6.1 Canonical Trait Formatting</h4>

<p>Canonical surface form for Traits depends on the number of Traits present in a Concept opening marker.</p>

<p>If a Concept opening marker has one or two Traits, the Traits MUST appear on a single line.</p>

<p>If a Concept opening marker has three or more Traits, each Trait MUST appear on its own line.</p>

<p>When Traits are written on multiple lines, each Trait line MUST be indented exactly one nesting level deeper than the Concept marker.</p>

<p>When Traits are written on multiple lines, the closing <code class="language-plaintext highlighter-rouge">&gt;</code> or <code class="language-plaintext highlighter-rouge">/&gt;</code> MUST appear on its own line at the same indentation level as the opening <code class="language-plaintext highlighter-rouge">&lt;</code>.</p>

<p>Example (canonical multiline opening marker):</p>

<pre><code class="language-cdx">&lt;Book
	id=book:TheHobbit
	title="The Hobbit"
	author="J.R.R. Tolkien"
&gt;
	[children here]
&lt;/Book&gt;
</code></pre>

<p>Example (canonical multiline self-closing marker):</p>

<pre><code class="language-cdx">&lt;Book
	id=book:TheHobbit
	title="The Hobbit"
	author="J.R.R. Tolkien"
/&gt;
</code></pre>

<h3 id="87-values-surface-parsing-notes">8.7 Values (Surface Parsing Notes)</h3>

<p>In the Surface Form, Trait values are literal spellings of Value types defined by this specification (see §5).</p>

<p>Codex-conforming tools MUST parse Values mechanically.</p>

<p>Codex-conforming tools MUST NOT evaluate, interpret, or normalize Values beyond recognizing their Value type and literal structure.</p>

<p>A Trait value spelling MUST match exactly one Value spelling defined by this specification (see §5).</p>

<p>If a Trait value spelling does not match any Value spelling defined by this specification, Codex-conforming tools MUST reject it with a <code class="language-plaintext highlighter-rouge">ParseError</code> (§14).</p>

<p>Codex-conforming tools MUST NOT infer a Value type.</p>

<p>Codex-conforming tools MUST NOT coerce one Value type into another.</p>

<p>Within a Concept marker, a Value MUST terminate at the first of the following:</p>

<ul>
  <li>whitespace outside balanced delimiters (space, tab, or newline)</li>
  <li><code class="language-plaintext highlighter-rouge">&gt;</code> or <code class="language-plaintext highlighter-rouge">/&gt;</code> (end of Concept marker)</li>
</ul>

<p>While scanning for Value termination, Codex-conforming tools MUST respect balanced delimiters as required by the Value spellings and the grammar, including <code class="language-plaintext highlighter-rouge">[]</code>, <code class="language-plaintext highlighter-rouge">{}</code>, <code class="language-plaintext highlighter-rouge">()</code>, <code class="language-plaintext highlighter-rouge">''</code>, and <code class="language-plaintext highlighter-rouge">""</code>.</p>

<p>Except where permitted by a Value spelling (for example, within string and character literals), leading and trailing whitespace MUST NOT be treated as part of a Value.</p>

<h3 id="871-multiline-value-literals">8.7.1 Multiline Value Literals</h3>

<p>Codex-conforming tools MUST accept multiline spellings for Value literals that use balanced delimiters, including list (<code class="language-plaintext highlighter-rouge">[...]</code>), set (<code class="language-plaintext highlighter-rouge">set[...]</code>), map (<code class="language-plaintext highlighter-rouge">map[...]</code>), tuple (<code class="language-plaintext highlighter-rouge">(...)</code>), and range forms.</p>

<p>Within a balanced Value literal:</p>

<ul>
  <li>Line breaks are treated as whitespace.</li>
  <li>Whitespace between elements, entries, or delimiters is not significant.</li>
  <li>Whitespace MUST NOT terminate the Value.</li>
</ul>

<p>Outside of balanced delimiters, a Value literal MUST be fully contained on a single line.</p>

<p>Codex-conforming tools MUST determine Value boundaries solely by balanced delimiter matching and MUST NOT treat line boundaries as semantically significant within a Value literal.</p>

<h3 id="88-content-blocks">8.8 Content Blocks</h3>

<p>A Content Block is opaque text between an opening marker and a closing marker.</p>

<p>Content is not a Value.</p>

<p>Content MUST NOT be interpreted as Codex structure, Traits, or Values.</p>

<p>In canonical surface form, content lines MUST be indented one nesting level deeper than their enclosing Concept instance.</p>

<p>Content can contain blank lines and can span multiple lines.</p>

<h4 id="881-content-termination">8.8.1 Content Termination</h4>

<p>Codex-conforming tools MUST identify the end of content by scanning for the closing marker that matches the opening Concept name: <code class="language-plaintext highlighter-rouge">&lt;/ConceptName&gt;</code>.</p>

<h4 id="882-content-escaping">8.8.2 Content Escaping</h4>

<p>Within content:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">\&lt;</code> represents a literal <code class="language-plaintext highlighter-rouge">&lt;</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">\[</code> represents a literal <code class="language-plaintext highlighter-rouge">[</code>.</li>
</ul>

<p>A backslash not immediately followed by <code class="language-plaintext highlighter-rouge">&lt;</code> or <code class="language-plaintext highlighter-rouge">[</code> is a literal backslash and has no special meaning.</p>

<p>A raw <code class="language-plaintext highlighter-rouge">&lt;</code> character MUST NOT appear anywhere in content.</p>

<p>A raw <code class="language-plaintext highlighter-rouge">[</code> character MUST NOT appear as the first non-indentation character of a content line. This preserves schema-less determinism of content-versus-children body mode (see §10.2.1.1).</p>

<p>Codex-conforming tools MUST reject violations of these content escaping rules with a <code class="language-plaintext highlighter-rouge">ParseError</code> (§14).</p>

<h4 id="883-content-indentation-normalization">8.8.3 Content Indentation Normalization</h4>

<p>Codex-conforming tools MUST store and process content without its canonical leading indentation.</p>

<p>In canonical surface form, each non-blank content line MUST be indented exactly one nesting level deeper than its enclosing Concept instance.</p>

<p>For each non-blank content line, the canonical leading indentation is the exact leading indentation required to place that line at one nesting level deeper than its enclosing Concept instance.</p>

<p>Codex-conforming tools MUST remove exactly that canonical leading indentation from each non-blank content line when producing the logical content.</p>

<p>Codex-conforming tools MUST preserve all characters following the removed indentation, including any additional leading whitespace.</p>

<p>If a non-blank content line does not have the required canonical leading indentation after indentation normalization, Codex-conforming tools MUST fail with a <code class="language-plaintext highlighter-rouge">FormattingError</code> (§14).</p>

<p>Indentation normalization is schema-free and MUST be performed before schema-directed processing.</p>

<h4 id="884-whitespace-mode-normalization">8.8.4 Whitespace Mode Normalization</h4>

<p>Whitespace mode normalization is schema-directed and MUST be performed during schema-directed processing.</p>

<p>The governing schema declares <code class="language-plaintext highlighter-rouge">whitespaceMode</code> on each Concept that allows content (see §11.4.2).</p>

<p>For <code class="language-plaintext highlighter-rouge">whitespaceMode=$Preformatted</code>:</p>

<ul>
  <li>Codex-conforming tools MUST preserve all content whitespace exactly after indentation normalization.</li>
</ul>

<p>For <code class="language-plaintext highlighter-rouge">whitespaceMode=$Flow</code>:</p>

<ul>
  <li>Codex-conforming tools MUST collapse each run of whitespace characters (spaces, tabs, and line breaks) to a single U+0020 SPACE.</li>
  <li>Codex-conforming tools MUST trim leading and trailing whitespace from the resulting content.</li>
  <li>In canonical surface form, Codex-conforming tools MUST wrap content to lines of at most 100 Unicode scalar values, breaking at whitespace boundaries. If a non-breakable sequence exceeds 100 Unicode scalar values, it MUST appear on its own line without wrapping.</li>
  <li>Each wrapped line MUST be indented exactly one nesting level deeper than the enclosing Concept instance.</li>
</ul>

<p>Schema-less processing MUST treat all content as <code class="language-plaintext highlighter-rouge">$Preformatted</code> (preserve all whitespace after indentation normalization).</p>

<h4 id="885-examples-informative">8.8.5 Examples (Informative)</h4>

<p>This section is informative.</p>

<p>Example: indentation stripping while preserving whitespace-sensitive content.</p>

<p>This example assumes <code class="language-plaintext highlighter-rouge">Verse</code> is defined with <code class="language-plaintext highlighter-rouge">whitespaceMode=$Preformatted</code>.</p>

<pre><code class="language-cdx">&lt;Verse&gt;
	Buffalo Bill 's
	defunct
	        who used to
	        ride a watersmooth-silver
	                                  stallion
	and break onetwothreefourfive pigeonsjustlikethat
	                                                  Jesus

	he was a handsome man
	                      and what i want to know is
	how do you like your blueeyed boy
	Mister Death
&lt;/Verse&gt;
</code></pre>

<p>The logical content is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Buffalo Bill 's
defunct
        who used to
        ride a watersmooth-silver
                                  stallion
and break onetwothreefourfive pigeonsjustlikethat
                                                  Jesus

he was a handsome man
                      and what i want to know is
how do you like your blueeyed boy
Mister Death
</code></pre></div></div>

<p>(Poem: “Buffalo Bill ‘s” by e.e. cummings)</p>

<p>Example: escaping <code class="language-plaintext highlighter-rouge">&lt;</code> inside content.</p>

<pre><code class="language-cdx">&lt;Tutorial&gt;
	&lt;Section title="Writing Descriptions"&gt;
		To write a description, use the Description Concept:

		\&lt;Description&gt;Your text here.\&lt;/Description&gt;

		The text inside is opaque content.
	&lt;/Section&gt;
&lt;/Tutorial&gt;
</code></pre>

<p>Example: escaping <code class="language-plaintext highlighter-rouge">[</code> at the start of a content line.</p>

<pre><code class="language-cdx">&lt;Note&gt;
	\[1] This footnote reference starts with a bracket.
	Normal [bracketed] text mid-line needs no escaping.
&lt;/Note&gt;
</code></pre>

<h3 id="89-annotations">8.9 Annotations</h3>

<p>Annotations are editorial metadata, distinct from Values and content.</p>

<p>Codex-conforming tools MUST preserve annotations without interpretation.</p>

<h4 id="891-annotation-forms">8.9.1 Annotation Forms</h4>

<p>Codex defines two surface forms for annotations.</p>

<h5 id="8911-inline-annotation">8.9.1.1 Inline Annotation</h5>

<p>An inline annotation MUST use <code class="language-plaintext highlighter-rouge">[</code> and <code class="language-plaintext highlighter-rouge">]</code> on the same line.</p>

<pre><code class="language-cdx">[Short note]
&lt;Thing /&gt;
</code></pre>

<h5 id="8912-block-annotation">8.9.1.2 Block Annotation</h5>

<p>A block annotation MUST use <code class="language-plaintext highlighter-rouge">[</code> and <code class="language-plaintext highlighter-rouge">]</code> on their own lines.</p>

<pre><code class="language-cdx">[
	A longer note.
	It may include lists:

	- red
	- green
	- blue
]
</code></pre>

<p>Annotations can appear at top-level or within bodies interpreted as containing child Concepts.</p>

<p>Annotations MUST NOT appear inside Concept markers (that is, inside <code class="language-plaintext highlighter-rouge">&lt;Concept …&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;/Concept&gt;</code>, or <code class="language-plaintext highlighter-rouge">&lt;Concept /&gt;</code>).</p>

<p>Annotations can contain arbitrary text, including blank lines (block annotations only).</p>

<h4 id="892-structural-rules">8.9.2 Structural Rules</h4>

<p>The opening <code class="language-plaintext highlighter-rouge">[</code> MUST be the first non-whitespace character on its line.</p>

<p>For an inline annotation, the closing <code class="language-plaintext highlighter-rouge">]</code> MUST appear on the same line.</p>

<p>For a block annotation:</p>

<ul>
  <li>The line containing <code class="language-plaintext highlighter-rouge">[</code> MUST contain no other non-whitespace characters.</li>
  <li>The closing <code class="language-plaintext highlighter-rouge">]</code> MUST appear as the first non-whitespace character on its own line.</li>
  <li>The closing <code class="language-plaintext highlighter-rouge">]</code> line MUST contain no other non-whitespace characters.</li>
</ul>

<h4 id="893-escaping">8.9.3 Escaping</h4>

<p>Within an annotation:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">\]</code> represents a literal <code class="language-plaintext highlighter-rouge">]</code>.</li>
</ul>

<p>A backslash not immediately followed by <code class="language-plaintext highlighter-rouge">]</code> is a literal backslash and has no special meaning.</p>

<h4 id="894-canonical-form">8.9.4 Canonical Form</h4>

<p>Canonicalization of annotations is deterministic and depends on the annotation form.</p>

<h5 id="8941-inline-annotation-canonicalization">8.9.4.1 Inline Annotation Canonicalization</h5>

<p>Codex-conforming tools MUST canonicalize inline annotations as follows:</p>

<ul>
  <li>Leading and trailing whitespace inside the brackets MUST be trimmed.</li>
  <li>Internal runs of whitespace (spaces and tabs) MUST be collapsed to a single space.</li>
  <li>Escaped closing brackets MUST remain escaped (that is, <code class="language-plaintext highlighter-rouge">\]</code> MUST remain spelled as <code class="language-plaintext highlighter-rouge">\]</code>).</li>
</ul>

<p>Canonical rendering MUST use no padding spaces just inside the brackets (for example, <code class="language-plaintext highlighter-rouge">[text]</code>, not <code class="language-plaintext highlighter-rouge">[ text ]</code>).</p>

<h5 id="8942-block-annotation-canonicalization">8.9.4.2 Block Annotation Canonicalization</h5>

<p>Block annotations MUST preserve their internal line structure.</p>

<p>Codex-conforming tools MUST normalize block-annotation line endings to LF.</p>

<p>A block annotation can include a directive (see §8.9.5) that controls additional canonicalization.</p>

<p>For a block annotation with no directive, Codex-conforming tools MUST:</p>

<ul>
  <li>Remove trailing whitespace on each content line.</li>
  <li>Normalize indentation so that the content lines are indented exactly one tab deeper than the <code class="language-plaintext highlighter-rouge">[</code> / <code class="language-plaintext highlighter-rouge">]</code> lines.</li>
</ul>

<h4 id="895-block-annotation-directives">8.9.5 Block Annotation Directives</h4>

<p>In a block annotation, the first non-blank content line can be a directive line.</p>

<p>If present, the directive line MUST be exactly one of:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FLOW:</code></li>
  <li><code class="language-plaintext highlighter-rouge">CODE:</code></li>
  <li><code class="language-plaintext highlighter-rouge">MARKDOWN:</code></li>
</ul>

<p>Directive recognition MUST be performed prior to any canonicalization other than newline normalization.</p>

<p>If present, the directive line MUST be preserved in canonical output.</p>

<p>Directive behavior:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CODE:</code> — Codex-conforming tools MUST preserve the block annotation bytes verbatim except for newline normalization.</li>
  <li><code class="language-plaintext highlighter-rouge">MARKDOWN:</code> — Codex-conforming tools MUST preserve the block annotation bytes verbatim except for newline normalization.</li>
  <li><code class="language-plaintext highlighter-rouge">FLOW:</code> — The flow-text value is the remaining content with leading and trailing whitespace trimmed, internal runs of whitespace collapsed to single spaces, and escapes interpreted per §8.9.3.</li>
</ul>

<p>For <code class="language-plaintext highlighter-rouge">CODE:</code> and <code class="language-plaintext highlighter-rouge">MARKDOWN:</code> directives, Codex-conforming tools MUST NOT reindent, trim, strip trailing whitespace, wrap, or interpret escapes within the block annotation.</p>

<p>If no directive is present, the block annotation MUST be canonicalized as described in §8.9.4.2.</p>

<p>For <code class="language-plaintext highlighter-rouge">FLOW:</code> directives, Codex-conforming tools MUST render canonical output as follows:</p>

<ul>
  <li>Split the remaining content into paragraphs separated by one or more blank lines.</li>
  <li>For each paragraph, wrap words to lines of at most 100 Unicode scalar values using greedy packing. If a non-breakable sequence exceeds 100 Unicode scalar values, it MUST appear on its own line without wrapping.</li>
  <li>Indent each wrapped line exactly one tab deeper than the <code class="language-plaintext highlighter-rouge">[</code> / <code class="language-plaintext highlighter-rouge">]</code> lines.</li>
  <li>Separate paragraphs by exactly one blank line.</li>
</ul>

<h4 id="896-annotation-kinds">8.9.6 Annotation Kinds</h4>

<p>Codex defines three kinds of annotations:</p>

<ol>
  <li>Attached annotations — attach to a single Concept instance.</li>
  <li>Grouping annotations — <code class="language-plaintext highlighter-rouge">GROUP</code> / <code class="language-plaintext highlighter-rouge">END</code> markers that bracket a region.</li>
  <li>General annotations — standalone annotations (inline or block).</li>
</ol>

<h5 id="8961-attached-annotations">8.9.6.1 Attached Annotations</h5>

<p>An annotation is an attached annotation if and only if:</p>

<ul>
  <li>It is not a grouping annotation.</li>
  <li>It appears immediately before a Concept opening marker.</li>
  <li>There is no blank line between the annotation and that marker.</li>
</ul>

<p>An attached annotation can be either inline or block form.</p>

<p>Multiple attached annotations can stack.</p>

<p>Stacked attached annotations MUST be contiguous and MUST NOT be separated by blank lines.</p>

<p>An attached-annotation stack attaches to the next Concept opening marker.</p>

<h5 id="8962-grouping-annotations">8.9.6.2 Grouping Annotations</h5>

<p>A grouping annotation is a single-line annotation whose canonicalized annotation text matches one of the following forms:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">GROUP: &lt;label&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">END: &lt;label&gt;</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">&lt;label&gt;</code> MUST be a non-empty string after trimming.</p>

<p>Grouping recognition MUST be performed after applying the inline annotation canonicalization rules in §8.9.4.1.</p>

<p>Grouping annotations MUST NOT attach to Concept instances.</p>

<p>Grouping annotations define a purely editorial grouping region.</p>

<p>Grouping annotations can nest.</p>

<p>Label comparison MUST use the canonical label form (trimmed, with internal whitespace collapsed to single spaces).</p>

<p>Grouping annotations MUST conform to the canonical blank-line requirements in §8.9.8.</p>

<h5 id="8963-general-annotations">8.9.6.3 General Annotations</h5>

<p>An annotation is a general annotation if and only if:</p>

<ul>
  <li>It is not an attached annotation.</li>
  <li>It is not a grouping annotation.</li>
  <li>It is surrounded by exactly one blank line above and exactly one blank line below, where file boundaries count as blank-line boundaries.</li>
</ul>

<p>A general annotation can be either inline or block form.</p>

<p>General annotations MUST NOT attach to Concept instances.</p>

<h4 id="897-group-nesting-and-matching">8.9.7 Group Nesting and Matching</h4>

<p>Grouping annotations form a properly nested stack.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">[GROUP: X]</code> pushes label <code class="language-plaintext highlighter-rouge">X</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">[END: X]</code> MUST match the most recent unmatched <code class="language-plaintext highlighter-rouge">[GROUP: X]</code>.</li>
</ul>

<p>If an <code class="language-plaintext highlighter-rouge">END</code> label does not match the most recent open group label, or if an <code class="language-plaintext highlighter-rouge">END</code> appears with no open group, Codex-conforming tools MUST reject the document with a <code class="language-plaintext highlighter-rouge">ParseError</code> (§14).</p>

<h4 id="898-canonical-blank-line-requirements">8.9.8 Canonical Blank Line Requirements</h4>

<p>In canonical surface form:</p>

<ul>
  <li>Attached annotations MUST appear directly above the annotated Concept opening marker with no blank line.</li>
  <li>Grouping annotations MUST be surrounded by exactly one blank line above and below, where file boundaries count as blank-line boundaries.</li>
  <li>General annotations MUST be surrounded by exactly one blank line above and below, where file boundaries count as blank-line boundaries.</li>
</ul>

<p>Codex-conforming tools MUST reject any annotation that is neither an attached annotation, a grouping annotation, nor a general annotation with a <code class="language-plaintext highlighter-rouge">ParseError</code> (§14).</p>

<hr />

<h2 id="9-schema-first-architecture">9. Schema-First Architecture</h2>

<p>Codex is schema-first.</p>

<p>A conforming implementation MUST provide schema-directed parsing and validation.</p>

<p>This specification defines the authoritative model for schema authoring, schema-to-instance-graph interpretation, and deterministic projection to derived validation artifacts.</p>

<p>Codex has exactly one semantic model: the canonical RDF representation.</p>

<p>All semantic meaning, validation behavior, and derived artifacts are defined solely in terms of this canonical representation. Authoring modes do not define alternative semantics.</p>

<p>Canonical Authoring Mode permits authors to write the canonical RDF representation directly. Simplified Authoring Mode permits authors to write a Codex-native surface form that has no independent semantics and exists only as a deterministic, lossless authoring convenience; documents written in Simplified Authoring Mode MUST expand to a byte-identical canonical RDF representation.</p>

<p>No other semantic layers, representations, or interpretive stages exist in Codex, and implementations MUST treat the canonical RDF representation as the sole source of truth.</p>

<h3 id="91-scope-and-inputs">9.1 Scope and Inputs</h3>

<p>Semantic processing—including validation, constraint evaluation, and interpretation—requires a governing schema.</p>

<p>Given the same required inputs, a conforming implementation MUST produce the same parsing, validation, and canonicalization results.</p>

<p>The required inputs for schema-directed processing are:</p>

<ul>
  <li>the Codex document bytes</li>
  <li>the governing schema</li>
  <li>any other external inputs explicitly required by this specification or by the governing schema</li>
</ul>

<p>Other external inputs—including environment state, configuration, registries, network access, clocks, or randomness—MUST NOT influence processing.</p>

<p>If any required input is missing, schema-directed processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>Given a Codex document and a governing schema, a conforming implementation MUST dispatch parsing and validation according to that schema.</p>

<h3 id="92-schema-less-formatting--well-formedness-checks">9.2 Schema-Less Formatting / Well-Formedness Checks</h3>

<p>If an implementation performs schema-less checks, it MUST limit those checks to rules that are explicitly defined by this specification as independent of schema semantics.</p>

<p>Schema-less checks are limited to:</p>

<ul>
  <li>determining whether the input bytes can be decoded as a permitted file encoding</li>
  <li>determining whether the input matches the surface-form grammar</li>
  <li>mechanically recognizing and classifying Value spellings into their Value kinds (and any grammar-defined subkinds) using only surface-form grammar rules, without reference to schema-defined value types</li>
  <li>enforcing surface-form structural well-formedness (including marker nesting/matching)</li>
  <li>enforcing surface-form canonicalization rules defined by this specification</li>
</ul>

<p>Schema-less checks MUST NOT include any schema-driven semantic interpretation.</p>

<p>In particular, without a governing schema, an implementation MUST NOT:</p>

<ul>
  <li>interpret content mode versus child mode for a concept beyond what is mechanically implied by the surface form</li>
  <li>interpret whether a concept instance is an Entity beyond the presence or absence of an <code class="language-plaintext highlighter-rouge">id</code> trait spelling</li>
  <li>evaluate trait meaning, trait authorization, expected <code class="language-plaintext highlighter-rouge">ValueType</code> constraints, value typing beyond surface-form Value recognition, or constraint logic</li>
  <li>resolve reference traits beyond their surface-form value type constraints</li>
</ul>

<h3 id="93-schema-required-semantic-validation">9.3 Schema-Required Semantic Validation</h3>

<p>An implementation MUST NOT perform semantic validation without a governing schema.</p>

<p>Given a governing schema, an implementation MUST perform semantic validation as defined by that schema.</p>

<p>Schema-driven semantic validation MUST be explainable in terms of the specific schema rule(s) applied.</p>

<p>Schema-driven semantic validation MUST include evaluation of all schema-defined authorizations and constraints, including at least:</p>

<ul>
  <li>concept authorization and required/forbidden structure</li>
  <li>content mode versus child mode requirements</li>
  <li>trait authorization and required/forbidden traits</li>
  <li>value type constraints beyond surface-form recognition</li>
  <li>entity eligibility and any schema-defined identity constraints</li>
  <li>schema-defined constraints over children, descendants, and collections</li>
  <li>schema-defined reference semantics and any schema-defined resolution requirements</li>
</ul>

<p>If the governing schema requires any external inputs (for example, inputs needed to interpret lookup token bindings or to construct derived validation artifacts), those inputs MUST be explicit and machine-checkable.</p>

<p>The required semantics for schema-driven validation and any required derived artifacts are defined by this specification (notably §9.5–§9.11) and by the schema definition language (§11).</p>

<h3 id="94-authoring-modes">9.4 Authoring Modes</h3>

<p>A schema document MUST be validated under exactly one authoring mode.</p>

<p>Codex defines two authoring modes:</p>

<ul>
  <li><strong>Simplified Authoring Mode</strong>: Codex-native schema-definition authoring surface only (§9.5, §11)</li>
  <li><strong>Canonical Authoring Mode</strong>: Canonical Representation authoring only via <code class="language-plaintext highlighter-rouge">RdfGraph</code> (§9.6)</li>
</ul>

<p>Both modes are mandatory.</p>

<p>All conforming implementations MUST support the Canonical Authoring Mode.</p>

<p>All conforming implementations MUST support the Simplified Authoring Mode.</p>

<p>A schema document MUST NOT mix modes.</p>

<p>The authoring mode MUST be selected by an explicit declaration in the schema document.</p>

<p>The schema document’s root <code class="language-plaintext highlighter-rouge">Schema</code> concept MUST have an <code class="language-plaintext highlighter-rouge">authoringMode</code> trait.</p>

<p><code class="language-plaintext highlighter-rouge">authoringMode</code> MUST be exactly one of:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$SimplifiedMode</code></li>
  <li><code class="language-plaintext highlighter-rouge">$CanonicalMode</code></li>
</ul>

<p>If <code class="language-plaintext highlighter-rouge">authoringMode</code> is missing or has any other value, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>The following mode-specific constraints MUST hold:</p>

<ul>
  <li>Simplified mode schemas MUST contain exactly one <code class="language-plaintext highlighter-rouge">ConceptDefinitions</code> and MUST NOT contain <code class="language-plaintext highlighter-rouge">RdfGraph</code>.</li>
  <li>Canonical mode schemas MUST contain exactly one <code class="language-plaintext highlighter-rouge">RdfGraph</code> and MUST NOT contain Codex-native schema-definition concepts (including <code class="language-plaintext highlighter-rouge">ConceptDefinitions</code>, <code class="language-plaintext highlighter-rouge">TraitDefinitions</code>, <code class="language-plaintext highlighter-rouge">EnumeratedValueSets</code>, <code class="language-plaintext highlighter-rouge">ConstraintDefinitions</code>, <code class="language-plaintext highlighter-rouge">ValueTypeDefinitions</code>, and <code class="language-plaintext highlighter-rouge">ValidatorDefinitions</code>).</li>
  <li>Simplified-mode expansion MUST generate the Canonical Representation as a canonical RDF graph; different simplified spellings that are semantically identical MUST expand to byte-identical canonical RDF graphs.</li>
  <li>Canonicalization of the Canonical Representation MUST make semantically identical graphs byte-identical.</li>
</ul>

<h3 id="95-simplified-authoring-mode-codex-native-schema-authoring-surface">9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface)</h3>

<p>Simplified Authoring Mode is the Codex-native schema-definition authoring surface defined by the schema definition language (§11).</p>

<p>Simplified Authoring Mode MUST satisfy the Codex language invariants, including closed-world semantics, determinism, and prohibition of heuristics.</p>

<p>To support a total, deterministic projection to derived validation artifacts, simplified-mode schema authoring MUST additionally support the following extensions.</p>

<h4 id="951-pattern-flags">9.5.1 Pattern Flags</h4>

<p>The following atomic constraints MUST support an optional <code class="language-plaintext highlighter-rouge">flags</code> trait whose value is a string:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ValueMatchesPattern</code></li>
  <li><code class="language-plaintext highlighter-rouge">PatternConstraint</code></li>
  <li><code class="language-plaintext highlighter-rouge">ContentMatchesPattern</code></li>
</ul>

<p>If <code class="language-plaintext highlighter-rouge">flags</code> is omitted, it MUST be treated as the empty string.</p>

<p>The <code class="language-plaintext highlighter-rouge">pattern</code> and <code class="language-plaintext highlighter-rouge">flags</code> semantics MUST be SPARQL 1.1 <code class="language-plaintext highlighter-rouge">REGEX</code> semantics.</p>

<h4 id="952-explicit-validator-definitions">9.5.2 Explicit Validator Definitions</h4>

<p>Simplified Authoring Mode MUST support explicit validator definitions that make <code class="language-plaintext highlighter-rouge">ValueIsValid</code> deterministic.</p>

<p><code class="language-plaintext highlighter-rouge">ValidatorDefinitions</code> is a container concept.</p>

<p><code class="language-plaintext highlighter-rouge">ValidatorDefinition</code> defines one validator.</p>

<p>Each <code class="language-plaintext highlighter-rouge">ValidatorDefinition</code> MUST have these traits:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">name</code> (required; Enumerated Token Value)</li>
  <li><code class="language-plaintext highlighter-rouge">message</code> (optional; String Value)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">ValidatorDefinition</code> names MUST be unique within the Schema.</p>

<p>Each <code class="language-plaintext highlighter-rouge">ValidatorDefinition</code> MUST be in content mode.</p>

<p>The content of <code class="language-plaintext highlighter-rouge">ValidatorDefinition</code> MUST be a SPARQL <code class="language-plaintext highlighter-rouge">SELECT</code> query string.</p>

<p>The <code class="language-plaintext highlighter-rouge">SELECT</code> results MUST follow the SHACL-SPARQL convention (returning one row per violation with <code class="language-plaintext highlighter-rouge">?this</code> bound to the focus node).</p>

<p>If a derived validation artifact is expressed using SHACL-SPARQL, the embedding contract for <code class="language-plaintext highlighter-rouge">ValueIsValid validatorName=$X</code> MUST be:</p>

<ol>
  <li>Resolve <code class="language-plaintext highlighter-rouge">$X</code> to exactly one <code class="language-plaintext highlighter-rouge">ValidatorDefinition</code> in the governing schema.</li>
  <li>Emit a SHACL-SPARQL constraint whose <code class="language-plaintext highlighter-rouge">sh:select</code> string is exactly the <code class="language-plaintext highlighter-rouge">ValidatorDefinition</code> content.</li>
</ol>

<p>If <code class="language-plaintext highlighter-rouge">$X</code> cannot be resolved to exactly one <code class="language-plaintext highlighter-rouge">ValidatorDefinition</code>, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<h4 id="953-explicit-path-and-quantifier-rule-forms">9.5.3 Explicit Path and Quantifier Rule Forms</h4>

<p>The schema definition language (§11) defines paths (<code class="language-plaintext highlighter-rouge">TraitPath</code>, <code class="language-plaintext highlighter-rouge">ChildPath</code>, <code class="language-plaintext highlighter-rouge">DescendantPath</code>, <code class="language-plaintext highlighter-rouge">ContentPath</code>) and quantifiers (<code class="language-plaintext highlighter-rouge">Exists</code>, <code class="language-plaintext highlighter-rouge">ForAll</code>, <code class="language-plaintext highlighter-rouge">Count</code>) but does not define a concrete rule-node form that composes them with rules.</p>

<p>To produce a total, deterministic mapping, Simplified Authoring Mode MUST provide explicit rule-node forms that bind exactly one path to exactly one nested rule.</p>

<p>Simplified Authoring Mode MUST provide the following rule nodes:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">OnPathExists</code></li>
  <li><code class="language-plaintext highlighter-rouge">OnPathForAll</code></li>
  <li><code class="language-plaintext highlighter-rouge">OnPathCount</code></li>
</ul>

<p>Each of these MUST have exactly one <code class="language-plaintext highlighter-rouge">Path</code> child and exactly one <code class="language-plaintext highlighter-rouge">Rule</code> child.</p>

<p><code class="language-plaintext highlighter-rouge">OnPathCount</code> MUST additionally have:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">minCount</code> (optional; non-negative integer)</li>
  <li><code class="language-plaintext highlighter-rouge">maxCount</code> (optional; positive integer)</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">Path</code> child MUST be exactly one of:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">TraitPath</code></li>
  <li><code class="language-plaintext highlighter-rouge">ChildPath</code></li>
  <li><code class="language-plaintext highlighter-rouge">DescendantPath</code></li>
  <li><code class="language-plaintext highlighter-rouge">ContentPath</code></li>
</ul>

<p>For schema rules that express the common “every direct child of type X satisfies R” pattern, <code class="language-plaintext highlighter-rouge">ChildSatisfies(conceptSelector=X, Rule=R)</code> MUST be interpreted as equivalent to <code class="language-plaintext highlighter-rouge">OnPathForAll(Path=ChildPath(X), Rule=R)</code>.</p>

<h4 id="954-collection-and-order-constraint-scoping">9.5.4 Collection and Order Constraint Scoping</h4>

<p>For each of the following constraint nodes:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CollectionOrdering</code></li>
  <li><code class="language-plaintext highlighter-rouge">CollectionAllowsEmpty</code></li>
  <li><code class="language-plaintext highlighter-rouge">CollectionAllowsDuplicates</code></li>
  <li><code class="language-plaintext highlighter-rouge">MemberCount</code></li>
  <li><code class="language-plaintext highlighter-rouge">EachMemberSatisfies</code></li>
  <li><code class="language-plaintext highlighter-rouge">OrderConstraint</code></li>
</ul>

<p>the constraint node MUST have exactly one <code class="language-plaintext highlighter-rouge">Path</code> child that selects the collection members the constraint applies to.</p>

<p>That member-selection path MUST be either <code class="language-plaintext highlighter-rouge">ChildPath</code> or <code class="language-plaintext highlighter-rouge">DescendantPath</code>.</p>

<p>If the member-selection path is not one of these, expansion MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>For <code class="language-plaintext highlighter-rouge">CollectionAllowsDuplicates</code> with <code class="language-plaintext highlighter-rouge">allowed=false</code>, the constraint node MUST include a required <code class="language-plaintext highlighter-rouge">keyTrait</code> trait whose value is a trait name string.</p>

<p>If <code class="language-plaintext highlighter-rouge">keyTrait</code> is <code class="language-plaintext highlighter-rouge">id</code>, it MUST refer to the declared identifier as specified by the instance-graph identity rules.</p>

<h3 id="96-canonical-representation-rdf--shacl">9.6 Canonical Representation (RDF / SHACL)</h3>

<p>The Canonical Representation of Codex schemas is an RDF 1.1 graph.</p>

<p>The Canonical Representation MUST be able to represent any SHACL graph, including SHACL-SPARQL constraints.</p>

<p>This specification does not define namespace prefixes; the Canonical Representation uses IRIs directly.</p>

<p>The Canonical Representation MUST be deterministic and canonical:</p>

<ul>
  <li>The Canonical Representation MUST NOT contain RDF blank nodes.</li>
  <li>All RDF nodes in the Canonical Representation MUST be IRIs.</li>
  <li>Where SHACL commonly uses blank nodes (for example, <code class="language-plaintext highlighter-rouge">sh:property</code> values and RDF lists), the Canonical Representation MUST use deterministically derived skolem IRIs instead.</li>
  <li>The Canonical Representation MUST be treated as a set of RDF triples.</li>
  <li>The Canonical Representation MUST NOT contain duplicate triples.</li>
</ul>

<h4 id="961-canonical-triple-form">9.6.1 Canonical Triple Form</h4>

<p>When the Canonical Representation is authored as a Codex graph form, it MUST use:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">RdfGraph</code> — container for triples</li>
  <li><code class="language-plaintext highlighter-rouge">RdfTriple</code> — a single RDF triple</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">RdfGraph</code> MUST be in children mode.</p>

<p><code class="language-plaintext highlighter-rouge">RdfGraph</code> children MUST be one or more <code class="language-plaintext highlighter-rouge">RdfTriple</code>.</p>

<p>Each <code class="language-plaintext highlighter-rouge">RdfTriple</code> MUST have these traits:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">s</code> (required; IRI Reference Value) — subject</li>
  <li><code class="language-plaintext highlighter-rouge">p</code> (required; IRI Reference Value) — predicate</li>
</ul>

<p>And exactly one of:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">o</code> (required; IRI Reference Value) — object IRI</li>
  <li><code class="language-plaintext highlighter-rouge">lex</code> (required; String Value) — object literal lexical form</li>
</ul>

<p>When <code class="language-plaintext highlighter-rouge">lex</code> is present, the following additional traits are permitted:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">datatype</code> (optional; IRI Reference Value) — RDF datatype IRI</li>
  <li><code class="language-plaintext highlighter-rouge">language</code> (optional; String Value) — RDF language tag</li>
</ul>

<p>If <code class="language-plaintext highlighter-rouge">language</code> is present, <code class="language-plaintext highlighter-rouge">datatype</code> MUST be absent.</p>

<p>If <code class="language-plaintext highlighter-rouge">datatype</code> is absent and <code class="language-plaintext highlighter-rouge">language</code> is absent, the literal datatype MUST be <code class="language-plaintext highlighter-rouge">xsd:string</code>.</p>

<h4 id="962-canonical-ordering-and-duplicate-removal">9.6.2 Canonical Ordering and Duplicate Removal</h4>

<p>In the canonical RDF graph, <code class="language-plaintext highlighter-rouge">RdfTriple</code> children MUST be sorted in ascending lexicographic order of <code class="language-plaintext highlighter-rouge">(s, p, oKey)</code>.</p>

<p><code class="language-plaintext highlighter-rouge">oKey</code> MUST be:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">o</code> when the object is an IRI, and</li>
  <li>the pair <code class="language-plaintext highlighter-rouge">(datatypeOrDefault, lex)</code> when the object is a literal.</li>
</ul>

<p>If two triples are identical after this normalization, duplicates MUST be removed.</p>

<p>Any algorithm that derives the Canonical Representation or derives SHACL shapes from the Canonical Representation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14) rather than guess when required semantics are not explicitly defined.</p>

<h4 id="963-rdf-list-encoding-no-blank-nodes">9.6.3 RDF List Encoding (No Blank Nodes)</h4>

<p>If the Canonical Representation includes an RDF list (for example, as the object of <code class="language-plaintext highlighter-rouge">sh:in</code>), it MUST be encoded using the standard RDF list vocabulary (<code class="language-plaintext highlighter-rouge">rdf:first</code>, <code class="language-plaintext highlighter-rouge">rdf:rest</code>, <code class="language-plaintext highlighter-rouge">rdf:nil</code>).</p>

<p>All RDF list nodes MUST be IRIs.</p>

<p>Where the RDF list encoding would otherwise use blank nodes, the Canonical Representation MUST use deterministically derived skolem IRIs instead.</p>

<p>For an RDF list attached as the object of a triple <code class="language-plaintext highlighter-rouge">(subject, predicate, _)</code>, list node IRIs MUST be derived as follows:</p>

<ul>
  <li>Let <code class="language-plaintext highlighter-rouge">listAnchor = subject + "/list/" + iriHash(predicate)</code>.</li>
  <li>For the list node at position <code class="language-plaintext highlighter-rouge">i</code> (0-indexed): <code class="language-plaintext highlighter-rouge">listNodeIri(listAnchor, i) = listAnchor + "/" + i</code>.</li>
  <li>The list head is the node at position 0.</li>
  <li>The final list node’s <code class="language-plaintext highlighter-rouge">rdf:rest</code> MUST be <code class="language-plaintext highlighter-rouge">rdf:nil</code>.</li>
</ul>

<h4 id="964-deterministic-iri-hashing">9.6.4 Deterministic IRI Hashing</h4>

<p>When a derived IRI embeds another IRI or name as a path component, the embedded value MUST be hashed to produce a fixed-length, path-safe string.</p>

<p><code class="language-plaintext highlighter-rouge">iriHash(value)</code> MUST be computed as:</p>

<ol>
  <li>Encode the value as a UTF-8 byte sequence.</li>
  <li>Compute the SHA-256 hash of that byte sequence.</li>
  <li>Encode the hash as lowercase hexadecimal (64 characters).</li>
</ol>

<p>The result is a deterministic, fixed-length string safe for use in IRI paths.</p>

<h4 id="965-deterministic-derived-iris-one-way-to-say-it">9.6.5 Deterministic Derived IRIs (One Way To Say It)</h4>

<p>To preserve “one way to say it”, every derived IRI used by schema processing, instance graph mapping, and derived validation artifact generation MUST be computed by a single deterministic algorithm.</p>

<p>This requirement applies to:</p>

<ul>
  <li>derived node IRIs (skolem IRIs)</li>
  <li>derived shape IRIs (node shapes, property shapes)</li>
  <li>derived SPARQL variable names</li>
  <li>derived graph structures (RDF lists, edge nodes)</li>
</ul>

<p>If a derivation is underspecified such that multiple incompatible algorithms could conform, processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14) rather than guess.</p>

<h4 id="966-node-shape-iris">9.6.6 Node Shape IRIs</h4>

<p>If derived validation artifacts use node shapes (for example, SHACL <code class="language-plaintext highlighter-rouge">sh:NodeShape</code> resources), the node shape IRI for a concept class IRI <code class="language-plaintext highlighter-rouge">K</code> MUST be deterministically derived as:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">nodeShapeIri(K) = K + "#shape"</code></li>
</ul>

<h4 id="967-property-shape-iris">9.6.7 Property Shape IRIs</h4>

<p>If derived validation artifacts use property shapes (for example, SHACL <code class="language-plaintext highlighter-rouge">sh:PropertyShape</code> resources), each property shape MUST have a deterministic IRI.</p>

<p>For a node shape IRI <code class="language-plaintext highlighter-rouge">S</code> and a trait name <code class="language-plaintext highlighter-rouge">t</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">propertyShapeIri(S,t) = S + "/property/trait/" + iriHash(t)</code></li>
</ul>

<p>For a node shape IRI <code class="language-plaintext highlighter-rouge">S</code> and a child class IRI <code class="language-plaintext highlighter-rouge">Q</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">propertyShapeIri(S,Q) = S + "/property/child/" + iriHash(Q)</code></li>
</ul>

<p>For a node shape IRI <code class="language-plaintext highlighter-rouge">S</code> and an RDF predicate IRI <code class="language-plaintext highlighter-rouge">p</code> used as a SHACL path (for example, <code class="language-plaintext highlighter-rouge">codex:content</code> or <code class="language-plaintext highlighter-rouge">codex:isEntity</code>):</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">predicatePropertyShapeIri(S,p) = S + "/property/predicate/" + iriHash(p)</code></li>
</ul>

<h4 id="968-document-node-shape-iri">9.6.8 Document Node Shape IRI</h4>

<p>If derived validation artifacts include a node shape targeting the document node, its node shape IRI MUST be deterministically derived as:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">documentNodeShapeIri = schemaIri + "#shape/Document"</code></li>
</ul>

<p>All canonicalization and projection rules for the Canonical Representation required by this specification are defined in this section.</p>

<p>Byte-identical canonicalization requirements apply to the Codex <code class="language-plaintext highlighter-rouge">RdfGraph</code> form, not to arbitrary RDF serializations such as Turtle or RDF/XML.</p>

<h3 id="97-codexrdf-instance-graph-mapping">9.7 Codex→RDF Instance Graph Mapping</h3>

<p>To support deterministic derived validation artifacts (including SHACL), Codex defines a canonical mapping from a parsed Codex document to an RDF instance graph.</p>

<p>The mapping MUST be deterministic and MUST NOT use RDF blank nodes.</p>

<p>The mapping requires an explicit <code class="language-plaintext highlighter-rouge">documentBaseIri</code> external input.</p>

<p>If <code class="language-plaintext highlighter-rouge">documentBaseIri</code> is missing, the mapping MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<h4 id="971-document-node">9.7.1 Document Node</h4>

<p>The instance graph MUST include a single document node.</p>

<p>The RDF node IRI for the Document context MUST be exactly <code class="language-plaintext highlighter-rouge">documentBaseIri</code>.</p>

<h4 id="972-node-identity-and-declared-identifiers">9.7.2 Node Identity and Declared Identifiers</h4>

<p>Each Concept instance in the Codex document MUST map to exactly one RDF node whose identity is a deterministic skolem IRI derived from its structural position within the document. The <code class="language-plaintext highlighter-rouge">codex:</code> prefix used in this section is shorthand; full IRI derivations are defined in §9.7.5.</p>

<h5 id="9721-skolem-iri-derivation-nodeiri">9.7.2.1 Skolem IRI Derivation (<code class="language-plaintext highlighter-rouge">nodeIri</code>)</h5>

<p>This section defines a conforming deterministic skolem IRI derivation for concept instance nodes.</p>

<p>Let <code class="language-plaintext highlighter-rouge">C</code> be a Concept instance.</p>

<p>Let <code class="language-plaintext highlighter-rouge">C.name</code> be the concept name of <code class="language-plaintext highlighter-rouge">C</code>.</p>

<p>Let <code class="language-plaintext highlighter-rouge">parent(C)</code> be the direct parent Concept instance of <code class="language-plaintext highlighter-rouge">C</code>, or the Document context if <code class="language-plaintext highlighter-rouge">C</code> is a root Concept instance.</p>

<p>Let <code class="language-plaintext highlighter-rouge">siblings(C)</code> be:</p>

<ul>
  <li>the ordered list of all top-level Concept instances in the document (in source order) if <code class="language-plaintext highlighter-rouge">parent(C)</code> is the Document context, or</li>
  <li>the ordered list of all direct child Concept instances of <code class="language-plaintext highlighter-rouge">parent(C)</code> (in source order) otherwise.</li>
</ul>

<p>Let <code class="language-plaintext highlighter-rouge">ordinalIndex(C)</code> be the unique integer <code class="language-plaintext highlighter-rouge">i</code> such that <code class="language-plaintext highlighter-rouge">siblings(C)[i]</code> is <code class="language-plaintext highlighter-rouge">C</code>.</p>

<p><code class="language-plaintext highlighter-rouge">ordinalIndex(C)</code> MUST be zero-based.</p>

<p><code class="language-plaintext highlighter-rouge">ordinalIndex(C)</code> MUST be expressed in base-10 with no leading zeros (except that <code class="language-plaintext highlighter-rouge">0</code> is permitted).</p>

<p>Define <code class="language-plaintext highlighter-rouge">addressSegments(C)</code> as the ordered list of segments obtained by walking from the document root to <code class="language-plaintext highlighter-rouge">C</code> (inclusive), where each segment for a visited node <code class="language-plaintext highlighter-rouge">X</code> is:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">iriHash(X.name) + "/" + ordinalIndex(X)</code></li>
</ul>

<p>Define <code class="language-plaintext highlighter-rouge">nodeIri(C)</code> as:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">documentBaseIri + "/__node/" + join("/", addressSegments(C))</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">nodeIri(C)</code> MUST be stable and injective within a document.</p>

<p>The RDF node IRI MUST NOT be derived from the Concept instance’s declared <code class="language-plaintext highlighter-rouge">id</code> trait value.</p>

<p>If a Concept instance declares an <code class="language-plaintext highlighter-rouge">id</code> trait, that declared identifier MUST be represented as data via a dedicated predicate <code class="language-plaintext highlighter-rouge">codex:declaredId</code>.</p>

<p>If a concept instance <code class="language-plaintext highlighter-rouge">C</code> declares an <code class="language-plaintext highlighter-rouge">id</code> trait with value <code class="language-plaintext highlighter-rouge">v</code>, the mapping MUST emit:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(nodeIri(C), codex:declaredId, valueTerm(v))</code></li>
</ul>

<h4 id="973-entity-marker">9.7.3 Entity Marker</h4>

<p>If and only if a Concept instance is an Entity, the mapped RDF node MUST be marked as an Entity using a dedicated predicate <code class="language-plaintext highlighter-rouge">codex:isEntity</code>.</p>

<p>Presence of an <code class="language-plaintext highlighter-rouge">id</code> trait spelling does not itself make a concept instance an Entity; entity status is schema-defined via <code class="language-plaintext highlighter-rouge">entityEligibility</code> (§6.1).</p>

<p>To support identity constraints without guessing, the mapping MUST emit an entity marker for every Concept instance node:</p>

<ul>
  <li>If the concept instance is an Entity, emit <code class="language-plaintext highlighter-rouge">(nodeIri(C), codex:isEntity, "true"^^xsd:boolean)</code>.</li>
  <li>Otherwise, emit <code class="language-plaintext highlighter-rouge">(nodeIri(C), codex:isEntity, "false"^^xsd:boolean)</code>.</li>
</ul>

<h4 id="974-parent-link-and-ordered-children">9.7.4 Parent Link and Ordered Children</h4>

<p>For each non-root Concept instance, the instance graph MUST include a parent link using a dedicated predicate <code class="language-plaintext highlighter-rouge">codex:parentNode</code>.</p>

<p>For each parent Concept instance <code class="language-plaintext highlighter-rouge">C</code> and each direct child Concept instance <code class="language-plaintext highlighter-rouge">D</code>, the instance graph MUST emit:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(nodeIri(D), codex:parentNode, nodeIri(C))</code></li>
</ul>

<p>For each child Concept instance <code class="language-plaintext highlighter-rouge">D</code> of parent Concept instance <code class="language-plaintext highlighter-rouge">C</code>, the instance graph MUST emit the structural child triple:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(nodeIri(C), childPredicateIri(C,D), nodeIri(D))</code></li>
</ul>

<p>The instance graph MUST additionally represent the ordered child sequence using explicit edge nodes that carry a stable numeric index (see §9.7.6).</p>

<h4 id="975-reserved-predicates">9.7.5 Reserved Predicates</h4>

<p>For the purposes of this section, let <code class="language-plaintext highlighter-rouge">schemaIri</code> be the governing schema’s <code class="language-plaintext highlighter-rouge">Schema.id</code> value.</p>

<p>The following reserved predicates are used by the instance graph mapping:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">codex:parent</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:child</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:index</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:parentNode</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:isEntity</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:declaredId</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:lookupToken</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:lookupIri</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:content</code></li>
</ul>

<p>Their IRIs MUST be deterministically derived from <code class="language-plaintext highlighter-rouge">schemaIri</code> as follows:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">codex:parent</code> MUST be <code class="language-plaintext highlighter-rouge">schemaIri + "#codex/parent"</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:child</code> MUST be <code class="language-plaintext highlighter-rouge">schemaIri + "#codex/child"</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:index</code> MUST be <code class="language-plaintext highlighter-rouge">schemaIri + "#codex/index"</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:parentNode</code> MUST be <code class="language-plaintext highlighter-rouge">schemaIri + "#codex/parentNode"</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:isEntity</code> MUST be <code class="language-plaintext highlighter-rouge">schemaIri + "#codex/isEntity"</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:declaredId</code> MUST be <code class="language-plaintext highlighter-rouge">schemaIri + "#codex/declaredId"</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:lookupToken</code> MUST be <code class="language-plaintext highlighter-rouge">schemaIri + "#codex/lookupToken"</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:lookupIri</code> MUST be <code class="language-plaintext highlighter-rouge">schemaIri + "#codex/lookupIri"</code></li>
  <li><code class="language-plaintext highlighter-rouge">codex:content</code> MUST be <code class="language-plaintext highlighter-rouge">schemaIri + "#codex/content"</code></li>
</ul>

<h4 id="976-ordered-children-encoding">9.7.6 Ordered Children Encoding</h4>

<p>This section defines the canonical ordered-children encoding.</p>

<p>For each parent Concept instance <code class="language-plaintext highlighter-rouge">C</code> and each direct child Concept instance <code class="language-plaintext highlighter-rouge">D</code> in children order, let:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">p = nodeIri(C)</code></li>
  <li><code class="language-plaintext highlighter-rouge">d = nodeIri(D)</code></li>
  <li><code class="language-plaintext highlighter-rouge">i = 0..n-1</code> be the ordinal position of <code class="language-plaintext highlighter-rouge">D</code> among the direct children of <code class="language-plaintext highlighter-rouge">C</code>, in source order</li>
</ul>

<p>The mapping MUST emit an edge node <code class="language-plaintext highlighter-rouge">e</code> and three triples:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(e, codex:parent, p)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(e, codex:child, d)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(e, codex:index, "i"^^xsd:integer)</code></li>
</ul>

<p>The edge node IRI MUST be:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">e = p + "/__childEdge/" + i</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">codex:parentNode</code> is distinct from <code class="language-plaintext highlighter-rouge">codex:parent</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">codex:parentNode</code> links a concept instance node to its parent concept instance node.</li>
  <li><code class="language-plaintext highlighter-rouge">codex:parent</code> links an ordered-child edge node to the parent concept instance node.</li>
</ul>

<h4 id="977-traits-and-value-terms">9.7.7 Traits and Value Terms</h4>

<p>For each trait <code class="language-plaintext highlighter-rouge">t=v</code> on a concept instance <code class="language-plaintext highlighter-rouge">C</code>, the instance graph MUST emit exactly one triple:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(nodeIri(C), traitPredicateIri(t), valueTerm(v))</code></li>
</ul>

<p>Exception:</p>

<ul>
  <li>If <code class="language-plaintext highlighter-rouge">t</code> is <code class="language-plaintext highlighter-rouge">id</code>, the mapping MUST NOT emit a <code class="language-plaintext highlighter-rouge">traitPredicateIri("id")</code> triple.</li>
  <li>Instead, <code class="language-plaintext highlighter-rouge">id</code> MUST be represented only by <code class="language-plaintext highlighter-rouge">codex:declaredId</code>, with the <code class="language-plaintext highlighter-rouge">id</code> value as an IRI (not a literal).</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">valueTerm(v)</code> MUST be:</p>

<ul>
  <li>an IRI when <code class="language-plaintext highlighter-rouge">v</code> is an IRI Reference Value</li>
  <li>otherwise a typed literal</li>
</ul>

<p>In this section, <code class="language-plaintext highlighter-rouge">xsd:*</code> refers to the XML Schema datatypes namespace.</p>

<p>For typed literals, the datatype IRI MUST be computed by <code class="language-plaintext highlighter-rouge">valueDatatypeIri(v)</code> and the lexical form MUST be computed by <code class="language-plaintext highlighter-rouge">valueLex(v)</code>.</p>

<p>Both <code class="language-plaintext highlighter-rouge">valueDatatypeIri(v)</code> and <code class="language-plaintext highlighter-rouge">valueLex(v)</code> MUST be derived by parsing <code class="language-plaintext highlighter-rouge">v</code> according to the Codex value catalog.</p>

<p><code class="language-plaintext highlighter-rouge">valueDatatypeIri(v)</code> MUST be:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">xsd:string</code> for String Values</li>
  <li><code class="language-plaintext highlighter-rouge">xsd:string</code> for Character Values</li>
  <li><code class="language-plaintext highlighter-rouge">xsd:boolean</code> for Boolean Values</li>
  <li><code class="language-plaintext highlighter-rouge">xsd:integer</code> for Integer Values</li>
</ul>

<p>For all other value types, <code class="language-plaintext highlighter-rouge">valueDatatypeIri(v)</code> MUST be the deterministic URN:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">urn:cdx:value-type:&lt;T&gt;</code></li>
</ul>

<p>where <code class="language-plaintext highlighter-rouge">&lt;T&gt;</code> is the Codex value type token name (for example, <code class="language-plaintext highlighter-rouge">Uuid</code>, <code class="language-plaintext highlighter-rouge">Color</code>, <code class="language-plaintext highlighter-rouge">Temporal</code>, <code class="language-plaintext highlighter-rouge">List</code>, <code class="language-plaintext highlighter-rouge">Map</code>).</p>

<p><code class="language-plaintext highlighter-rouge">valueLex(v)</code> MUST be:</p>

<ul>
  <li>the decoded Unicode string value for String Values</li>
  <li>the single Unicode scalar value as a Unicode string for Character Values</li>
  <li><code class="language-plaintext highlighter-rouge">"true"</code> or <code class="language-plaintext highlighter-rouge">"false"</code> for Boolean Values</li>
  <li>a base-10 integer string for Integer Values</li>
</ul>

<p>For all other value types, <code class="language-plaintext highlighter-rouge">valueLex(v)</code> MUST be the canonical surface spelling of <code class="language-plaintext highlighter-rouge">v</code>.</p>

<p>Lookup Token Values MUST be represented as typed literals with:</p>

<ul>
  <li>datatype: <code class="language-plaintext highlighter-rouge">urn:cdx:value-type:LookupToken</code></li>
  <li>lexical form: the canonical surface spelling (for example, <code class="language-plaintext highlighter-rouge">~myToken</code>)</li>
</ul>

<p>If a schema constraint requires an interpreted value (for example, numeric comparisons or string length), schema processing MUST either provide the interpreted value in a deterministic RDF representation or fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<h4 id="978-content">9.7.8 Content</h4>

<p>If a concept instance is in content mode, the mapping MUST emit:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(nodeIri(C), codex:content, contentString)</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">contentString</code> MUST be an <code class="language-plaintext highlighter-rouge">xsd:string</code> literal containing the concept’s content after applying the Codex content escaping rules.</p>

<h4 id="979-deterministic-predicate-iris">9.7.9 Deterministic Predicate IRIs</h4>

<p>For the purposes of this section, let <code class="language-plaintext highlighter-rouge">schemaIri</code> be the governing schema’s <code class="language-plaintext highlighter-rouge">Schema.id</code> value.</p>

<p>Trait predicate IRIs MUST be derived as follows.</p>

<p>For a trait name <code class="language-plaintext highlighter-rouge">t</code>:</p>

<ul>
  <li>If the governing schema contains exactly one <code class="language-plaintext highlighter-rouge">TraitDefinition</code> for <code class="language-plaintext highlighter-rouge">t</code> and that <code class="language-plaintext highlighter-rouge">TraitDefinition</code> has an <code class="language-plaintext highlighter-rouge">id</code>, <code class="language-plaintext highlighter-rouge">traitPredicateIri(t)</code> MUST be that <code class="language-plaintext highlighter-rouge">id</code>.</li>
  <li>If the governing schema contains exactly one <code class="language-plaintext highlighter-rouge">TraitDefinition</code> for <code class="language-plaintext highlighter-rouge">t</code> and that <code class="language-plaintext highlighter-rouge">TraitDefinition</code> has no <code class="language-plaintext highlighter-rouge">id</code>, <code class="language-plaintext highlighter-rouge">traitPredicateIri(t)</code> MUST be <code class="language-plaintext highlighter-rouge">schemaIri + "#trait/" + t</code>.</li>
  <li>If the governing schema contains zero <code class="language-plaintext highlighter-rouge">TraitDefinition</code> entries for <code class="language-plaintext highlighter-rouge">t</code>, validation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</li>
  <li>If the governing schema contains more than one <code class="language-plaintext highlighter-rouge">TraitDefinition</code> for <code class="language-plaintext highlighter-rouge">t</code>, validation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</li>
</ul>

<p>Child predicate IRIs MUST be derived as follows.</p>

<p>Let the governing schema’s <code class="language-plaintext highlighter-rouge">ConceptDefinition.id</code> for the parent concept name be <code class="language-plaintext highlighter-rouge">P</code> and for the child concept name be <code class="language-plaintext highlighter-rouge">Q</code>.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">childPredicateIri(P,Q)</code> MUST be <code class="language-plaintext highlighter-rouge">P + "#child/" + iriHash(Q)</code>.</li>
</ul>

<h4 id="9710-rdf-types">9.7.10 RDF Types</h4>

<p>Each Concept instance MUST emit an RDF type triple:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(nodeIri(C), rdf:type, conceptClassIri(C.name))</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">conceptClassIri(X)</code> MUST be the <code class="language-plaintext highlighter-rouge">ConceptDefinition.id</code> for concept name <code class="language-plaintext highlighter-rouge">X</code> in the governing schema.</p>

<p>If <code class="language-plaintext highlighter-rouge">conceptClassIri(X)</code> cannot be resolved to exactly one <code class="language-plaintext highlighter-rouge">ConceptDefinition</code>, schema-driven validation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>All aspects of the instance graph mapping required by this specification are defined in this section.</p>

<h3 id="98-lookup-token-bindings">9.8 Lookup Token Bindings</h3>
<p>Lookup Token Values (<code class="language-plaintext highlighter-rouge">~name</code>) are symbolic references that require an explicit binding to a target identifier in order to be resolved.</p>

<p>Lookup token bindings, when present, are declared using a document-level binding section.</p>

<h4 id="981-binding-section-surface-form">9.8.1 Binding Section Surface Form</h4>

<p>A binding section is declared using a top-level <code class="language-plaintext highlighter-rouge">Bindings</code> Concept.</p>

<p>The <code class="language-plaintext highlighter-rouge">Bindings</code> Concept:</p>

<ul>
  <li>MUST appear at most once per document</li>
  <li>MUST appear at the top level of the document</li>
  <li>MUST NOT be nested inside any other Concept</li>
  <li>MUST NOT contain Content</li>
  <li>MUST contain one or more <code class="language-plaintext highlighter-rouge">Bind</code> child Concepts</li>
</ul>

<h4 id="982-bind">9.8.2 <code class="language-plaintext highlighter-rouge">Bind</code></h4>

<p>A <code class="language-plaintext highlighter-rouge">Bind</code> Concept declares a single lookup binding.</p>

<h5 id="traits">Traits</h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">key</code> (required; Lookup Token Value; §5.10)</li>
  <li><code class="language-plaintext highlighter-rouge">id</code> (required; IRI Reference Value; §5.9)</li>
</ul>

<p>Each <code class="language-plaintext highlighter-rouge">Bind</code> Concept binds the specified lookup token (<code class="language-plaintext highlighter-rouge">key</code>) to the specified Entity identity (<code class="language-plaintext highlighter-rouge">id</code>).</p>

<h5 id="constraints">Constraints</h5>

<ul>
  <li>Each lookup token key MUST be bound at most once within a document.</li>
  <li>If a lookup token is used in the document and is required to be resolved by the governing schema, a corresponding binding MUST be present.</li>
  <li>Lookup token bindings MUST NOT be inferred, synthesized, or imported implicitly.</li>
</ul>

<h4 id="983-resolution-semantics">9.8.3 Resolution Semantics</h4>

<p>When lookup token resolution is required by schema validation:</p>

<ul>
  <li>The binding table MUST be constructed from the <code class="language-plaintext highlighter-rouge">Bindings</code> section.</li>
  <li>A lookup token MUST resolve to exactly one identifier.</li>
  <li>If no binding is found for a required lookup token, validation MUST fail with a <code class="language-plaintext highlighter-rouge">ReferenceError</code> (§14).</li>
  <li>If duplicate bindings for the same lookup token are present, validation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</li>
</ul>

<p>Lookup token bindings are declarative only and MUST NOT imply loading, dereferencing, or execution.</p>

<h4 id="984-schema-interaction">9.8.4 Schema Interaction</h4>

<p>A governing schema MUST specify, for each context where lookup token values are permitted, one of the following resolution requirements:</p>

<ul>
  <li>The lookup token MUST be resolvable.</li>
  <li>The lookup token MUST NOT appear in the context.</li>
  <li>Resolution is not required.</li>
</ul>

<p>These requirements are enforced during schema validation, not during parsing or formatting.</p>

<h3 id="99-deterministic-projection-to-derived-validation-artifacts">9.9 Deterministic Projection to Derived Validation Artifacts</h3>

<p>If an implementation derives validation artifacts from a governing schema, it MUST do so deterministically.</p>

<p>Any derived validation artifact MUST be a pure function of:</p>

<ul>
  <li>the governing schema</li>
  <li>the explicitly required external inputs, if any</li>
</ul>

<p>Derived validation artifact generation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14) rather than guess if any required semantic rule is not explicitly defined.</p>

<p>Derived validation artifact generation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14) if any of the following hold:</p>

<ul>
  <li>the governing schema is not valid under the schema-of-schemas</li>
  <li>any <code class="language-plaintext highlighter-rouge">ConceptDefinition</code> lacks an <code class="language-plaintext highlighter-rouge">id</code></li>
  <li>any required selector (concept name, trait name) cannot be resolved to a unique definition</li>
  <li>any schema rule produces a semantic constraint that cannot be expressed under the chosen Codex→RDF instance graph mapping</li>
</ul>

<p>Codex permits derived validation artifacts expressed as SHACL.</p>

<p>If SHACL is used as a derived validation artifact format, the generated shapes are permitted to use SHACL-SPARQL.</p>

<p>If the governing schema includes constraint definitions with explicit targets, a derived SHACL artifact MUST apply each constraint to the target node shape(s) determined as follows:</p>

<ul>
  <li>For <code class="language-plaintext highlighter-rouge">TargetConcept conceptSelector="X"</code>, the constraint MUST be applied to the node shape derived from the <code class="language-plaintext highlighter-rouge">ConceptDefinition</code> whose <code class="language-plaintext highlighter-rouge">name</code> is <code class="language-plaintext highlighter-rouge">X</code>.</li>
  <li>For <code class="language-plaintext highlighter-rouge">TargetContext contextSelector="Document"</code>, the constraint MUST be applied to a special node shape with IRI <code class="language-plaintext highlighter-rouge">schemaIri + "#shape/Document"</code> and MUST include at least:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">(schemaIri + "#shape/Document", rdf:type, sh:NodeShape)</code></li>
      <li><code class="language-plaintext highlighter-rouge">(schemaIri + "#shape/Document", sh:targetNode, documentBaseIri)</code>
  If <code class="language-plaintext highlighter-rouge">documentBaseIri</code> is not available as an external input, derived validation artifact generation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</li>
    </ul>
  </li>
  <li>If <code class="language-plaintext highlighter-rouge">contextSelector</code> is a concept name (not <code class="language-plaintext highlighter-rouge">Document</code>), the constraint MUST be applied to the node shape for that concept.</li>
</ul>

<p>If a derived validation artifact is produced as a SHACL graph, it MUST be canonical and MUST include the following structural shape triples:</p>

<ul>
  <li>For each <code class="language-plaintext highlighter-rouge">ConceptDefinition</code> in the governing schema with concept name <code class="language-plaintext highlighter-rouge">X</code>, let <code class="language-plaintext highlighter-rouge">K = conceptClassIri(X)</code> and let <code class="language-plaintext highlighter-rouge">S = nodeShapeIri(K)</code>. The derived artifact MUST include:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">(S, rdf:type, sh:NodeShape)</code></li>
      <li><code class="language-plaintext highlighter-rouge">(S, sh:targetClass, K)</code></li>
    </ul>
  </li>
  <li>If the derived artifact includes any constraint expressed on a property shape <code class="language-plaintext highlighter-rouge">PS</code>, it MUST include:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">(S, sh:property, PS)</code> where <code class="language-plaintext highlighter-rouge">S</code> is the owning node shape</li>
      <li><code class="language-plaintext highlighter-rouge">(PS, rdf:type, sh:PropertyShape)</code>
  and <code class="language-plaintext highlighter-rouge">PS</code> MUST be deterministically derived as follows:</li>
      <li>for a trait name <code class="language-plaintext highlighter-rouge">t</code>: <code class="language-plaintext highlighter-rouge">PS = propertyShapeIri(S,t)</code> and the artifact MUST include <code class="language-plaintext highlighter-rouge">(PS, sh:path, traitPredicateIri(t))</code></li>
      <li>for a child class IRI <code class="language-plaintext highlighter-rouge">Q</code>: <code class="language-plaintext highlighter-rouge">PS = propertyShapeIri(S,Q)</code> and the artifact MUST include <code class="language-plaintext highlighter-rouge">(PS, sh:path, childPredicateIri(K,Q))</code></li>
      <li>for a predicate IRI <code class="language-plaintext highlighter-rouge">p</code>: <code class="language-plaintext highlighter-rouge">PS = predicatePropertyShapeIri(S,p)</code> and the artifact MUST include <code class="language-plaintext highlighter-rouge">(PS, sh:path, p)</code></li>
    </ul>
  </li>
</ul>

<p>If a derived validation artifact expresses any constraint using SHACL-SPARQL, the <code class="language-plaintext highlighter-rouge">sh:select</code> string MUST be a SPARQL 1.1 <code class="language-plaintext highlighter-rouge">SELECT</code> query that returns one row per violating focus node using the SHACL-SPARQL convention:</p>

<ul>
  <li>the focus node variable MUST be <code class="language-plaintext highlighter-rouge">?this</code></li>
  <li>a row returned by the query MUST indicate a violation</li>
</ul>

<p>SPARQL textual equality for derived artifacts is semantic, not lexical; whitespace and formatting variations that do not change query semantics are permitted.</p>

<p>To keep derived artifacts canonical and avoid accidental variable capture, internal SPARQL variables introduced during constraint translation MUST be allocated as follows:</p>

<ul>
  <li>Walk the constraint’s rule tree in pre-order.</li>
  <li>For the <code class="language-plaintext highlighter-rouge">$k$</code>-th visited node (1-indexed), allocate a node-local suffix <code class="language-plaintext highlighter-rouge">$k$</code>.</li>
  <li>Any internal variable introduced while translating that node MUST append suffix <code class="language-plaintext highlighter-rouge">$k$</code> to a base name.</li>
  <li>Variables introduced for one rule node MUST NOT be referenced outside the <code class="language-plaintext highlighter-rouge">EXISTS { ... }</code> block created for that node.</li>
</ul>

<h4 id="991-enumerated-value-sets-shin">9.9.1 Enumerated Value Sets (<code class="language-plaintext highlighter-rouge">sh:in</code>)</h4>

<p>If a derived SHACL artifact encodes an enumerated value-set constraint using <code class="language-plaintext highlighter-rouge">sh:in</code> on a property shape <code class="language-plaintext highlighter-rouge">PS</code>, it MUST emit a triple <code class="language-plaintext highlighter-rouge">(PS, sh:in, listHead)</code>.</p>

<p>This rule applies whenever the governing schema constrains a value to a fixed enumerated set and that constraint is projected into SHACL.</p>

<p><code class="language-plaintext highlighter-rouge">listHead</code> MUST be an IRI and MUST be a deterministically derived skolem IRI (no blank nodes).</p>

<p>The list structure MUST be encoded as an RDF list as specified in §9.6.3.</p>

<h4 id="992-pattern-constraints-shpattern-shflags">9.9.2 Pattern Constraints (<code class="language-plaintext highlighter-rouge">sh:pattern</code>, <code class="language-plaintext highlighter-rouge">sh:flags</code>)</h4>

<p>If a derived SHACL artifact encodes a pattern constraint using <code class="language-plaintext highlighter-rouge">sh:pattern</code> on a property shape <code class="language-plaintext highlighter-rouge">PS</code>, it MUST emit a triple <code class="language-plaintext highlighter-rouge">(PS, sh:pattern, p)</code>.</p>

<p>If <code class="language-plaintext highlighter-rouge">flags</code> is present and non-empty, it MUST emit a triple <code class="language-plaintext highlighter-rouge">(PS, sh:flags, f)</code>.</p>

<p>This rule applies to derived SHACL constraints corresponding to schema constraints such as <code class="language-plaintext highlighter-rouge">ValueMatchesPattern</code> and <code class="language-plaintext highlighter-rouge">PatternConstraint</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">pattern</code> and <code class="language-plaintext highlighter-rouge">flags</code> semantics MUST be SPARQL 1.1 <code class="language-plaintext highlighter-rouge">REGEX</code> semantics (see §9.5.1).</p>

<h4 id="993-shacl-core-value-constraints">9.9.3 SHACL Core Value Constraints</h4>

<p>If a derived SHACL artifact encodes a value-length constraint on a property shape <code class="language-plaintext highlighter-rouge">PS</code>, it MUST emit:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:minLength, "a"^^xsd:integer)</code> when a minimum length <code class="language-plaintext highlighter-rouge">a</code> is present</li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:maxLength, "b"^^xsd:integer)</code> when a maximum length <code class="language-plaintext highlighter-rouge">b</code> is present</li>
</ul>

<p>If a derived SHACL artifact encodes a non-empty constraint on a property shape <code class="language-plaintext highlighter-rouge">PS</code>, it MUST emit:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:minLength, "1"^^xsd:integer)</code></li>
</ul>

<p>If a derived SHACL artifact encodes a numeric-range constraint on a property shape <code class="language-plaintext highlighter-rouge">PS</code>, it MUST use SHACL Core numeric bounds only when the active value datatype is <code class="language-plaintext highlighter-rouge">xsd:integer</code>.</p>

<p>If the active datatype is not <code class="language-plaintext highlighter-rouge">xsd:integer</code>, derived validation artifact generation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>When permitted, it MUST emit:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:minInclusive, "u"^^xsd:integer)</code> when a minimum value <code class="language-plaintext highlighter-rouge">u</code> is present</li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:maxInclusive, "v"^^xsd:integer)</code> when a maximum value <code class="language-plaintext highlighter-rouge">v</code> is present</li>
</ul>

<h4 id="994-child-constraints">9.9.4 Child Constraints</h4>

<p>For child constraints projected onto a property shape <code class="language-plaintext highlighter-rouge">PS</code>, let <code class="language-plaintext highlighter-rouge">P</code> be the concept class IRI (RDF class) targeted by the owning node shape.</p>

<p>If a derived SHACL artifact encodes a required-child constraint for a child concept selector <code class="language-plaintext highlighter-rouge">X</code> on a property shape <code class="language-plaintext highlighter-rouge">PS</code>, it MUST emit:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:path, childPredicateIri(P, conceptClassIri(X)))</code></li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:minCount, "1"^^xsd:integer)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:class, conceptClassIri(X))</code></li>
</ul>

<p>If a derived SHACL artifact encodes a forbidden-child constraint for a child concept selector <code class="language-plaintext highlighter-rouge">X</code> on a property shape <code class="language-plaintext highlighter-rouge">PS</code>, it MUST emit:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:path, childPredicateIri(P, conceptClassIri(X)))</code></li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:maxCount, "0"^^xsd:integer)</code></li>
</ul>

<p>If a schema rule permits a child relationship (allows without requiring), the derived SHACL artifact MUST NOT emit a constraint.</p>

<h4 id="995-content-constraints">9.9.5 Content Constraints</h4>

<p>If a derived SHACL artifact encodes a content-required constraint on a property shape <code class="language-plaintext highlighter-rouge">PS</code>, it MUST emit:</p>

<ul>
  <li>Let <code class="language-plaintext highlighter-rouge">S</code> be the owning node shape for the constraint. The property shape IRI MUST be <code class="language-plaintext highlighter-rouge">PS = predicatePropertyShapeIri(S, codex:content)</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:path, codex:content)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:minLength, "1"^^xsd:integer)</code></li>
</ul>

<p>If a derived SHACL artifact encodes a content pattern constraint on a property shape <code class="language-plaintext highlighter-rouge">PS</code>, it MUST emit:</p>

<ul>
  <li>Let <code class="language-plaintext highlighter-rouge">S</code> be the owning node shape for the constraint. The property shape IRI MUST be <code class="language-plaintext highlighter-rouge">PS = predicatePropertyShapeIri(S, codex:content)</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:path, codex:content)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:pattern, p)</code></li>
</ul>

<p>If <code class="language-plaintext highlighter-rouge">flags</code> is present and non-empty, it MUST emit:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:flags, f)</code></li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">pattern</code> and <code class="language-plaintext highlighter-rouge">flags</code> semantics MUST be SPARQL 1.1 <code class="language-plaintext highlighter-rouge">REGEX</code> semantics (see §9.5.1).</p>

<h4 id="996-identity-constraints">9.9.6 Identity Constraints</h4>

<p>If a derived SHACL artifact encodes an identity constraint requiring an entity, it MUST emit:</p>

<ul>
  <li>Let <code class="language-plaintext highlighter-rouge">S</code> be the owning node shape for the constraint. The property shape IRI MUST be <code class="language-plaintext highlighter-rouge">PS = predicatePropertyShapeIri(S, codex:isEntity)</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:path, codex:isEntity)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:hasValue, "true"^^xsd:boolean)</code></li>
</ul>

<p>If a derived SHACL artifact encodes an identity constraint requiring a non-entity, it MUST emit:</p>

<ul>
  <li>Let <code class="language-plaintext highlighter-rouge">S</code> be the owning node shape for the constraint. The property shape IRI MUST be <code class="language-plaintext highlighter-rouge">PS = predicatePropertyShapeIri(S, codex:isEntity)</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:path, codex:isEntity)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:hasValue, "false"^^xsd:boolean)</code></li>
</ul>

<p>Derived validation artifacts MUST support <code class="language-plaintext highlighter-rouge">IdentityConstraint(type=IdentifierUniqueness, scope=S)</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">scope</code> trait MUST be present. For derived artifact purposes, <code class="language-plaintext highlighter-rouge">IdentityConstraint(type=IdentifierUniqueness, scope=S)</code> MUST be treated as <code class="language-plaintext highlighter-rouge">UniqueConstraint(trait=id, scope=S)</code> and MUST follow §9.9.7.</p>

<p>Derived validation artifacts MUST support <code class="language-plaintext highlighter-rouge">IdentityConstraint(type=IdentifierForm, pattern=p, flags=f)</code>.</p>

<p>Because <code class="language-plaintext highlighter-rouge">codex:declaredId</code> is represented as an RDF IRI term (see §9.7.7), this constraint MUST be expressible using SHACL-SPARQL.
It MUST report a violation if the focus node is an Entity and either:</p>

<ul>
  <li>it has no <code class="language-plaintext highlighter-rouge">codex:declaredId</code>, or</li>
  <li><code class="language-plaintext highlighter-rouge">STR(codex:declaredId)</code> does not match <code class="language-plaintext highlighter-rouge">p</code> under SPARQL 1.1 <code class="language-plaintext highlighter-rouge">REGEX</code> semantics (using flags <code class="language-plaintext highlighter-rouge">f</code> if present).</li>
</ul>

<p>The SHACL-SPARQL constraint MUST use the following boolean condition:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXISTS {
	focusVar codex:declaredId ?idK .
	FILTER(
		REGEX(STR(?idK), p, f)
	)
}
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">p</code> is the required pattern and <code class="language-plaintext highlighter-rouge">f</code> is the flags string if present. If <code class="language-plaintext highlighter-rouge">flags</code> is absent, the generated constraint MUST use the 2-argument <code class="language-plaintext highlighter-rouge">REGEX(text, pattern)</code> form.</p>

<h4 id="997-uniqueness-constraints">9.9.7 Uniqueness Constraints</h4>

<p>Derived validation artifacts MUST support the following uniqueness constraints.</p>

<p>For both constraints, the identity of a trait is determined by the instance-graph trait mapping (see §9.7.7).</p>

<p>If a uniqueness constraint refers to <code class="language-plaintext highlighter-rouge">t = id</code>, it MUST refer to the declared identifier as represented by <code class="language-plaintext highlighter-rouge">codex:declaredId</code>.</p>

<p>For nearest-scope uniqueness, <code class="language-plaintext highlighter-rouge">UniqueConstraint(trait=t, scope=S)</code> MUST mean:</p>

<ul>
  <li>within the nearest ancestor (including self) of concept type <code class="language-plaintext highlighter-rouge">S</code>, no two nodes may share the same value for trait <code class="language-plaintext highlighter-rouge">t</code>.</li>
</ul>

<p>For purposes of this constraint, the nearest scope node is the unique node <code class="language-plaintext highlighter-rouge">scopeK</code> such that:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">focusVar &lt;codex:parentNode&gt;* scopeK</code></li>
  <li><code class="language-plaintext highlighter-rouge">scopeK rdf:type &lt;conceptClassIri(S)&gt;</code></li>
  <li>and there is no other node <code class="language-plaintext highlighter-rouge">midK</code> where:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">focusVar &lt;codex:parentNode&gt;* midK</code></li>
      <li><code class="language-plaintext highlighter-rouge">midK rdf:type &lt;conceptClassIri(S)&gt;</code></li>
      <li><code class="language-plaintext highlighter-rouge">midK &lt;codex:parentNode&gt;+ scopeK</code></li>
      <li><code class="language-plaintext highlighter-rouge">midK != scopeK</code></li>
    </ul>
  </li>
</ul>

<p>Derived validation artifact generation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14) if no nearest scope node exists.</p>

<p>For document-wide uniqueness, <code class="language-plaintext highlighter-rouge">UniqueInDocument(trait=t)</code> MUST mean:</p>

<ul>
  <li>no two nodes in the Document may share the same value for trait <code class="language-plaintext highlighter-rouge">t</code>.</li>
</ul>

<h4 id="998-context-constraints">9.9.8 Context Constraints</h4>

<p>Context constraints are expressible using the deterministic parent links in the instance graph (see §9.7.4).</p>

<p><code class="language-plaintext highlighter-rouge">ContextConstraint(type=OnlyValidUnderParent)</code> MUST be expressible in derived validation artifacts.</p>

<p><code class="language-plaintext highlighter-rouge">OnlyValidUnderParent</code> requires that the focus node’s immediate parent is of the type specified by <code class="language-plaintext highlighter-rouge">TargetContext</code> in the constraint’s <code class="language-plaintext highlighter-rouge">Targets</code> block. The <code class="language-plaintext highlighter-rouge">contextSelector</code> trait MUST NOT be present.</p>

<p>If projected into a SHACL-derived artifact, it MUST map to SHACL-SPARQL and MUST report a violation when the focus node has no direct parent of the target context type.</p>

<p>The SHACL-SPARQL constraint MUST use the following boolean condition:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXISTS {
	focusVar &lt;codex:parentNode&gt; ?pK .
	?pK rdf:type &lt;conceptClassIri(TargetContext)&gt; .
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ContextConstraint(type=OnlyValidUnderContext, contextSelector=A)</code> MUST be expressible in derived validation artifacts.</p>

<p><code class="language-plaintext highlighter-rouge">OnlyValidUnderContext</code> requires that the focus node has an ancestor of type <code class="language-plaintext highlighter-rouge">A</code> somewhere in its parent chain. The <code class="language-plaintext highlighter-rouge">contextSelector</code> trait MUST be present and specifies the required ancestor type.</p>

<p>If projected into a SHACL-derived artifact, it MUST map to SHACL-SPARQL and MUST report a violation when the focus node has no ancestor (via one or more parent links) of type <code class="language-plaintext highlighter-rouge">A</code>.</p>

<p>The SHACL-SPARQL constraint MUST use the following boolean condition:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXISTS {
	focusVar &lt;codex:parentNode&gt;+ ?aK .
	?aK rdf:type &lt;conceptClassIri(A)&gt; .
}
</code></pre></div></div>

<h4 id="999-reference-constraints-reference-trait-predicates">9.9.9 Reference Constraints (Reference Trait Predicates)</h4>

<p>Reference constraints are expressible without external resolution if identifiers are represented by <code class="language-plaintext highlighter-rouge">codex:declaredId</code> and lookup tokens are resolvable via the lookup binding table (see §9.8).</p>

<p>For the purposes of reference constraints, the set of reference-trait predicates MUST be exactly:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">traitPredicateIri("reference")</code></li>
  <li><code class="language-plaintext highlighter-rouge">traitPredicateIri("target")</code></li>
  <li><code class="language-plaintext highlighter-rouge">traitPredicateIri("for")</code></li>
</ul>

<p>If a governing schema uses different reference trait names, derived validation artifact generation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p><code class="language-plaintext highlighter-rouge">ReferenceConstraint(type=ReferenceSingleton)</code> MUST be expressible in derived validation artifacts.</p>

<p>If projected into a SHACL-derived artifact, it MUST be expressible (for example, via SHACL-SPARQL or equivalent core constraints) and MUST report a violation when more than one reference-trait predicate is present on the same focus node.</p>

<p><code class="language-plaintext highlighter-rouge">ReferenceConstraint(type=ReferenceTraitAllowed)</code> is underspecified unless the constraint specifies which reference trait is allowed.</p>

<p>Therefore, derived validation artifact generation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14) for <code class="language-plaintext highlighter-rouge">ReferenceTraitAllowed</code> unless the constraint provides an additional trait <code class="language-plaintext highlighter-rouge">traitName</code> whose value is one of <code class="language-plaintext highlighter-rouge">reference</code>, <code class="language-plaintext highlighter-rouge">target</code>, or <code class="language-plaintext highlighter-rouge">for</code>.</p>

<h4 id="9910-reference-constraints-deterministic-resolution-and-targets">9.9.10 Reference Constraints (Deterministic Resolution and Targets)</h4>

<p>Some reference constraints require deterministically resolving reference values to an IRI.</p>

<p>For the purposes of reference constraints, a reference value <code class="language-plaintext highlighter-rouge">v</code> MUST be one of:</p>

<ul>
  <li>an IRI (RDF IRI term), or</li>
  <li>a Lookup Token typed literal with datatype <code class="language-plaintext highlighter-rouge">urn:cdx:value-type:LookupToken</code>.</li>
</ul>

<p>Given a reference value <code class="language-plaintext highlighter-rouge">v</code>, its resolved IRI <code class="language-plaintext highlighter-rouge">r</code> MUST be computed as follows:</p>

<ul>
  <li>If <code class="language-plaintext highlighter-rouge">v</code> is an IRI, then <code class="language-plaintext highlighter-rouge">r = v</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">v</code> is a Lookup Token typed literal, then:
    <ul>
      <li>If there exists exactly one binding entry in the lookup binding table such that the binding entry’s <code class="language-plaintext highlighter-rouge">tokenLiteral</code> is <code class="language-plaintext highlighter-rouge">v</code>, and the binding entry’s <code class="language-plaintext highlighter-rouge">targetIri</code> is <code class="language-plaintext highlighter-rouge">r</code>, then <code class="language-plaintext highlighter-rouge">r</code> is that bound <code class="language-plaintext highlighter-rouge">targetIri</code>.</li>
      <li>Otherwise, <code class="language-plaintext highlighter-rouge">v</code> MUST be treated as unresolved.</li>
    </ul>
  </li>
  <li>Otherwise, <code class="language-plaintext highlighter-rouge">v</code> MUST be treated as unresolved.</li>
</ul>

<p>Derived validation artifacts MUST NOT guess a resolution for an unresolved reference value.</p>

<p>Derived validation artifacts MUST support <code class="language-plaintext highlighter-rouge">ReferenceConstraint(type=ReferenceTargetsEntity)</code>.</p>

<p><code class="language-plaintext highlighter-rouge">ReferenceTargetsEntity</code> MUST mean:</p>

<ul>
  <li>For each reference-trait predicate <code class="language-plaintext highlighter-rouge">p</code> in the reference-trait predicate set and for each value <code class="language-plaintext highlighter-rouge">v</code> on the focus node where <code class="language-plaintext highlighter-rouge">(focusVar, p, v)</code> holds, compute the resolved IRI <code class="language-plaintext highlighter-rouge">r</code>.</li>
  <li>A violation MUST be reported if <code class="language-plaintext highlighter-rouge">v</code> is treated as unresolved.</li>
  <li>A violation MUST be reported unless there exists a node <code class="language-plaintext highlighter-rouge">n</code> in the same Document such that:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">(n, codex:declaredId, r)</code> holds, and</li>
      <li><code class="language-plaintext highlighter-rouge">(n, codex:isEntity, "true"^^xsd:boolean)</code> holds.</li>
    </ul>
  </li>
</ul>

<h4 id="9911-reference-constraints-targets-a-concept">9.9.11 Reference Constraints (Targets a Concept)</h4>

<p>Derived validation artifacts MUST support <code class="language-plaintext highlighter-rouge">ReferenceConstraint(type=ReferenceTargetsConcept, conceptSelector=X)</code>.</p>

<p><code class="language-plaintext highlighter-rouge">ReferenceTargetsConcept</code> MUST mean:</p>

<ul>
  <li>For each reference-trait predicate <code class="language-plaintext highlighter-rouge">p</code> in the reference-trait predicate set and for each value <code class="language-plaintext highlighter-rouge">v</code> on the focus node where <code class="language-plaintext highlighter-rouge">(focusVar, p, v)</code> holds, compute the resolved IRI <code class="language-plaintext highlighter-rouge">r</code>.</li>
  <li>A violation MUST be reported if <code class="language-plaintext highlighter-rouge">v</code> is treated as unresolved.</li>
  <li>A violation MUST be reported unless there exists a node <code class="language-plaintext highlighter-rouge">n</code> in the same Document such that:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">(n, codex:declaredId, r)</code> holds, and</li>
      <li><code class="language-plaintext highlighter-rouge">(n, rdf:type, conceptClassIri(X))</code> holds.</li>
    </ul>
  </li>
</ul>

<h4 id="9912-reference-constraints-must-resolve">9.9.12 Reference Constraints (Must Resolve)</h4>

<p>Derived validation artifacts MUST support <code class="language-plaintext highlighter-rouge">ReferenceConstraint(type=ReferenceMustResolve)</code>.</p>

<p><code class="language-plaintext highlighter-rouge">ReferenceMustResolve</code> MUST mean:</p>

<ul>
  <li>For each reference-trait predicate <code class="language-plaintext highlighter-rouge">p</code> in the reference-trait predicate set and for each value <code class="language-plaintext highlighter-rouge">v</code> on the focus node where <code class="language-plaintext highlighter-rouge">(focusVar, p, v)</code> holds, compute the resolved IRI <code class="language-plaintext highlighter-rouge">r</code>.</li>
  <li>A violation MUST be reported if <code class="language-plaintext highlighter-rouge">v</code> is treated as unresolved.</li>
  <li>A violation MUST be reported unless there exists a node <code class="language-plaintext highlighter-rouge">n</code> in the same Document such that <code class="language-plaintext highlighter-rouge">(n, codex:declaredId, r)</code> holds.</li>
</ul>

<p>If a derived validation artifact is produced as an RDF graph (including a SHACL graph), the projection to a concrete RDF syntax MUST be exactly:</p>

<ol>
  <li>Check the derived <code class="language-plaintext highlighter-rouge">RdfGraph</code> against the derived-artifact structural rules.</li>
  <li>Emit the triples in a chosen RDF concrete syntax (for example, Turtle).</li>
</ol>

<p>The projection MUST NOT change the set of triples.</p>

<h3 id="910-failure-rules-no-guessing">9.10 Failure Rules (No Guessing)</h3>

<p>Schema processing, schema-driven validation, instance-graph mapping, and derived-artifact projection MUST fail with an appropriate error rather than guess when required information is missing or ambiguous.</p>

<p>Any derivation step that depends on resolving an identifier, concept, trait, or selector MUST fail immediately with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14) if resolution is not unique and total.</p>

<p>At minimum, processing MUST fail in any of the following cases:</p>

<ul>
  <li>the schema authoring mode is missing, invalid, or mixed (see §9.4) — <code class="language-plaintext highlighter-rouge">SchemaError</code></li>
  <li>a schema rule requires semantics not explicitly defined by this specification, the governing schema, or the schema-definition specification — <code class="language-plaintext highlighter-rouge">SchemaError</code></li>
  <li>a required external input is missing — <code class="language-plaintext highlighter-rouge">SchemaError</code></li>
  <li>an algorithm would require nondeterministic choice (including heuristic inference or “best effort”) — <code class="language-plaintext highlighter-rouge">SchemaError</code></li>
  <li>a lookup token is required to resolve but no binding is found — <code class="language-plaintext highlighter-rouge">ReferenceError</code></li>
  <li>a derived validation artifact cannot be constructed without inventing missing definitions — <code class="language-plaintext highlighter-rouge">SchemaError</code></li>
</ul>

<h3 id="911-simplified-authoring-mode--canonical-representation-expansion-algorithm-total">9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total)</h3>

<p>This section defines a deterministic, total expansion algorithm from the Simplified Authoring Mode (Codex-native schema-definition authoring surface) to the Canonical Representation (<code class="language-plaintext highlighter-rouge">RdfGraph</code>) suitable for derived validation artifacts (including SHACL and SHACL-SPARQL).</p>

<p>The expansion algorithm is normative.</p>

<h4 id="9111-inputs-and-output">9.11.1 Inputs and Output</h4>

<p>Input: a Simplified Authoring Mode schema document <code class="language-plaintext highlighter-rouge">S</code>.</p>

<p>Output: a Canonical Representation <code class="language-plaintext highlighter-rouge">RdfGraph</code> containing a SHACL graph.</p>

<h4 id="9112-preconditions">9.11.2 Preconditions</h4>

<p>The expansion MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14) if any precondition defined in §9.9 is violated.</p>

<h4 id="9113-expansion-steps">9.11.3 Expansion Steps</h4>

<ol>
  <li>Compute <code class="language-plaintext highlighter-rouge">schemaIri</code> as the governing schema’s <code class="language-plaintext highlighter-rouge">Schema.id</code> value.</li>
  <li>For each <code class="language-plaintext highlighter-rouge">ConceptDefinition</code> in <code class="language-plaintext highlighter-rouge">S</code>, compute:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">K = conceptClassIri(X)</code> where <code class="language-plaintext highlighter-rouge">X</code> is the concept name</li>
      <li><code class="language-plaintext highlighter-rouge">NS = nodeShapeIri(K)</code></li>
    </ul>
  </li>
  <li>Emit SHACL node shape triples for each concept definition:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">(NS, rdf:type, sh:NodeShape)</code></li>
      <li><code class="language-plaintext highlighter-rouge">(NS, sh:targetClass, K)</code></li>
    </ul>
  </li>
  <li>Expand TraitRules into property shapes (§9.11.4).</li>
  <li>Expand ChildRules into property shapes (§9.11.5).</li>
  <li>Expand ConstraintDefinitions into SHACL constraints (§9.11.6).</li>
  <li>Canonicalize the resulting <code class="language-plaintext highlighter-rouge">RdfGraph</code> (§9.6).</li>
</ol>

<h4 id="9114-traitrules--shacl-property-shapes">9.11.4 TraitRules → SHACL Property Shapes</h4>

<p>For each trait rule attached to a concept definition with node shape IRI <code class="language-plaintext highlighter-rouge">NS</code>, let <code class="language-plaintext highlighter-rouge">t</code> be the trait name string.</p>

<p>The expansion MUST emit one SHACL property shape node <code class="language-plaintext highlighter-rouge">PS</code> with:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(NS, sh:property, PS)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(PS, rdf:type, sh:PropertyShape)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:path, traitPredicateIri(t))</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">PS</code> MUST be <code class="language-plaintext highlighter-rouge">propertyShapeIri(NS, t)</code>.</p>

<p>Cardinality mapping:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">RequiresTrait</code> MUST emit <code class="language-plaintext highlighter-rouge">(PS, sh:minCount, "1"^^xsd:integer)</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">ForbidsTrait</code> MUST emit <code class="language-plaintext highlighter-rouge">(PS, sh:maxCount, "0"^^xsd:integer)</code>.</li>
</ul>

<p>Value type mapping:</p>

<ul>
  <li>If simplified-mode schema authoring declares a value type token that maps to an RDF datatype IRI, the expansion MUST emit <code class="language-plaintext highlighter-rouge">(PS, sh:datatype, datatypeIri)</code>.</li>
  <li>If simplified-mode schema authoring constrains by enumerated set, the expansion MUST emit <code class="language-plaintext highlighter-rouge">(PS, sh:in, listNodeIri)</code> and MUST emit the RDF list structure using deterministic skolem IRIs (see §9.6.3).</li>
</ul>

<p>Any value-type token without a defined mapping MUST cause expansion failure with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<h4 id="9115-childrules--shacl-property-shapes">9.11.5 ChildRules → SHACL Property Shapes</h4>

<p>For each allowed/required/forbidden child relationship declared on a concept definition with node shape IRI <code class="language-plaintext highlighter-rouge">NS</code> and concept class IRI <code class="language-plaintext highlighter-rouge">K</code>, let <code class="language-plaintext highlighter-rouge">Q = conceptClassIri(X)</code> for the selected child concept name <code class="language-plaintext highlighter-rouge">X</code>.</p>

<p>The expansion MUST emit one SHACL property shape node <code class="language-plaintext highlighter-rouge">PS</code> with:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(NS, sh:property, PS)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(PS, rdf:type, sh:PropertyShape)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(PS, sh:path, childPredicateIri(K, Q))</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">PS</code> MUST be <code class="language-plaintext highlighter-rouge">propertyShapeIri(NS, Q)</code>.</p>

<p>Child presence mapping:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">RequiresChildConcept</code> MUST emit <code class="language-plaintext highlighter-rouge">(PS, sh:minCount, "1"^^xsd:integer)</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">ForbidsChildConcept</code> MUST emit <code class="language-plaintext highlighter-rouge">(PS, sh:maxCount, "0"^^xsd:integer)</code>.</li>
</ul>

<p>If simplified-mode schema authoring restricts child type, the expansion MUST emit <code class="language-plaintext highlighter-rouge">(PS, sh:class, Q)</code>.</p>

<h4 id="9116-constraintdefinitions--shacl-constraints">9.11.6 ConstraintDefinitions → SHACL Constraints</h4>

<p>ConstraintDefinitions MUST expand to SHACL constraints.</p>

<h5 id="91161-general-rule">9.11.6.1 General Rule</h5>

<p>Each Codex constraint type permitted by the schema-definition specification MUST map to either:</p>

<ul>
  <li>a SHACL Core constraint expression, or</li>
  <li>a SHACL-SPARQL constraint (<code class="language-plaintext highlighter-rouge">sh:sparql</code>).</li>
</ul>

<p>If a constraint type cannot be expressed without inventing semantics not defined by this specification and the schema-definition specification, expansion MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>Atomic constraint mappings that are defined by this specification MUST follow §9.9.</p>

<h5 id="91162-rule-algebra--shacl-sparql-total">9.11.6.2 Rule Algebra → SHACL-SPARQL (Total)</h5>

<p>This section defines a total mapping for the rule algebra elements:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AllOf</code></li>
  <li><code class="language-plaintext highlighter-rouge">AnyOf</code></li>
  <li><code class="language-plaintext highlighter-rouge">Not</code></li>
  <li><code class="language-plaintext highlighter-rouge">ConditionalConstraint</code> (<code class="language-plaintext highlighter-rouge">When</code> / <code class="language-plaintext highlighter-rouge">Then</code>)</li>
</ul>

<p>This mapping is total in the sense that it provides a deterministic SHACL-SPARQL construction for any rule algebra tree.</p>

<p>If the rule algebra tree contains an atomic constraint whose required mapping is undefined, expansion MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<h6 id="911621-canonical-sparql-form">9.11.6.2.1 Canonical SPARQL Form</h6>

<p>For any <code class="language-plaintext highlighter-rouge">ConstraintDefinition</code>, expansion MUST emit exactly one SHACL-SPARQL constraint query per target shape.</p>

<p>The query MUST be a <code class="language-plaintext highlighter-rouge">SELECT</code> query that returns one row per violating focus node using the SHACL-SPARQL convention:</p>

<ul>
  <li>The focus node variable MUST be <code class="language-plaintext highlighter-rouge">?this</code>.</li>
  <li>A row returned by the query MUST indicate a violation.</li>
</ul>

<p>The query MUST have the following canonical structure:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT DISTINCT ?this
WHERE {
	&lt;TARGET_BINDING&gt;
	FILTER( !( &lt;HOLD_EXPR&gt; ) )
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&lt;TARGET_BINDING&gt;</code> MUST bind <code class="language-plaintext highlighter-rouge">?this</code> to the set of focus nodes implied by the constraint’s targets.</p>

<p>The target binding MUST be:</p>

<ul>
  <li>For a concept target with concept name <code class="language-plaintext highlighter-rouge">X</code>: <code class="language-plaintext highlighter-rouge">?this rdf:type &lt;conceptClassIri(X)&gt; .</code></li>
  <li>For <code class="language-plaintext highlighter-rouge">TargetContext contextSelector="Document"</code>: <code class="language-plaintext highlighter-rouge">FILTER( ?this = &lt;documentBaseIri&gt; ) .</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">&lt;documentBaseIri&gt;</code> denotes the IRI term whose value is the required external input <code class="language-plaintext highlighter-rouge">documentBaseIri</code>.</p>

<p>If target binding cannot be expressed without ambiguity (for example, the target selector is not resolvable), expansion MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p><code class="language-plaintext highlighter-rouge">&lt;HOLD_EXPR&gt;</code> MUST be computed by the function <code class="language-plaintext highlighter-rouge">H(rule, ctx, focusVar)</code> defined below, with <code class="language-plaintext highlighter-rouge">focusVar</code> set to <code class="language-plaintext highlighter-rouge">?this</code>.</p>

<h6 id="911622-deterministic-variable-allocation">9.11.6.2.2 Deterministic Variable Allocation</h6>

<p>Atomic constraints and path/quantifier expressions often require internal SPARQL variables.</p>

<p>To avoid accidental capture and to make the output canonical, expansion MUST allocate internal variable names deterministically.</p>

<p>Expansion MUST walk the rule tree in pre-order.</p>

<p>For the k-th node visited (1-indexed), the expansion context <code class="language-plaintext highlighter-rouge">ctx</code> MUST define a node-local suffix <code class="language-plaintext highlighter-rouge">k</code>.</p>

<p>Any internal variable introduced while translating that node MUST be named by appending <code class="language-plaintext highlighter-rouge">k</code> to a base name.</p>

<p>Examples:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">?v1</code>, <code class="language-plaintext highlighter-rouge">?v2</code>, … for values</li>
  <li><code class="language-plaintext highlighter-rouge">?c1</code>, <code class="language-plaintext highlighter-rouge">?c2</code>, … for child nodes</li>
</ul>

<p>Variables introduced for one rule node MUST NOT be referenced outside the <code class="language-plaintext highlighter-rouge">EXISTS { ... }</code> block created for that node.</p>

<h6 id="911623-the-hrule-ctx-focusvar-function">9.11.6.2.3 The <code class="language-plaintext highlighter-rouge">H(rule, ctx, focusVar)</code> Function</h6>

<p><code class="language-plaintext highlighter-rouge">H(rule, ctx, focusVar)</code> returns a SPARQL boolean expression that evaluates to true exactly when the rule holds for the current focus node.</p>

<p>If <code class="language-plaintext highlighter-rouge">focusVar</code> is omitted, it MUST be <code class="language-plaintext highlighter-rouge">?this</code>.</p>

<p><code class="language-plaintext highlighter-rouge">H(rule, ctx, focusVar)</code> MUST be computed as follows.</p>

<p><strong>AllOf</strong></p>

<p>If <code class="language-plaintext highlighter-rouge">rule</code> is <code class="language-plaintext highlighter-rouge">AllOf</code> with child rules <code class="language-plaintext highlighter-rouge">r1..rn</code>, then:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">H(rule, ctx, focusVar) = H(r1, ctx1, focusVar) &amp;&amp; H(r2, ctx2, focusVar) &amp;&amp; ... &amp;&amp; H(rn, ctxn, focusVar)</code></li>
</ul>

<p>where <code class="language-plaintext highlighter-rouge">ctxi</code> are derived by continuing the deterministic pre-order traversal.</p>

<p><strong>AnyOf</strong></p>

<p>If <code class="language-plaintext highlighter-rouge">rule</code> is <code class="language-plaintext highlighter-rouge">AnyOf</code> with child rules <code class="language-plaintext highlighter-rouge">r1..rn</code>, then:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">H(rule, ctx, focusVar) = H(r1, ctx1, focusVar) || H(r2, ctx2, focusVar) || ... || H(rn, ctxn, focusVar)</code></li>
</ul>

<p><strong>Not</strong></p>

<p>If <code class="language-plaintext highlighter-rouge">rule</code> is <code class="language-plaintext highlighter-rouge">Not</code> with exactly one child rule <code class="language-plaintext highlighter-rouge">r</code>, then:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">H(rule, ctx, focusVar) = !H(r, ctx1, focusVar)</code></li>
</ul>

<p><strong>ConditionalConstraint</strong></p>

<p>If <code class="language-plaintext highlighter-rouge">rule</code> is <code class="language-plaintext highlighter-rouge">ConditionalConstraint</code> with condition rule <code class="language-plaintext highlighter-rouge">w</code> (under <code class="language-plaintext highlighter-rouge">When</code>) and consequent rule <code class="language-plaintext highlighter-rouge">t</code> (under <code class="language-plaintext highlighter-rouge">Then</code>), then:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">H(rule, ctx, focusVar) = (!H(w, ctxW, focusVar)) || H(t, ctxT, focusVar)</code></li>
</ul>

<p>This is logically equivalent to: if the condition holds, the consequent must hold.</p>

<h6 id="911624-atomic-rules-as-exists-blocks">9.11.6.2.4 Atomic Rules as <code class="language-plaintext highlighter-rouge">EXISTS</code> Blocks</h6>

<p>If <code class="language-plaintext highlighter-rouge">rule</code> is atomic, <code class="language-plaintext highlighter-rouge">H(rule, ctx, focusVar)</code> MUST be a SPARQL <code class="language-plaintext highlighter-rouge">EXISTS { ... }</code> form or an <code class="language-plaintext highlighter-rouge">EXISTS</code>-free boolean constant.</p>

<p>For atomic rules whose SHACL Core mapping is defined in §9.9, expansion MUST ALSO define <code class="language-plaintext highlighter-rouge">H(rule, ctx, focusVar)</code> using only SPARQL 1.1 constructs.</p>

<p>If an atomic rule cannot be expressed as a SPARQL boolean expression without inventing additional semantics, expansion MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>For atomic rules mapped in §9.9, the <code class="language-plaintext highlighter-rouge">H</code> translation MUST be:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">TraitExists(trait=t)</code>: <code class="language-plaintext highlighter-rouge">EXISTS { focusVar &lt;traitPredicateIri(t)&gt; ?vK }</code></li>
  <li><code class="language-plaintext highlighter-rouge">TraitMissing(trait=t)</code>: <code class="language-plaintext highlighter-rouge">!EXISTS { focusVar &lt;traitPredicateIri(t)&gt; ?vK }</code></li>
  <li><code class="language-plaintext highlighter-rouge">TraitEquals(trait=t, value=v)</code>: <code class="language-plaintext highlighter-rouge">EXISTS { focusVar &lt;traitPredicateIri(t)&gt; &lt;valueTerm(v)&gt; }</code></li>
</ul>

<p>Here <code class="language-plaintext highlighter-rouge">?vK</code> MUST follow the deterministic variable allocation rule in §9.11.6.2.2.</p>

<h6 id="911625-one-way-representation-rule">9.11.6.2.5 One-Way Representation Rule</h6>

<p>When a <code class="language-plaintext highlighter-rouge">ConstraintDefinition</code> uses rule algebra (i.e., contains <code class="language-plaintext highlighter-rouge">AllOf</code>, <code class="language-plaintext highlighter-rouge">AnyOf</code>, <code class="language-plaintext highlighter-rouge">Not</code>, or <code class="language-plaintext highlighter-rouge">ConditionalConstraint</code> anywhere in its rule tree), expansion MUST express that constraint definition using SHACL-SPARQL only.</p>

<p>Expansion MUST NOT additionally emit independent SHACL Core constraints for the same <code class="language-plaintext highlighter-rouge">ConstraintDefinition</code>.</p>

<p>Rationale: emitting both creates multiple ways to say the same thing and risks divergence between engines.</p>

<h5 id="91163-paths-and-quantifiers--shacl-sparql-total">9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total)</h5>

<p>This section defines a total mapping for:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">TraitPath</code>, <code class="language-plaintext highlighter-rouge">ChildPath</code>, <code class="language-plaintext highlighter-rouge">DescendantPath</code>, <code class="language-plaintext highlighter-rouge">ContentPath</code></li>
  <li><code class="language-plaintext highlighter-rouge">OnPathExists</code>, <code class="language-plaintext highlighter-rouge">OnPathForAll</code>, <code class="language-plaintext highlighter-rouge">OnPathCount</code></li>
</ul>

<p>These operators MUST be expressed using SHACL-SPARQL.</p>

<h6 id="911631-path-binding-function">9.11.6.3.1 Path Binding Function</h6>

<p>Define a function <code class="language-plaintext highlighter-rouge">B(path, focusVar, outVar)</code> that emits a SPARQL graph pattern which binds <code class="language-plaintext highlighter-rouge">outVar</code> to each element selected by <code class="language-plaintext highlighter-rouge">path</code> from <code class="language-plaintext highlighter-rouge">focusVar</code>.</p>

<p><code class="language-plaintext highlighter-rouge">B</code> MUST be computed as follows.</p>

<p><strong>TraitPath</strong></p>

<p>For <code class="language-plaintext highlighter-rouge">TraitPath traitName=t</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>focusVar &lt;traitPredicateIri(t)&gt; outVar .
</code></pre></div></div>

<p><strong>ChildPath</strong></p>

<p>For <code class="language-plaintext highlighter-rouge">ChildPath conceptSelector=X</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>outVar &lt;codex:parentNode&gt; focusVar .
outVar rdf:type &lt;conceptClassIri(X)&gt; .
</code></pre></div></div>

<p><strong>DescendantPath</strong></p>

<p>For <code class="language-plaintext highlighter-rouge">DescendantPath conceptSelector=X</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>outVar &lt;codex:parentNode&gt;+ focusVar .
outVar rdf:type &lt;conceptClassIri(X)&gt; .
</code></pre></div></div>

<p><strong>ContentPath</strong></p>

<p>For <code class="language-plaintext highlighter-rouge">ContentPath</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>focusVar &lt;codex:content&gt; outVar .
</code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">conceptSelector</code> cannot be resolved to a unique <code class="language-plaintext highlighter-rouge">ConceptDefinition</code>, expansion MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<h6 id="911632-quantifier-semantics-revised--onpathcount">9.11.6.3.2 Quantifier Semantics (Revised — <code class="language-plaintext highlighter-rouge">OnPathCount</code>)</h6>

<p>Each <code class="language-plaintext highlighter-rouge">OnPath*</code> node scopes a nested rule over the set of elements produced by <code class="language-plaintext highlighter-rouge">B</code>.</p>

<p>Let <code class="language-plaintext highlighter-rouge">path</code> be its <code class="language-plaintext highlighter-rouge">Path</code> child.</p>

<p>Let <code class="language-plaintext highlighter-rouge">r</code> be its nested <code class="language-plaintext highlighter-rouge">Rule</code> child.</p>

<p>Let <code class="language-plaintext highlighter-rouge">xVar</code> be the deterministically allocated variable for the bound element.</p>

<p>The nested rule MUST be evaluated with <code class="language-plaintext highlighter-rouge">focusVar</code> set to <code class="language-plaintext highlighter-rouge">xVar</code>.</p>

<p><strong>OnPathExists</strong></p>

<p><code class="language-plaintext highlighter-rouge">OnPathExists(path, r)</code> MUST translate to:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXISTS {
	B(path, focusVar, xVar)
	FILTER( H(r, ctxChild, xVar) )
}
</code></pre></div></div>

<p><strong>OnPathForAll</strong></p>

<p><code class="language-plaintext highlighter-rouge">OnPathForAll(path, r)</code> MUST translate to:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!EXISTS {
	B(path, focusVar, xVar)
	FILTER( !H(r, ctxChild, xVar) )
}
</code></pre></div></div>

<p><strong>OnPathCount</strong></p>

<p><code class="language-plaintext highlighter-rouge">OnPathCount(path, r, minCount=m?, maxCount=n?)</code> MUST translate to a COUNT-based boolean condition.</p>

<p>If both <code class="language-plaintext highlighter-rouge">minCount</code> and <code class="language-plaintext highlighter-rouge">maxCount</code> are absent, expansion MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>The expansion MUST introduce a subquery that binds a single variable <code class="language-plaintext highlighter-rouge">?countK</code> and MUST then apply all required comparisons to <code class="language-plaintext highlighter-rouge">?countK</code> using a <code class="language-plaintext highlighter-rouge">FILTER</code> expression.</p>

<p>A conforming translation MUST have the following canonical form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
	SELECT (COUNT(?xVar) AS ?countK)
	WHERE {
		B(path, focusVar, xVar)
		FILTER( H(r, ctxChild, xVar) )
	}
}
FILTER(
	(minCountPresent ? (?countK &gt;= m) : true)
	&amp;&amp;
	(maxCountPresent ? (?countK &lt;= n) : true)
)
</code></pre></div></div>

<p>Where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">?countK</code> MUST be deterministically allocated according to §9.11.6.2.2.</li>
  <li>The subquery MUST appear in the same <code class="language-plaintext highlighter-rouge">WHERE</code> block as the enclosing constraint.</li>
  <li>The <code class="language-plaintext highlighter-rouge">FILTER</code> expression applying the count comparisons MUST appear immediately after the subquery.</li>
  <li>Other bindings or filters MUST NOT intervene between the subquery and its associated <code class="language-plaintext highlighter-rouge">FILTER</code>.</li>
</ul>

<p>The resulting boolean condition MUST evaluate to true if and only if the count constraints hold.</p>

<h5 id="91164-sparql-constraint-shape">9.11.6.4 SPARQL Constraint Shape</h5>

<p>When a constraint is expressed using SHACL-SPARQL, the expansion MUST emit:</p>

<p>Let <code class="language-plaintext highlighter-rouge">targetShapeIri</code> be the node shape IRI the constraint is applied to (for example, <code class="language-plaintext highlighter-rouge">nodeShapeIri(conceptClassIri(X))</code> for a concept target or <code class="language-plaintext highlighter-rouge">documentNodeShapeIri</code> for the Document context).</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(targetShapeIri, sh:sparql, sparqlConstraintIri)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(sparqlConstraintIri, sh:select, selectTextLiteral)</code></li>
</ul>

<p>If the source constraint has a <code class="language-plaintext highlighter-rouge">title</code> or <code class="language-plaintext highlighter-rouge">description</code>, the expansion MUST emit <code class="language-plaintext highlighter-rouge">sh:message</code>.</p>

<p>The SPARQL query MUST be deterministic given the source constraint.</p>

<h5 id="91165-pattern-constraints-sparql-11-regex">9.11.6.5 Pattern Constraints (SPARQL 1.1 REGEX)</h5>

<p>For the pattern-bearing constraints (<code class="language-plaintext highlighter-rouge">ValueMatchesPattern</code>, <code class="language-plaintext highlighter-rouge">PatternConstraint</code>, <code class="language-plaintext highlighter-rouge">ContentMatchesPattern</code>), the expansion MUST use SPARQL 1.1 <code class="language-plaintext highlighter-rouge">REGEX</code> semantics.</p>

<p>If <code class="language-plaintext highlighter-rouge">flags</code> is present, it MUST be projected to <code class="language-plaintext highlighter-rouge">sh:flags</code> when using <code class="language-plaintext highlighter-rouge">sh:pattern</code>, and it MUST be passed as the third argument to <code class="language-plaintext highlighter-rouge">REGEX</code> when using <code class="language-plaintext highlighter-rouge">sh:sparql</code>.</p>

<h5 id="91166-valueisvalid-via-explicit-validatordefinition">9.11.6.6 <code class="language-plaintext highlighter-rouge">ValueIsValid</code> via Explicit <code class="language-plaintext highlighter-rouge">ValidatorDefinition</code></h5>

<p>For <code class="language-plaintext highlighter-rouge">ValueIsValid validatorName=$X</code>, expansion MUST:</p>

<ol>
  <li>Resolve <code class="language-plaintext highlighter-rouge">$X</code> to exactly one <code class="language-plaintext highlighter-rouge">ValidatorDefinition</code> in the schema.</li>
  <li>Embed the <code class="language-plaintext highlighter-rouge">ValidatorDefinition</code> content into a SHACL-SPARQL constraint.</li>
</ol>

<p>If the validator cannot be resolved uniquely, expansion MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>The embedding contract MUST be purely textual and deterministic.</p>

<p>The embedding contract MUST be:</p>

<ul>
  <li>The validator content MUST be a SPARQL <code class="language-plaintext highlighter-rouge">SELECT</code> query string whose results follow the SHACL-SPARQL convention (returning a row per violation with <code class="language-plaintext highlighter-rouge">?this</code>).</li>
</ul>

<p>The derived <code class="language-plaintext highlighter-rouge">sh:select</code> string MUST be exactly the validator content.</p>

<hr />

<h2 id="10-formatting-and-canonicalization">10. Formatting and Canonicalization</h2>

<h3 id="101-purpose">10.1 Purpose</h3>

<p>This section defines how Codex documents are:</p>

<ul>
  <li>formatted</li>
  <li>canonicalized</li>
  <li>rejected when canonicalization is not possible</li>
</ul>

<p>Its goals are to:</p>

<ul>
  <li>ensure exactly one canonical surface form</li>
  <li>ensure formatting/canonicalization conforms to the language invariants (§2), including the prohibition of heuristics</li>
  <li>enable mechanical, explainable normalization</li>
  <li>support lossless round-tripping</li>
</ul>

<p>This section governs formatting and canonicalization only.</p>

<h3 id="102-processing-phases">10.2 Processing Phases</h3>
<p>Codex supports two related pipelines:</p>

<ol>
  <li>Schema-less formatting / well-formedness check (§2.5) (no schema required)</li>
  <li>Semantic validation (§2.5) (schema required)</li>
</ol>

<p>Formatting and canonicalization are not optional in the full pipeline.
However, schema availability is required only for semantic validation.</p>

<h4 id="1021-schema-less-formatting-mode-required">10.2.1 Schema-Less Formatting Mode (Required)</h4>
<p>An implementation MUST provide a schema-less formatting / canonicalization mode that can be run without a governing schema.</p>

<p>This mode exists to support well-formedness and formatting checks (gofmt-like), independent of semantic validation.</p>

<p>A schema-less formatter:</p>

<ul>
  <li>MUST NOT claim that its output is valid under any schema</li>
  <li>MUST NOT report schema/semantic error classes (e.g., <code class="language-plaintext highlighter-rouge">SchemaError</code>, <code class="language-plaintext highlighter-rouge">IdentityError</code>, <code class="language-plaintext highlighter-rouge">ReferenceError</code>, <code class="language-plaintext highlighter-rouge">ConstraintError</code>)</li>
  <li>MUST normalize encoding and line endings as defined by the surface form requirements (§8)</li>
  <li>MUST apply the canonical form requirement defined in §10.4</li>
  <li>MUST normalize whitespace, blank-line layout, trait layout, and annotation whitespace</li>
</ul>

<p>Schema-less formatting is not validation. It exists to produce a consistent surface form without consulting schema meaning.</p>

<h3 id="10211-schema-less-content-mode-determination">10.2.1.1 Schema-less Content Mode Determination</h3>
<p>In schema-less formatting and canonicalization mode, the parser MUST determine a Concept instance’s body mode mechanically as follows:</p>

<ul>
  <li>Let the body lines be the lines between the Concept instance’s opening marker and its matching closing marker (or empty for a self-closing marker).</li>
  <li>Ignore blank lines.</li>
  <li>Consider only lines at exactly one nesting level deeper than the enclosing Concept instance after indentation normalization.</li>
</ul>

<p>The body MUST be classified according to the following rules:</p>

<ul>
  <li>If there are no non-blank body lines, the body MUST be treated as children mode.</li>
  <li>If any non-blank considered line begins with <code class="language-plaintext highlighter-rouge">&lt;</code> (Concept marker) or <code class="language-plaintext highlighter-rouge">[</code> (annotation), the body MUST be treated as children mode.</li>
  <li>Otherwise, the body MUST be treated as content mode.</li>
</ul>

<p>Lines beginning with the escape sequences <code class="language-plaintext highlighter-rouge">\&lt;</code> or <code class="language-plaintext highlighter-rouge">\[</code> are content, not structural markers.</p>

<p>If the body is classified as children mode but contains any non-blank considered line that is neither a valid Concept marker line (§8.5) nor a valid annotation line (§8.9), the document MUST be rejected with a <code class="language-plaintext highlighter-rouge">ParseError</code> (§14).</p>

<p>This determination is purely mechanical and MUST NOT depend on schema knowledge, heuristics, or inferred intent.</p>

<p>If subsequent schema-based validation determines that the mechanically determined body mode is not permitted for the Concept, validation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<h4 id="1022-full-validation-pipeline">10.2.2 Full Validation Pipeline</h4>
<p>To validate a document under a schema, a conforming tool MUST follow this sequence:</p>

<ol>
  <li>Decode + newline normalization</li>
  <li>Formatting + canonicalization (mandatory) — using the schema-less mode defined in §10.2.1</li>
  <li>Schema resolution — obtain the governing schema for the document (§12)</li>
  <li>Semantic validation — schema rule evaluation (constraints, value types, identity, references)</li>
</ol>

<p>Schema resolution is required before semantic validation.</p>

<h3 id="103-parse-errors-vs-formatting-errors">10.3 Parse Errors vs Formatting Errors</h3>
<h4 id="1031-parse-errors">10.3.1 Parse Errors</h4>

<p>During formatting + canonicalization, a failure MUST be classified as <code class="language-plaintext highlighter-rouge">ParseError</code> (§14) when input cannot be read into the syntactic structure required to produce a parsed document model (AST) as defined by the Codex surface form.</p>

<h4 id="1032-formatting-errors">10.3.2 Formatting Errors</h4>

<p>During formatting + canonicalization, a failure MUST be classified as <code class="language-plaintext highlighter-rouge">FormattingError</code> (§14) when input can be structurally read, but cannot be transformed into canonical surface form deterministically.</p>

<p><code class="language-plaintext highlighter-rouge">FormattingError</code> is distinct from schema or semantic error classes.</p>

<h3 id="104-canonical-form-requirement">10.4 Canonical Form Requirement</h3>
<p>Every valid Codex document MUST normalize to exactly one canonical textual form.</p>

<p>Canonicalization:</p>

<ul>
  <li>is deterministic</li>
  <li>is mechanical</li>
  <li>preserves meaning and Content</li>
  <li>never guesses author intent</li>
</ul>

<p>If canonicalization cannot be performed unambiguously, the document MUST be rejected with a <code class="language-plaintext highlighter-rouge">FormattingError</code> (§14).</p>

<h3 id="105-canonicalization-rules">10.5 Canonicalization Rules</h3>
<p>Canonicalization is divided into two phases:</p>

<p><strong>Phase 1 (schema-free)</strong> applies to all documents:</p>

<ul>
  <li>canonical encoding and newline normalization (§8)</li>
  <li>deterministic indentation</li>
  <li>no trailing whitespace on lines</li>
  <li>no trailing blank lines at end of file</li>
  <li>exactly one blank line between sibling Concepts</li>
  <li>canonical spacing of Traits</li>
  <li>canonical Trait layout (1–2 Traits on one line; 3+ Traits on separate lines)</li>
  <li>canonical placement of self-closing markers</li>
  <li>canonical inline-annotation whitespace collapse</li>
  <li>canonical string escaping</li>
  <li>preservation of Concept, Trait, and Content order</li>
  <li>content indentation normalization (§8.8.3)</li>
</ul>

<p><strong>Phase 2 (schema-directed)</strong> applies during schema-directed processing:</p>

<ul>
  <li>content whitespace mode normalization per <code class="language-plaintext highlighter-rouge">whitespaceMode</code> declaration (§8.8.4)</li>
  <li>deterministic sorting of children in <code class="language-plaintext highlighter-rouge">$Unordered</code> collections (§10.5.1)</li>
</ul>

<p>Schema-less processing MUST complete Phase 1 only. Schema-directed processing MUST complete both phases.</p>

<p>Canonicalization MUST NOT:</p>

<ul>
  <li>reorder Concepts (except children of <code class="language-plaintext highlighter-rouge">$Unordered</code> collections during Phase 2)</li>
  <li>reorder Traits</li>
  <li>invent or remove Concepts, Traits, or Content</li>
  <li>infer missing structure</li>
</ul>

<h4 id="1051-deterministic-ordering-for-unordered-collections">10.5.1 Deterministic Ordering for Unordered Collections</h4>

<p>In canonical surface form, children of an <code class="language-plaintext highlighter-rouge">$Unordered</code> collection MUST be sorted according to the following deterministic algorithm:</p>

<ol>
  <li>Sort by Concept name (lexicographic, case-sensitive, ascending).</li>
  <li>If Concept names are equal, sort by <code class="language-plaintext highlighter-rouge">id</code> trait value (lexicographic, ascending) if present.</li>
  <li>If Concept names are equal and neither child has an <code class="language-plaintext highlighter-rouge">id</code> trait, sort by <code class="language-plaintext highlighter-rouge">key</code> trait value (lexicographic, ascending) if present.</li>
  <li>If still tied, preserve source order.</li>
</ol>

<p>This sorting is schema-directed and MUST only be applied during Phase 2 processing.</p>

<h3 id="106-annotation-canonicalization">10.6 Annotation Canonicalization</h3>
<p>Annotation canonicalization MUST follow the surface form requirements (§8).</p>

<p>In particular:</p>

<ul>
  <li>Inline annotations collapse internal whitespace to single spaces and trim leading/trailing whitespace (as described in §8)</li>
  <li>Block annotations preserve internal line structure</li>
  <li>Block annotations with <code class="language-plaintext highlighter-rouge">CODE:</code> or <code class="language-plaintext highlighter-rouge">MARKDOWN:</code> directives are byte-preserving: tools MUST NOT reindent, trim, strip trailing whitespace, wrap, or interpret escapes within those blocks</li>
</ul>

<p>If attachment cannot be determined deterministically, canonicalization MUST fail with a <code class="language-plaintext highlighter-rouge">FormattingError</code> (§14).</p>

<h3 id="107-allowed-vs-forbidden-changes">10.7 Allowed vs Forbidden Changes</h3>
<p>The formatter/canonicalizer exists to produce a single canonical surface form without changing meaning.</p>

<p>Allowed changes (examples):</p>

<ul>
  <li>Normalize newlines to LF and ensure a trailing newline</li>
  <li>Normalize structural indentation (tabs) for Concept markers and children bodies</li>
  <li>Canonicalize trait layout/spacing without reordering traits</li>
  <li>Canonicalize inline annotation whitespace (trim + internal collapse)</li>
  <li>Canonicalize grouping-annotation labels by whitespace normalization</li>
  <li>Normalize UUID spelling to the canonical form required by §5.8</li>
</ul>

<p>Forbidden changes (examples):</p>

<ul>
  <li>Reorder Concepts or Traits</li>
  <li>Change Content bytes</li>
  <li>Change any bytes inside <code class="language-plaintext highlighter-rouge">CODE:</code> or <code class="language-plaintext highlighter-rouge">MARKDOWN:</code> block annotations</li>
  <li>Guess annotation attachment or reinterpret annotation kinds</li>
  <li>Invent, remove, or rename Concepts/Traits/Values</li>
</ul>

<h3 id="108-normalization-failures">10.8 Normalization Failures</h3>
<p>A canonicalization failure occurs when:</p>

<ul>
  <li>indentation is ambiguous</li>
  <li>annotation attachment is ambiguous</li>
  <li>whitespace cannot be normalized without changing meaning</li>
  <li>structural inconsistencies prevent a unique surface form</li>
</ul>

<p>Canonicalization failures MUST be classified as <code class="language-plaintext highlighter-rouge">FormattingError</code> (§14).</p>

<h3 id="109-formatting-vs-schema-errors">10.9 Formatting vs Schema Errors</h3>
<p>Mandatory distinction:</p>

<ul>
  <li>Formatting errors concern how Codex is written</li>
  <li>Schema errors concern what Codex means</li>
</ul>

<p>Tools MUST NOT report schema errors when the root cause is a formatting failure.</p>

<h3 id="1010-error-classification">10.10 Error Classification</h3>
<p>Formatting and canonicalization failures MUST be classified as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FormattingError
</code></pre></div></div>

<p>They MUST NOT be downgraded to warnings.</p>

<h3 id="1011-prohibited-behaviors">10.11 Prohibited Behaviors</h3>
<p>Codex tools MUST NOT:</p>

<ul>
  <li>silently normalize invalid input</li>
  <li>auto-correct formatting errors without reporting them</li>
  <li>accept multiple canonical forms</li>
  <li>discard or rewrite Content</li>
  <li>depend on source offsets or editor state</li>
</ul>

<h3 id="1012-reporting-requirements">10.12 Reporting Requirements</h3>

<p>Formatting error reports MUST include at minimum:</p>

<ul>
  <li>error class (<code class="language-plaintext highlighter-rouge">FormattingError</code>)</li>
  <li>violated rule</li>
  <li>location (line number or Concept path)</li>
  <li>explanation of canonicalization failure</li>
</ul>

<p>Exact wording is tool-defined.</p>

<h3 id="1013-non-goals">10.13 Non-Goals</h3>

<p>This section does not:</p>

<ul>
  <li>define editor behavior</li>
  <li>prescribe auto-format-on-save policies</li>
  <li>define diff or patch semantics</li>
  <li>define schema validation rules</li>
  <li>define rendering or execution behavior</li>
</ul>

<h3 id="1014-summary">10.14 Summary</h3>

<ul>
  <li>Canonical surface form is mandatory</li>
  <li>Canonicalization is mechanical and deterministic</li>
  <li>Formatting failures are classified as <code class="language-plaintext highlighter-rouge">FormattingError</code> (§14)</li>
  <li>No heuristic or best-effort formatting is permitted</li>
  <li>Formatting is separate from schema validation</li>
</ul>

<hr />

<h2 id="11-schema-definition-language">11. Schema Definition Language</h2>

<p>This section normatively defines the schema definition language for Codex 1.0.0.</p>

<p>It specifies how <strong>schemas themselves are authored in Codex</strong>, including:</p>

<ul>
  <li>Concept definitions</li>
  <li>Trait definitions</li>
  <li>Content, child, trait, and collection rules</li>
  <li>Enumerated value sets</li>
  <li>Entity eligibility</li>
  <li>Declarative constraints</li>
  <li>Schema versioning and compatibility</li>
</ul>

<p>This content is <strong>Normative</strong>.</p>

<hr />

<h3 id="111-purpose">11.1 Purpose</h3>

<p>This section normatively defines the <strong>schema definition language for Codex</strong>.</p>

<p>It specifies how <strong>schemas themselves are authored in Codex</strong>, using the same surface form, parsing rules, and language invariants as instance documents.</p>

<p>The purposes of the schema definition language are to:</p>

<ul>
  <li>make schemas <strong>first-class Codex data</strong></li>
  <li>define all schema semantics <strong>declaratively</strong></li>
  <li>ensure schema validation satisfies the Codex language invariants, including closed-world semantics, determinism, and prohibition of heuristics</li>
  <li>enable schemas to validate other schemas (bootstrapping)</li>
  <li>support deterministic expansion to derived validation artifacts (including SHACL)</li>
</ul>

<p>Schemas authored using this language are authoritative.</p>

<p>Derived representations (for example, SHACL or RDF graphs) MUST NOT introduce semantics not explicitly defined by the schema definition language and this specification.</p>

<p>The Codex language invariants governing schema-first processing, determinism, and failure rules are defined in §9.</p>

<p>The schema definition language is bootstrapped by a built-in <strong>schema-of-schemas</strong>, which itself is expressed using this language. See §12.4.</p>

<hr />

<h3 id="112-core-principles">11.2 Core Principles</h3>

<p>The schema definition language obeys the same language invariants as Codex instance documents.</p>

<p>The following principles are normative:</p>

<ul>
  <li>Schemas are <strong>declarative data</strong>, not executable programs.</li>
  <li>All authorization is <strong>explicit</strong>; nothing is implied or inferred.</li>
  <li>All constraints are <strong>mechanically enforceable</strong>.</li>
  <li>Schema semantics MUST be <strong>closed-world</strong>, <strong>deterministic</strong>, and <strong>free of heuristics</strong>.</li>
  <li>Any schema rule whose semantics cannot be expressed deterministically under this specification MUST cause schema processing to fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</li>
</ul>

<p>Schema validation, schema expansion, and derived-artifact generation MUST satisfy the schema-first requirements defined in §9.</p>

<p>Schemas MUST NOT rely on tool-specific behavior, implicit defaults, or external interpretation beyond what is explicitly defined by this specification and the governing schema-of-schemas.</p>

<hr />

<h3 id="113-schema">11.3 Schema</h3>

<p>A <code class="language-plaintext highlighter-rouge">Schema</code> Concept defines a governing Codex schema.</p>

<p>A <code class="language-plaintext highlighter-rouge">Schema</code> document is the authoritative source of semantic meaning, authorization, and validation rules for Codex documents validated under it.</p>

<p>A schema itself is validated as Codex data under the schema-of-schemas.</p>

<h4 id="traits-1">Traits</h4>
<p>A <code class="language-plaintext highlighter-rouge">Schema</code> Concept MUST declare the following Traits:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">id</code> (required; IRI Reference Value)
The globally unique identifier for the schema. This value is used as <code class="language-plaintext highlighter-rouge">schemaIri</code> throughout schema processing, instance-graph mapping, and derived-artifact generation.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">version</code> (required; String Value)</p>

    <p>A schema version identifier whose ordering is defined by <code class="language-plaintext highlighter-rouge">versionScheme</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">versionScheme</code> (required; Enumerated Token Value)</p>

    <p>Declares the version comparison scheme used to order schema versions within the schema lineage. Allowed values and comparison rules are defined in §13.4.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">compatibilityClass</code> (required; Enumerated Token Value)
One of:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">$BackwardCompatible</code></li>
      <li><code class="language-plaintext highlighter-rouge">$ForwardCompatible</code></li>
      <li><code class="language-plaintext highlighter-rouge">$Breaking</code></li>
    </ul>
  </li>
</ul>

<p>The following Traits are optional:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">title</code> (optional; String Value)</li>
  <li><code class="language-plaintext highlighter-rouge">description</code> (optional; String Value)</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">Schema</code> Concept MUST declare exactly one authoring mode via the <code class="language-plaintext highlighter-rouge">authoringMode</code> Trait, as defined in §9.4.</p>

<p>If <code class="language-plaintext highlighter-rouge">authoringMode</code> is missing, invalid, or mixed, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>All conforming implementations MUST support both the Simplified Authoring Mode and the Canonical Authoring Mode (see §9.4).</p>

<h4 id="children">Children</h4>
<p>A <code class="language-plaintext highlighter-rouge">Schema</code> MUST satisfy the mode-conditional child-Concept rules defined in §9.4.</p>

<p>For <code class="language-plaintext highlighter-rouge">authoringMode=$SimplifiedMode</code>:</p>

<ul>
  <li>A <code class="language-plaintext highlighter-rouge">Schema</code> MUST contain exactly one <code class="language-plaintext highlighter-rouge">ConceptDefinitions</code> child Concept.</li>
  <li>
    <p>The following child Concepts are permitted, in any order:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">TraitDefinitions</code></li>
      <li><code class="language-plaintext highlighter-rouge">EnumeratedValueSets</code></li>
      <li><code class="language-plaintext highlighter-rouge">ConstraintDefinitions</code></li>
      <li><code class="language-plaintext highlighter-rouge">ValueTypeDefinitions</code></li>
      <li><code class="language-plaintext highlighter-rouge">ValidatorDefinitions</code></li>
    </ul>
  </li>
  <li>A <code class="language-plaintext highlighter-rouge">Schema</code> MUST NOT contain <code class="language-plaintext highlighter-rouge">RdfGraph</code>.</li>
</ul>

<p>For <code class="language-plaintext highlighter-rouge">authoringMode=$CanonicalMode</code>:</p>

<ul>
  <li>A <code class="language-plaintext highlighter-rouge">Schema</code> MUST contain exactly one <code class="language-plaintext highlighter-rouge">RdfGraph</code> child Concept.</li>
  <li>
    <p>A <code class="language-plaintext highlighter-rouge">Schema</code> MUST NOT contain any of the following child Concepts:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">ConceptDefinitions</code></li>
      <li><code class="language-plaintext highlighter-rouge">TraitDefinitions</code></li>
      <li><code class="language-plaintext highlighter-rouge">EnumeratedValueSets</code></li>
      <li><code class="language-plaintext highlighter-rouge">ConstraintDefinitions</code></li>
      <li><code class="language-plaintext highlighter-rouge">ValueTypeDefinitions</code></li>
      <li><code class="language-plaintext highlighter-rouge">ValidatorDefinitions</code></li>
    </ul>
  </li>
</ul>

<p>No other child Concepts are permitted.</p>

<p>Each container Concept listed above MUST obey the structural, identity, and content rules defined by this specification and the schema-of-schemas.</p>

<h4 id="semantic-requirements">Semantic Requirements</h4>

<ul>
  <li>A <code class="language-plaintext highlighter-rouge">Schema</code> Concept is an Entity and therefore MUST declare an <code class="language-plaintext highlighter-rouge">id</code>.</li>
  <li>All Concept, Trait, ValueType, and Constraint identifiers used within the schema MUST be resolvable and unique where required.</li>
  <li>A schema MUST be self-contained except for explicitly declared external inputs permitted by this specification.</li>
  <li>A schema MUST be valid under exactly one authoring mode (see §9.4).</li>
  <li>Any schema whose structure or semantics cannot be interpreted deterministically under this specification MUST be rejected with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">Schema</code> Concept defines the boundary within which schema-first parsing, validation, instance-graph mapping, and derived-artifact generation occur, as specified in §9.</p>

<hr />

<h3 id="114-concept-definitions">11.4 Concept Definitions</h3>

<p>This section defines how Codex Concepts are declared in schemas.</p>

<h4 id="1141-conceptdefinition">11.4.1 <code class="language-plaintext highlighter-rouge">ConceptDefinition</code></h4>

<p>A <code class="language-plaintext highlighter-rouge">ConceptDefinition</code> declares a Concept class and its structural, semantic, and identity rules.</p>

<p>A <code class="language-plaintext highlighter-rouge">ConceptDefinition</code> is an Entity.</p>

<h5 id="traits-2">Traits</h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">id</code> (required; IRI Reference Value)</li>
  <li><code class="language-plaintext highlighter-rouge">key</code> (optional; Lookup Token Value)</li>
  <li><code class="language-plaintext highlighter-rouge">name</code> (required; Concept name string, per §4 Naming Rules)</li>
  <li><code class="language-plaintext highlighter-rouge">conceptKind</code> (required; <code class="language-plaintext highlighter-rouge">$Semantic | $Structural | $ValueLike</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">entityEligibility</code> (required; <code class="language-plaintext highlighter-rouge">$MustBeEntity | $MustNotBeEntity</code>)</li>
</ul>

<h5 id="children-1">Children</h5>
<p>A <code class="language-plaintext highlighter-rouge">ConceptDefinition</code> is permitted to contain, in any order:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ContentRules</code> (optional)</li>
  <li><code class="language-plaintext highlighter-rouge">TraitRules</code> (optional)</li>
  <li><code class="language-plaintext highlighter-rouge">ChildRules</code> (optional)</li>
  <li><code class="language-plaintext highlighter-rouge">CollectionRules</code> (optional)</li>
</ul>

<p>No other children are permitted.</p>

<p>If a child section is omitted, its default behavior applies as defined below.</p>

<hr />

<h4 id="1142-contentrules">11.4.2 <code class="language-plaintext highlighter-rouge">ContentRules</code></h4>

<p><code class="language-plaintext highlighter-rouge">ContentRules</code> declares whether instances of the Concept are in content mode or children mode.</p>

<p>This declaration is schema-authoritative and MUST be consulted before parsing Concept bodies in schema-directed processing (§9).</p>

<h5 id="children-2">Children</h5>
<p>Exactly one of:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AllowsContent</code> — instances are in content mode</li>
  <li><code class="language-plaintext highlighter-rouge">ForbidsContent</code> — instances are in children mode</li>
</ul>

<h6 id="allowscontent"><code class="language-plaintext highlighter-rouge">AllowsContent</code></h6>

<p>Traits:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">whitespaceMode</code> (required; Enumerated Token Value)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">whitespaceMode</code> MUST be one of:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$Preformatted</code> — content whitespace is significant and MUST be preserved exactly (e.g., source code, poetry)</li>
  <li><code class="language-plaintext highlighter-rouge">$Flow</code> — content whitespace is not significant; Codex-conforming tools MUST collapse runs of whitespace to single spaces and trim leading/trailing whitespace</li>
</ul>

<h6 id="forbidscontent"><code class="language-plaintext highlighter-rouge">ForbidsContent</code></h6>

<p><code class="language-plaintext highlighter-rouge">ForbidsContent</code> has no traits.</p>

<h5 id="defaults">Defaults</h5>

<p>If <code class="language-plaintext highlighter-rouge">ContentRules</code> is omitted, <code class="language-plaintext highlighter-rouge">ForbidsContent</code> applies.</p>

<hr />

<h4 id="1143-traitrules">11.4.3 <code class="language-plaintext highlighter-rouge">TraitRules</code></h4>

<p><code class="language-plaintext highlighter-rouge">TraitRules</code> declares which Traits are permitted, required, or forbidden on instances of the Concept.</p>

<h5 id="children-3">Children</h5>
<p>One or more of:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">RequiresTrait</code></li>
  <li><code class="language-plaintext highlighter-rouge">AllowsTrait</code></li>
  <li><code class="language-plaintext highlighter-rouge">ForbidsTrait</code></li>
</ul>

<p>If no trait rules are needed, omit the <code class="language-plaintext highlighter-rouge">TraitRules</code> container entirely.</p>

<p>Each rule applies to exactly one trait name.</p>

<h6 id="requirestrait"><code class="language-plaintext highlighter-rouge">RequiresTrait</code></h6>

<p>Traits:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">name</code> (required; Trait name string, per §4)</li>
</ul>

<h6 id="allowstrait"><code class="language-plaintext highlighter-rouge">AllowsTrait</code></h6>

<p>Traits:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">name</code> (required; Trait name string, per §4)</li>
</ul>

<h6 id="forbidstrait"><code class="language-plaintext highlighter-rouge">ForbidsTrait</code></h6>

<p>Traits:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">name</code> (required; Trait name string, per §4)</li>
</ul>

<h5 id="defaults-1">Defaults</h5>

<ul>
  <li>Traits not explicitly allowed or required are forbidden.</li>
  <li>
    <p>If <code class="language-plaintext highlighter-rouge">TraitRules</code> is omitted, no Traits are permitted except:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">id</code>, when permitted or required by <code class="language-plaintext highlighter-rouge">entityEligibility</code></li>
      <li><code class="language-plaintext highlighter-rouge">key</code>, when applicable by schema rules</li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="1144-childrules">11.4.4 <code class="language-plaintext highlighter-rouge">ChildRules</code></h4>

<p><code class="language-plaintext highlighter-rouge">ChildRules</code> declares which child Concepts are permitted, required, or forbidden beneath instances of the Concept.</p>

<h5 id="children-4">Children</h5>
<p>One or more of:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AllowsChildConcept</code></li>
  <li><code class="language-plaintext highlighter-rouge">RequiresChildConcept</code></li>
  <li><code class="language-plaintext highlighter-rouge">ForbidsChildConcept</code></li>
</ul>

<p>If no child rules are needed, omit the <code class="language-plaintext highlighter-rouge">ChildRules</code> container entirely.</p>

<h6 id="allowschildconcept"><code class="language-plaintext highlighter-rouge">AllowsChildConcept</code></h6>

<p>Traits:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">conceptSelector</code> (required; Concept name string)</li>
  <li><code class="language-plaintext highlighter-rouge">min</code> (optional; non-negative integer; default <code class="language-plaintext highlighter-rouge">0</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">max</code> (optional; positive integer; omitted means unbounded)</li>
</ul>

<h6 id="requireschildconcept"><code class="language-plaintext highlighter-rouge">RequiresChildConcept</code></h6>

<p>Traits:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">conceptSelector</code> (required; Concept name string)</li>
  <li><code class="language-plaintext highlighter-rouge">min</code> (optional; positive integer; default <code class="language-plaintext highlighter-rouge">1</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">max</code> (optional; positive integer; omitted means unbounded)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">RequiresChildConcept</code> is semantically equivalent to <code class="language-plaintext highlighter-rouge">AllowsChildConcept</code> with <code class="language-plaintext highlighter-rouge">min = 1</code>.</p>

<h6 id="forbidschildconcept"><code class="language-plaintext highlighter-rouge">ForbidsChildConcept</code></h6>

<p>Traits:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">conceptSelector</code> (required; Concept name string)</li>
</ul>

<h5 id="defaults-2">Defaults</h5>

<p>Child Concepts not explicitly allowed or required are forbidden.</p>

<hr />

<h4 id="1145-collectionrules">11.4.5 <code class="language-plaintext highlighter-rouge">CollectionRules</code></h4>

<p><code class="language-plaintext highlighter-rouge">CollectionRules</code> declares collection semantics for Concepts whose children form a logical collection.</p>

<p>These semantics inform schema validation and deterministic graph mapping (§9).</p>

<h5 id="traits-3">Traits</h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ordering</code> (required; <code class="language-plaintext highlighter-rouge">$Ordered | $Unordered</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">allowsDuplicates</code> (required; boolean)</li>
</ul>

<h5 id="form">Form</h5>

<p><code class="language-plaintext highlighter-rouge">CollectionRules</code> MUST be self-closing and MUST NOT have children.</p>

<h5 id="applicability">Applicability</h5>

<p>If <code class="language-plaintext highlighter-rouge">CollectionRules</code> is present:</p>

<ul>
  <li>Child ordering and duplication semantics MUST be enforced as declared.</li>
  <li>Any schema rule that depends on collection semantics MUST refer to this declaration.</li>
</ul>

<p>If <code class="language-plaintext highlighter-rouge">CollectionRules</code> is absent, no collection semantics are assumed.</p>

<h5 id="ordering-semantics">Ordering Semantics</h5>
<p>The <code class="language-plaintext highlighter-rouge">ordering</code> trait on <code class="language-plaintext highlighter-rouge">CollectionRules</code> specifies whether the order of children in a collection is semantically significant.</p>

<p>Ordering MUST be exactly one of:</p>

<h6 id="ordered"><code class="language-plaintext highlighter-rouge">$Ordered</code></h6>

<p>A collection with <code class="language-plaintext highlighter-rouge">ordering=$Ordered</code> has semantically significant order.</p>

<p>Source order MUST be preserved through all conforming processing.</p>

<p>Conforming implementations MUST NOT reorder children of an <code class="language-plaintext highlighter-rouge">$Ordered</code> collection.</p>

<p>Two <code class="language-plaintext highlighter-rouge">$Ordered</code> collections with identical children in different orders MUST be treated as semantically distinct.</p>

<p>Validation and comparison of <code class="language-plaintext highlighter-rouge">$Ordered</code> collections MUST be order-sensitive.</p>

<h6 id="unordered"><code class="language-plaintext highlighter-rouge">$Unordered</code></h6>

<p>A collection with <code class="language-plaintext highlighter-rouge">ordering=$Unordered</code> has no semantically significant order.</p>

<p>Conforming implementations MUST preserve source order during parsing and general processing.</p>

<p>Validation of <code class="language-plaintext highlighter-rouge">$Unordered</code> collections MUST be order-insensitive.</p>

<p>Semantic comparison of <code class="language-plaintext highlighter-rouge">$Unordered</code> collections MUST be order-insensitive: two <code class="language-plaintext highlighter-rouge">$Unordered</code> collections with identical children in different orders MUST be treated as semantically equivalent.</p>

<p>In canonical surface form, children of an <code class="language-plaintext highlighter-rouge">$Unordered</code> collection MUST be sorted according to the deterministic ordering defined in §10.5.1.</p>

<hr />

<h3 id="115-trait-definitions">11.5. Trait Definitions</h3>

<h4 id="1151-traitdefinition">11.5.1 <code class="language-plaintext highlighter-rouge">TraitDefinition</code></h4>

<p>Defines a Trait independently of any Concept.</p>

<p>Trait definitions establish the value type and constraints for a Trait that may be used across multiple Concepts.</p>

<h6 id="traits-4">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">id</code> (optional; IRI reference)</li>
  <li><code class="language-plaintext highlighter-rouge">name</code> (required; Trait name string per §4 Naming Rules)</li>
  <li><code class="language-plaintext highlighter-rouge">defaultValueType</code> (required unless <code class="language-plaintext highlighter-rouge">defaultValueTypes</code> is provided; value type token, optionally parameterized per §5.17)</li>
  <li><code class="language-plaintext highlighter-rouge">defaultValueTypes</code> (required unless <code class="language-plaintext highlighter-rouge">defaultValueType</code> is provided; list of one or more value type tokens, optionally parameterized per §5.17)</li>
  <li><code class="language-plaintext highlighter-rouge">isReferenceTrait</code> (optional; boolean)</li>
  <li><code class="language-plaintext highlighter-rouge">priority</code> (optional; enumerated token; presentation hint)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">isReferenceTrait</code> is schema metadata only. It MUST NOT change the definition of reference Traits in §7, and it MUST NOT change the reference constraint semantics in §9.9.9–§9.9.12.</p>

<p>If both <code class="language-plaintext highlighter-rouge">defaultValueType</code> and <code class="language-plaintext highlighter-rouge">defaultValueTypes</code> are provided, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p><code class="language-plaintext highlighter-rouge">priority</code> is a meta-schema concern. Implementations MUST NOT use <code class="language-plaintext highlighter-rouge">priority</code> to change validation or compilation semantics. Meta-schemas are permitted to constrain allowed <code class="language-plaintext highlighter-rouge">priority</code> values (e.g., <code class="language-plaintext highlighter-rouge">$Primary</code>, <code class="language-plaintext highlighter-rouge">$Secondary</code>).</p>

<h5 id="value-type-semantics">Value Type Semantics</h5>
<p>When a trait is present on a Concept instance, its value MUST conform to the declared value type.</p>

<p>If <code class="language-plaintext highlighter-rouge">defaultValueType</code> specifies a single type, the value MUST conform to that type.</p>

<p>If <code class="language-plaintext highlighter-rouge">defaultValueTypes</code> specifies multiple types, the value MUST conform to exactly one of the listed types.</p>

<h5 id="collection-type-semantics">Collection Type Semantics</h5>
<p>If a trait’s value type is a parameterized collection type (e.g., <code class="language-plaintext highlighter-rouge">$List&lt;$String&gt;</code>), each element of the collection MUST conform to the declared item type.</p>

<p>If a trait’s value type is an unparameterized collection type (e.g., <code class="language-plaintext highlighter-rouge">$List</code>), elements are permitted to be of any type.</p>

<p>If a trait’s value type is a union containing both scalar and collection types (e.g., <code class="language-plaintext highlighter-rouge">[$String, $List&lt;$String&gt;]</code>), the value MUST conform to exactly one member of the union.</p>

<h5 id="trait-presence">Trait Presence</h5>

<p>Whether a trait must, may, or must not appear on a Concept instance is governed by <code class="language-plaintext highlighter-rouge">TraitRules</code> (<code class="language-plaintext highlighter-rouge">RequiresTrait</code>, <code class="language-plaintext highlighter-rouge">AllowsTrait</code>, <code class="language-plaintext highlighter-rouge">ForbidsTrait</code>), not by its value type.</p>

<h5 id="children-optional">Children (Optional)</h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AllowedValues</code> — constrains the set of valid values</li>
</ul>

<h5 id="example">Example</h5>

<pre><code class="language-cdx">&lt;TraitDefinition
	name="amount"
	defaultValueType=$Number
/&gt;

&lt;TraitDefinition
	name="unit"
	defaultValueType=$EnumeratedToken
&gt;
	&lt;AllowedValues&gt;
		&lt;ValueIsOneOf values=[$Grams, $Kilograms, $Milliliters, $Liters, $Units] /&gt;
	&lt;/AllowedValues&gt;
&lt;/TraitDefinition&gt;

&lt;TraitDefinition
	name="tags"
	defaultValueType=$List&lt;$String&gt;
/&gt;

&lt;TraitDefinition
	name="role"
	defaultValueTypes=[$String, $List&lt;$String&gt;]
/&gt;
</code></pre>

<hr />

<h4 id="1152-allowedvalues">11.5.2 <code class="language-plaintext highlighter-rouge">AllowedValues</code></h4>

<p>Constrains the values a Trait may accept.</p>

<h5 id="children-5">Children</h5>
<p>One or more value constraints:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ValueIsOneOf</code> — value must be in explicit list</li>
  <li><code class="language-plaintext highlighter-rouge">EnumeratedConstraint</code> — value must be member of named enumeration</li>
</ul>

<h5 id="valueisoneof"><code class="language-plaintext highlighter-rouge">ValueIsOneOf</code></h5>

<h6 id="traits-5">Traits</h6>

<ul>
  <li><code class="language-plaintext highlighter-rouge">values</code> (required; list of allowed values)</li>
</ul>

<h5 id="enumeratedconstraint"><code class="language-plaintext highlighter-rouge">EnumeratedConstraint</code></h5>

<h6 id="traits-6">Traits</h6>

<ul>
  <li><code class="language-plaintext highlighter-rouge">set</code> (required; name of an <code class="language-plaintext highlighter-rouge">EnumeratedValueSet</code>)</li>
</ul>

<hr />

<h3 id="116-value-types">11.6 Value Types</h3>

<p>This section defines how schemas constrain the <strong>Value types</strong> permitted for Trait values.</p>

<p>Value types in schemas are <strong>classifiers</strong>, not evaluators. They constrain which surface-form Value spellings (§5) are permitted and how those values may participate in schema-defined constraints.</p>

<h4 id="1161-built-in-value-type-tokens">11.6.1 Built-In Value Type Tokens</h4>
<p>Schemas are permitted to reference the following built-in value type tokens.</p>

<p>Each token corresponds to a Value category defined in §5 (Value Literal Catalog).</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$String</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Char</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Boolean</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Number</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Integer</code></li>
  <li><code class="language-plaintext highlighter-rouge">$EnumeratedToken</code></li>
  <li><code class="language-plaintext highlighter-rouge">$IriReference</code></li>
  <li><code class="language-plaintext highlighter-rouge">$LookupToken</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Uuid</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Color</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Temporal</code></li>
  <li><code class="language-plaintext highlighter-rouge">$List</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Set</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Map</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Tuple</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Range</code></li>
</ul>

<p>A built-in value type token constrains only <strong>surface-form validity and structural classification</strong>.
It MUST NOT imply evaluation, normalization, or conversion beyond what is defined in §5.</p>

<p>See §2.5 and §9.2 for the distinction between schema-less Value-kind classification and schema validation of expected <code class="language-plaintext highlighter-rouge">ValueType</code> constraints.</p>

<p>If a schema constrains a value using a built-in value type token, and a Trait value does not match that Value type’s surface grammar, schema-driven validation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<hr />

<h4 id="1162-valuetypedefinition-optional">11.6.2 <code class="language-plaintext highlighter-rouge">ValueTypeDefinition</code> (Optional)</h4>

<p>A <code class="language-plaintext highlighter-rouge">ValueTypeDefinition</code> defines a <strong>schema-specific named value type</strong> with additional validation semantics.</p>

<p>Schema-defined value types are referenced using Enumerated Token Values whose name matches the <code class="language-plaintext highlighter-rouge">ValueTypeDefinition.name</code>.</p>

<h5 id="container">Container</h5>

<p><code class="language-plaintext highlighter-rouge">ValueTypeDefinitions</code> is a container Concept holding one or more <code class="language-plaintext highlighter-rouge">ValueTypeDefinition</code> children.</p>

<h5 id="traits-7">Traits</h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">id</code> (optional; IRI Reference Value)</li>
  <li><code class="language-plaintext highlighter-rouge">name</code> (required; Concept name string per §4 Naming Rules)</li>
  <li><code class="language-plaintext highlighter-rouge">baseValueType</code> (required; built-in value type token)</li>
  <li><code class="language-plaintext highlighter-rouge">validatorName</code> (optional; Enumerated Token Value identifying a <code class="language-plaintext highlighter-rouge">ValidatorDefinition</code>)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">ValueTypeDefinition</code> names MUST be unique within the Schema.</p>

<p>The <code class="language-plaintext highlighter-rouge">baseValueType</code> defines the surface-form Value category.</p>

<p>If <code class="language-plaintext highlighter-rouge">validatorName</code> is present, schema-driven validation MUST apply the referenced validator as specified in §9.5.2 and §9.11.6.6.</p>

<p>If <code class="language-plaintext highlighter-rouge">validatorName</code> cannot be resolved to exactly one <code class="language-plaintext highlighter-rouge">ValidatorDefinition</code>, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>A <code class="language-plaintext highlighter-rouge">ValueTypeDefinition</code> MUST NOT change the surface grammar of its <code class="language-plaintext highlighter-rouge">baseValueType</code>.</p>

<hr />

<h4 id="1163-enumerated-value-sets">11.6.3 Enumerated Value Sets</h4>

<p>Schemas are permitted to define named sets of Enumerated Token Values.</p>

<p>Enumerated value sets are used exclusively by constraints and Trait definitions; they do not introduce new Value types.</p>

<h5 id="container-1">Container</h5>

<p><code class="language-plaintext highlighter-rouge">EnumeratedValueSets</code> is a container Concept holding one or more <code class="language-plaintext highlighter-rouge">EnumeratedValueSet</code> children.</p>

<h5 id="enumeratedvalueset"><code class="language-plaintext highlighter-rouge">EnumeratedValueSet</code></h5>

<p>Defines a closed set of enumerated tokens.</p>

<h6 id="traits-8">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">name</code> (required; Concept name string per §4 Naming Rules)</li>
</ul>

<h6 id="children-6">Children</h6>
<p>One or more <code class="language-plaintext highlighter-rouge">Member</code> children.</p>

<h5 id="member"><code class="language-plaintext highlighter-rouge">Member</code></h5>

<p>Defines one member of an enumerated value set.</p>

<h6 id="traits-9">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">value</code> (required; token name without <code class="language-plaintext highlighter-rouge">$</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">label</code> (optional; String Value)</li>
  <li><code class="language-plaintext highlighter-rouge">description</code> (optional; String Value)</li>
</ul>

<p>Each <code class="language-plaintext highlighter-rouge">value</code> MUST be unique within its <code class="language-plaintext highlighter-rouge">EnumeratedValueSet</code>.</p>

<hr />

<h4 id="1164-built-in-enumerated-value-sets">11.6.4 Built-In Enumerated Value Sets</h4>
<p>The following enumerated value sets are defined by the Codex language itself and MUST be recognized by all conforming implementations.</p>

<h5 id="conceptkind"><code class="language-plaintext highlighter-rouge">ConceptKind</code></h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$Semantic</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Structural</code></li>
  <li><code class="language-plaintext highlighter-rouge">$ValueLike</code></li>
</ul>

<h5 id="entityeligibility"><code class="language-plaintext highlighter-rouge">EntityEligibility</code></h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$MustBeEntity</code></li>
  <li><code class="language-plaintext highlighter-rouge">$MustNotBeEntity</code></li>
</ul>

<h5 id="compatibilityclass"><code class="language-plaintext highlighter-rouge">CompatibilityClass</code></h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$BackwardCompatible</code></li>
  <li><code class="language-plaintext highlighter-rouge">$ForwardCompatible</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Breaking</code></li>
</ul>

<h5 id="ordering"><code class="language-plaintext highlighter-rouge">Ordering</code></h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$Ordered</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Unordered</code></li>
</ul>

<h5 id="cardinality"><code class="language-plaintext highlighter-rouge">Cardinality</code></h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$Single</code></li>
  <li><code class="language-plaintext highlighter-rouge">$List</code></li>
</ul>

<p>These enumerated sets are authoritative and MUST NOT be redefined by schemas.</p>

<hr />

<h3 id="117-constraint-model">11.7 Constraint Model</h3>

<p>This section defines the <strong>schema constraint model</strong> used to express semantic validation rules.</p>

<p>Constraints are <strong>declarative</strong>, <strong>closed-world</strong>, and <strong>deterministic</strong>.
They describe conditions that MUST hold for a document to be valid under a governing schema.</p>

<p>Constraints:</p>

<ul>
  <li>MUST NOT execute code</li>
  <li>MUST NOT depend on implicit inference</li>
  <li>MUST be mechanically translatable to the schema-first validation model defined in §9</li>
</ul>

<hr />

<h4 id="1171-constraintdefinitions">11.7.1 <code class="language-plaintext highlighter-rouge">ConstraintDefinitions</code></h4>

<p><code class="language-plaintext highlighter-rouge">ConstraintDefinitions</code> is a container Concept that groups named, reusable constraints.</p>

<h5 id="children-7">Children</h5>
<p>One or more <code class="language-plaintext highlighter-rouge">ConstraintDefinition</code> children.</p>

<p>The order of <code class="language-plaintext highlighter-rouge">ConstraintDefinition</code> children MUST be preserved but MUST NOT affect semantics.</p>

<hr />

<h4 id="1172-constraintdefinition">11.7.2 <code class="language-plaintext highlighter-rouge">ConstraintDefinition</code></h4>

<p>A <code class="language-plaintext highlighter-rouge">ConstraintDefinition</code> defines a single named constraint that may be applied to one or more targets.</p>

<p>A <code class="language-plaintext highlighter-rouge">ConstraintDefinition</code> is itself an Entity.</p>

<h5 id="traits-10">Traits</h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">id</code> (required; IRI Reference Value)</li>
  <li><code class="language-plaintext highlighter-rouge">title</code> (optional; String Value)</li>
  <li><code class="language-plaintext highlighter-rouge">description</code> (optional; String Value)</li>
</ul>

<h5 id="children-8">Children</h5>
<p>Exactly two children, in any order:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Targets</code> — declares what the constraint applies to</li>
  <li><code class="language-plaintext highlighter-rouge">Rule</code> — declares the constraint logic</li>
</ul>

<p>If either child is missing or appears more than once, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<hr />

<h4 id="1173-targets">11.7.3 <code class="language-plaintext highlighter-rouge">Targets</code></h4>

<p><code class="language-plaintext highlighter-rouge">Targets</code> declares the focus set for a constraint.</p>

<p>A constraint is permitted to target multiple Concepts and/or contexts.</p>

<h5 id="children-9">Children</h5>
<p>One or more of:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">TargetConcept</code></li>
  <li><code class="language-plaintext highlighter-rouge">TargetContext</code></li>
</ul>

<p>If <code class="language-plaintext highlighter-rouge">Targets</code> contains no children, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<hr />

<h5 id="11731-targetconcept">11.7.3.1 <code class="language-plaintext highlighter-rouge">TargetConcept</code></h5>

<p>Applies the constraint to instances of a specific Concept.</p>

<h6 id="traits-11">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">conceptSelector</code> (required; Concept name string)</li>
</ul>

<p>The selector MUST resolve to exactly one <code class="language-plaintext highlighter-rouge">ConceptDefinition</code>.
Otherwise, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<hr />

<h5 id="11732-targetcontext">11.7.3.2 <code class="language-plaintext highlighter-rouge">TargetContext</code></h5>

<p>Applies the constraint relative to a context.</p>

<h6 id="traits-12">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">contextSelector</code> (required; Concept name string or the literal string <code class="language-plaintext highlighter-rouge">"Document"</code>)</li>
</ul>

<p>If <code class="language-plaintext highlighter-rouge">contextSelector</code> is not <code class="language-plaintext highlighter-rouge">"Document"</code>, it MUST resolve to exactly one <code class="language-plaintext highlighter-rouge">ConceptDefinition</code>.
Otherwise, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<hr />

<h4 id="1174-rule">11.7.4 <code class="language-plaintext highlighter-rouge">Rule</code></h4>

<p><code class="language-plaintext highlighter-rouge">Rule</code> contains the constraint logic.</p>

<h5 id="children-10">Children</h5>
<p>Exactly one child, which MUST be one of:</p>

<ul>
  <li>a <strong>composition rule</strong> (§11.8)</li>
  <li>an <strong>atomic constraint</strong> (§11.10)</li>
  <li>a <strong>path-scoped rule</strong> (§11.9 with quantifier)</li>
</ul>

<p>If <code class="language-plaintext highlighter-rouge">Rule</code> contains zero or more than one child, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p><code class="language-plaintext highlighter-rouge">Rule</code> nodes are purely structural and MUST NOT carry Traits.</p>

<hr />

<h3 id="118-rule-algebra">11.8 Rule Algebra</h3>
<p>This section defines the <strong>rule algebra</strong> used to compose constraints.</p>

<p>Rule algebra nodes are <strong>purely declarative</strong>, <strong>structural</strong>, and <strong>deterministic</strong>.
They define how atomic constraints are combined, without introducing new semantics.</p>

<p>Rule algebra MUST be interpreted according to the schema-first validation model defined in §9.
Rule algebra MUST be translatable to a total, deterministic validation form (for example, SHACL-SPARQL).</p>

<hr />

<h4 id="1181-general-rules">11.8.1 General Rules</h4>

<ul>
  <li>Rule algebra nodes MUST NOT carry Traits.</li>
  <li>Rule algebra nodes MUST contain only other <code class="language-plaintext highlighter-rouge">Rule</code> nodes as children.</li>
  <li>Rule algebra MUST NOT introduce side effects, inference, or execution semantics.</li>
  <li>Any rule tree MUST be finite and acyclic.</li>
</ul>

<p>If a rule algebra structure cannot be translated deterministically, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<hr />

<h4 id="1182-allof">11.8.2 <code class="language-plaintext highlighter-rouge">AllOf</code></h4>

<p><code class="language-plaintext highlighter-rouge">AllOf</code> requires that <strong>all</strong> child rules hold.</p>

<h5 id="children-11">Children</h5>
<p>Two or more <code class="language-plaintext highlighter-rouge">Rule</code> children.</p>

<h5 id="semantics">Semantics</h5>

<p>The rule holds if and only if <strong>every</strong> child rule holds for the same focus node.</p>

<hr />

<h4 id="1183-anyof">11.8.3 <code class="language-plaintext highlighter-rouge">AnyOf</code></h4>

<p><code class="language-plaintext highlighter-rouge">AnyOf</code> requires that <strong>at least one</strong> child rule holds.</p>

<h5 id="children-12">Children</h5>
<p>Two or more <code class="language-plaintext highlighter-rouge">Rule</code> children.</p>

<h5 id="semantics-1">Semantics</h5>

<p>The rule holds if and only if <strong>one or more</strong> child rules hold for the same focus node.</p>

<hr />

<h4 id="1184-not">11.8.4 <code class="language-plaintext highlighter-rouge">Not</code></h4>

<p><code class="language-plaintext highlighter-rouge">Not</code> negates a rule.</p>

<h5 id="children-13">Children</h5>
<p>Exactly one <code class="language-plaintext highlighter-rouge">Rule</code> child.</p>

<h5 id="semantics-2">Semantics</h5>

<p>The rule holds if and only if the child rule does <strong>not</strong> hold for the same focus node.</p>

<hr />

<h4 id="1185-conditionalconstraint">11.8.5 <code class="language-plaintext highlighter-rouge">ConditionalConstraint</code></h4>

<p><code class="language-plaintext highlighter-rouge">ConditionalConstraint</code> expresses implication: <em>if a condition holds, then a consequent must hold</em>.</p>

<h5 id="children-14">Children</h5>
<p>Exactly two children:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">When</code> — contains exactly one <code class="language-plaintext highlighter-rouge">Rule</code> child (the condition)</li>
  <li><code class="language-plaintext highlighter-rouge">Then</code> — contains exactly one <code class="language-plaintext highlighter-rouge">Rule</code> child (the consequent)</li>
</ul>

<h5 id="semantics-3">Semantics</h5>

<p>The rule holds if and only if:</p>

<ul>
  <li>the condition does <strong>not</strong> hold, <strong>or</strong></li>
  <li>the condition holds and the consequent holds</li>
</ul>

<p>This is logically equivalent to:
<code class="language-plaintext highlighter-rouge">¬When ∨ Then</code>.</p>

<hr />

<h4 id="1186-determinism-requirement">11.8.6 Determinism Requirement</h4>

<p>Rule algebra evaluation MUST be:</p>

<ul>
  <li>order-independent (except where explicitly scoped by paths or quantifiers)</li>
  <li>free of heuristic interpretation</li>
  <li>reducible to a single boolean outcome per focus node</li>
</ul>

<p>If rule algebra composition would require guessing, short-circuit heuristics, or undefined evaluation order, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<hr />

<h3 id="119-paths-and-quantifiers">11.9 Paths and Quantifiers</h3>
<p>This section defines <strong>paths</strong> and <strong>quantifiers</strong> used to scope constraint evaluation over structured data.</p>

<p>Paths and quantifiers are <strong>structural selectors</strong>, not semantic operators.
They MUST be interpreted deterministically and MUST NOT introduce inference or implicit traversal rules.</p>

<p>All path and quantifier semantics MUST be compatible with the instance-graph mapping defined in §9.7 and the rule-to-SPARQL translation defined in §9.11.</p>

<hr />

<h4 id="1191-paths">11.9.1 Paths</h4>

<p>A path selects zero or more elements relative to a focus node.</p>

<p>Paths MUST be explicit and MUST NOT depend on implicit defaults, ordering assumptions, or heuristic traversal.</p>

<p>Codex defines the following path types:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">TraitPath</code></li>
  <li><code class="language-plaintext highlighter-rouge">ChildPath</code></li>
  <li><code class="language-plaintext highlighter-rouge">DescendantPath</code></li>
  <li><code class="language-plaintext highlighter-rouge">ContentPath</code></li>
</ul>

<p>Each path node MUST declare exactly the traits required for its form.</p>

<h5 id="traitpath"><code class="language-plaintext highlighter-rouge">TraitPath</code></h5>

<p>Selects values of a Trait on the focus Concept instance.</p>

<h6 id="traits-13">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">traitName</code> (required; Trait name string per the Naming Rules in §4)</li>
</ul>

<h5 id="semantics-4">Semantics</h5>

<p>Selects each value bound to the named Trait on the focus node.</p>

<hr />

<h5 id="childpath"><code class="language-plaintext highlighter-rouge">ChildPath</code></h5>

<p>Selects direct child Concept instances of a given Concept type.</p>

<h6 id="traits-14">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">conceptSelector</code> (required; Concept name string)</li>
</ul>

<h5 id="semantics-5">Semantics</h5>

<p>Selects each direct child of the focus node whose Concept type matches <code class="language-plaintext highlighter-rouge">conceptSelector</code>.</p>

<hr />

<h5 id="descendantpath"><code class="language-plaintext highlighter-rouge">DescendantPath</code></h5>

<p>Selects descendant Concept instances at any depth of a given Concept type.</p>

<h6 id="traits-15">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">conceptSelector</code> (required; Concept name string)</li>
</ul>

<h5 id="semantics-6">Semantics</h5>

<p>Selects each descendant (via one or more parent links) of the focus node whose Concept type matches <code class="language-plaintext highlighter-rouge">conceptSelector</code>.</p>

<hr />

<h5 id="contentpath"><code class="language-plaintext highlighter-rouge">ContentPath</code></h5>

<p>Selects the content of the focus Concept instance.</p>

<h6 id="traits-16">Traits</h6>

<p>None.</p>

<h5 id="semantics-7">Semantics</h5>

<p>Selects the content string if and only if the focus Concept instance is in content mode.</p>

<hr />

<h4 id="1192-quantifiers">11.9.2 Quantifiers</h4>

<p>Quantifiers scope a nested rule over the set of elements selected by a Path.</p>

<p>Quantifiers MUST be explicit and MUST NOT introduce implicit cardinality assumptions.</p>

<p>Codex defines the following quantifiers:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Exists</code></li>
  <li><code class="language-plaintext highlighter-rouge">ForAll</code></li>
  <li><code class="language-plaintext highlighter-rouge">Count</code></li>
</ul>

<p>Quantifiers MUST appear only in rule nodes that explicitly bind a Path to a nested Rule (see §9.5.3).</p>

<hr />

<h5 id="exists"><code class="language-plaintext highlighter-rouge">Exists</code></h5>

<p>At least one selected element MUST satisfy the nested rule.</p>

<h6 id="semantics-8">Semantics</h6>

<p>The rule holds if and only if there exists at least one path-selected element for which the nested rule holds.</p>

<hr />

<h5 id="forall"><code class="language-plaintext highlighter-rouge">ForAll</code></h5>

<p>All selected elements MUST satisfy the nested rule.</p>

<h6 id="semantics-9">Semantics</h6>

<p>The rule holds if and only if no path-selected element violates the nested rule.</p>

<hr />

<h5 id="count"><code class="language-plaintext highlighter-rouge">Count</code></h5>

<p>Constrains the number of selected elements that satisfy the nested rule.</p>

<h6 id="traits-17">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">minCount</code> (optional; non-negative integer)</li>
  <li><code class="language-plaintext highlighter-rouge">maxCount</code> (optional; positive integer)</li>
</ul>

<p>At least one of <code class="language-plaintext highlighter-rouge">minCount</code> or <code class="language-plaintext highlighter-rouge">maxCount</code> MUST be present.</p>

<h6 id="semantics-10">Semantics</h6>

<p>The rule holds if and only if the number of path-selected elements that satisfy the nested rule is within the specified bounds.</p>

<hr />

<h4 id="1193-determinism-and-totality">11.9.3 Determinism and Totality</h4>

<ul>
  <li>Paths MUST select a well-defined set of elements.</li>
  <li>Quantifiers MUST evaluate to a single boolean outcome.</li>
  <li>If a path selector cannot be resolved uniquely, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</li>
  <li>If a quantifier cannot be evaluated without guessing, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</li>
</ul>

<p>Paths and quantifiers MUST NOT be evaluated outside the schema-driven validation pipeline defined in §9.</p>

<hr />

<h3 id="1110-atomic-constraints">11.10 Atomic Constraints</h3>
<p>Atomic constraints are the <strong>leaves</strong> of the rule algebra.
Each atomic constraint defines a single, declarative validation predicate with no internal composition.</p>

<p>Atomic constraints:</p>

<ul>
  <li>MUST be deterministic</li>
  <li>MUST be mechanically enforceable</li>
  <li>MUST be evaluable without inference or heuristics</li>
  <li>MUST be translatable to the schema-driven validation model defined in §9</li>
</ul>

<p>If an atomic constraint cannot be expressed under the instance-graph mapping (§9.7) and the constraint-to-artifact rules (§9.9–§9.11), schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<hr />

<h4 id="11101-trait-constraints">11.10.1 Trait Constraints</h4>

<p>Trait constraints apply to Traits declared on the focus Concept instance.</p>

<h5 id="traitexists"><code class="language-plaintext highlighter-rouge">TraitExists</code></h5>

<p>The named Trait MUST be present.</p>

<h6 id="traits-18">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">trait</code> (required; Trait name string per §4)</li>
</ul>

<hr />

<h5 id="traitmissing"><code class="language-plaintext highlighter-rouge">TraitMissing</code></h5>

<p>The named Trait MUST be absent.</p>

<h6 id="traits-19">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">trait</code> (required; Trait name string per §4)</li>
</ul>

<hr />

<h5 id="traitequals"><code class="language-plaintext highlighter-rouge">TraitEquals</code></h5>

<p>The named Trait MUST have at least one value equal to the specified value.</p>

<h6 id="traits-20">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">trait</code> (required; Trait name string per §4)</li>
  <li><code class="language-plaintext highlighter-rouge">value</code> (required; Value)</li>
</ul>

<hr />

<h5 id="traitcardinality"><code class="language-plaintext highlighter-rouge">TraitCardinality</code></h5>

<p>Constrains the number of values bound to a Trait.</p>

<h6 id="traits-21">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">trait</code> (required; Trait name string per §4)</li>
  <li><code class="language-plaintext highlighter-rouge">min</code> (optional; non-negative integer)</li>
  <li><code class="language-plaintext highlighter-rouge">max</code> (optional; positive integer)</li>
</ul>

<p>At least one of <code class="language-plaintext highlighter-rouge">min</code> or <code class="language-plaintext highlighter-rouge">max</code> MUST be present.</p>

<hr />

<h5 id="traitvaluetype"><code class="language-plaintext highlighter-rouge">TraitValueType</code></h5>

<p>Constrains the value type of a Trait.</p>

<h6 id="traits-22">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">trait</code> (required; Trait name string per §4)</li>
  <li><code class="language-plaintext highlighter-rouge">valueType</code> (required; value type token)</li>
</ul>

<hr />

<h4 id="11102-value-constraints">11.10.2 Value Constraints</h4>

<p>Value constraints apply to values selected by paths or Traits.</p>

<h5 id="valueisoneof-1"><code class="language-plaintext highlighter-rouge">ValueIsOneOf</code></h5>

<p>The value MUST be one of the explicitly listed values.</p>

<h6 id="traits-23">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">values</code> (required; list of Values)</li>
</ul>

<hr />

<h5 id="valuematchespattern"><code class="language-plaintext highlighter-rouge">ValueMatchesPattern</code></h5>

<p>The value MUST match a regular expression.</p>

<h6 id="traits-24">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pattern</code> (required; regex string)</li>
  <li><code class="language-plaintext highlighter-rouge">flags</code> (optional; string; SPARQL 1.1 <code class="language-plaintext highlighter-rouge">REGEX</code> flags)</li>
</ul>

<hr />

<h5 id="patternconstraint"><code class="language-plaintext highlighter-rouge">PatternConstraint</code></h5>

<p>Constrains a specific Trait value to match a regular expression.</p>

<h6 id="traits-25">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">trait</code> (required; Trait name string per §4)</li>
  <li><code class="language-plaintext highlighter-rouge">pattern</code> (required; regex string)</li>
  <li><code class="language-plaintext highlighter-rouge">flags</code> (optional; string; SPARQL 1.1 <code class="language-plaintext highlighter-rouge">REGEX</code> flags)</li>
</ul>

<hr />

<h5 id="valuelength"><code class="language-plaintext highlighter-rouge">ValueLength</code></h5>

<p>Constrains the length of a string value.</p>

<h6 id="traits-26">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">min</code> (optional; non-negative integer)</li>
  <li><code class="language-plaintext highlighter-rouge">max</code> (optional; positive integer)</li>
</ul>

<p>At least one of <code class="language-plaintext highlighter-rouge">min</code> or <code class="language-plaintext highlighter-rouge">max</code> MUST be present.</p>

<hr />

<h5 id="valueinnumericrange"><code class="language-plaintext highlighter-rouge">ValueInNumericRange</code></h5>

<p>Constrains a numeric value to an inclusive range.</p>

<h6 id="traits-27">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">min</code> (optional; number)</li>
  <li><code class="language-plaintext highlighter-rouge">max</code> (optional; number)</li>
</ul>

<p>At least one of <code class="language-plaintext highlighter-rouge">min</code> or <code class="language-plaintext highlighter-rouge">max</code> MUST be present.</p>

<p>This constraint MUST apply only to numeric value types that support ordered comparison.
If comparison semantics are not explicitly defined for the active value type, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<hr />

<h5 id="valueisnonempty"><code class="language-plaintext highlighter-rouge">ValueIsNonEmpty</code></h5>

<p>The value MUST be present and non-empty.</p>

<p>This constraint applies to string-like values only.
If applied to an incompatible value type, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<hr />

<h5 id="valueisvalid"><code class="language-plaintext highlighter-rouge">ValueIsValid</code></h5>

<p>The value MUST satisfy a named validator.</p>

<h6 id="traits-28">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">validatorName</code> (required; enumerated token)</li>
</ul>

<p>The validator MUST resolve to exactly one <code class="language-plaintext highlighter-rouge">ValidatorDefinition</code> in the governing schema.
If resolution fails, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<hr />

<h4 id="11103-child-constraints">11.10.3 Child Constraints</h4>

<p>Child constraints apply to child Concept instances.</p>

<h5 id="childconstraint"><code class="language-plaintext highlighter-rouge">ChildConstraint</code></h5>

<p>Generic child constraint using explicit type dispatch.</p>

<h6 id="traits-29">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">type</code> (required; one of <code class="language-plaintext highlighter-rouge">RequiresChildConcept | AllowsChildConcept | ForbidsChildConcept</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">conceptSelector</code> (required; Concept name string)</li>
</ul>

<p>This form is provided for compatibility and normalization.
Its semantics MUST be equivalent to the corresponding explicit child-rule form defined in §11.4.4.</p>

<hr />

<h5 id="childsatisfies"><code class="language-plaintext highlighter-rouge">ChildSatisfies</code></h5>

<p>Constrains child Concept instances using a nested rule.</p>

<h6 id="traits-30">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">conceptSelector</code> (required; Concept name string)</li>
</ul>

<h6 id="children-15">Children</h6>
<ul>
  <li>Exactly one <code class="language-plaintext highlighter-rouge">Rule</code> child</li>
</ul>

<p>The rule MUST be evaluated for each matching child Concept instance.</p>

<hr />

<h4 id="11104-collection-constraints">11.10.4 Collection Constraints</h4>

<p>Collection constraints apply only where a Concept’s children form a logical collection.</p>

<h5 id="collectionordering"><code class="language-plaintext highlighter-rouge">CollectionOrdering</code></h5>

<p>Constrains the ordering semantics of a collection.</p>

<h6 id="traits-31">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ordering</code> (required; <code class="language-plaintext highlighter-rouge">$Ordered | $Unordered</code>)</li>
</ul>

<h6 id="children-16">Children</h6>
<ul>
  <li>Exactly one of <code class="language-plaintext highlighter-rouge">ChildPath</code> or <code class="language-plaintext highlighter-rouge">DescendantPath</code> (see §9.5.4)</li>
</ul>

<hr />

<h5 id="collectionallowsempty"><code class="language-plaintext highlighter-rouge">CollectionAllowsEmpty</code></h5>

<p>Constrains whether a collection may be empty.</p>

<h6 id="traits-32">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">allowed</code> (required; boolean)</li>
</ul>

<h6 id="children-17">Children</h6>
<ul>
  <li>Exactly one of <code class="language-plaintext highlighter-rouge">ChildPath</code> or <code class="language-plaintext highlighter-rouge">DescendantPath</code> (see §9.5.4)</li>
</ul>

<hr />

<h5 id="collectionallowsduplicates"><code class="language-plaintext highlighter-rouge">CollectionAllowsDuplicates</code></h5>

<p>Constrains whether a collection may contain duplicate members.</p>

<h6 id="traits-33">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">allowed</code> (required; boolean)</li>
  <li><code class="language-plaintext highlighter-rouge">keyTrait</code> (conditional; required when <code class="language-plaintext highlighter-rouge">allowed=false</code>)</li>
</ul>

<h6 id="children-18">Children</h6>
<ul>
  <li>Exactly one of <code class="language-plaintext highlighter-rouge">ChildPath</code> or <code class="language-plaintext highlighter-rouge">DescendantPath</code> (see §9.5.4)</li>
</ul>

<hr />

<h5 id="membercount"><code class="language-plaintext highlighter-rouge">MemberCount</code></h5>

<p>Constrains the number of collection members.</p>

<h6 id="traits-34">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">min</code> (optional; non-negative integer)</li>
  <li><code class="language-plaintext highlighter-rouge">max</code> (optional; positive integer)</li>
</ul>

<p>At least one of <code class="language-plaintext highlighter-rouge">min</code> or <code class="language-plaintext highlighter-rouge">max</code> MUST be present.</p>

<h6 id="children-19">Children</h6>
<ul>
  <li>Exactly one of <code class="language-plaintext highlighter-rouge">ChildPath</code> or <code class="language-plaintext highlighter-rouge">DescendantPath</code> (see §9.5.4)</li>
</ul>

<hr />

<h5 id="eachmembersatisfies"><code class="language-plaintext highlighter-rouge">EachMemberSatisfies</code></h5>

<p>Each collection member MUST satisfy a nested rule.</p>

<h6 id="children-20">Children</h6>
<ul>
  <li>Exactly one of <code class="language-plaintext highlighter-rouge">ChildPath</code> or <code class="language-plaintext highlighter-rouge">DescendantPath</code> (see §9.5.4)</li>
  <li>Exactly one <code class="language-plaintext highlighter-rouge">Rule</code> child</li>
</ul>

<p>The rule MUST be evaluated for each matching collection member.</p>

<hr />

<h4 id="11105-uniqueness-constraints">11.10.5 Uniqueness Constraints</h4>

<h5 id="uniqueconstraint"><code class="language-plaintext highlighter-rouge">UniqueConstraint</code></h5>

<p>Constrains Trait values to be unique within a scope.</p>

<h6 id="traits-35">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">trait</code> (required; Trait name string per §4)</li>
  <li><code class="language-plaintext highlighter-rouge">scope</code> (required; Concept name string defining the uniqueness scope)</li>
</ul>

<p>Uniqueness semantics MUST follow the deterministic scope rules defined in §9.9.7.</p>

<hr />

<h4 id="11106-order-constraints">11.10.6 Order Constraints</h4>

<h5 id="orderconstraint"><code class="language-plaintext highlighter-rouge">OrderConstraint</code></h5>

<p>Constrains the ordering of collection elements by a trait value.</p>

<h6 id="traits-36">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">type</code> (required; one of the order constraint types defined below)</li>
  <li><code class="language-plaintext highlighter-rouge">byTrait</code> (required; Trait name string per §4)</li>
</ul>

<h6 id="types">Types</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Ascending</code>: Elements must be in ascending order by the specified trait value.</li>
  <li><code class="language-plaintext highlighter-rouge">Descending</code>: Elements must be in descending order by the specified trait value.</li>
</ul>

<h6 id="children-21">Children</h6>
<ul>
  <li>Exactly one of <code class="language-plaintext highlighter-rouge">ChildPath</code> or <code class="language-plaintext highlighter-rouge">DescendantPath</code> (see §9.5.4)</li>
</ul>

<p>Order constraint semantics apply to <code class="language-plaintext highlighter-rouge">$Ordered</code> collections only. If an <code class="language-plaintext highlighter-rouge">OrderConstraint</code> is applied to an <code class="language-plaintext highlighter-rouge">$Unordered</code> collection, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).
If a rule cannot be translated deterministically, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<hr />

<h4 id="11107-reference-constraints">11.10.7 Reference Constraints</h4>

<h5 id="referenceconstraint"><code class="language-plaintext highlighter-rouge">ReferenceConstraint</code></h5>

<p>Constrains usage of reference Traits.</p>

<h6 id="traits-37">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">type</code> (required; one of the reference constraint types defined below)</li>
</ul>

<h6 id="types-1">Types</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ReferenceTargetsEntity</code>: Target must be an entity. The <code class="language-plaintext highlighter-rouge">conceptSelector</code> and <code class="language-plaintext highlighter-rouge">traitName</code> traits MUST NOT be present.</li>
  <li><code class="language-plaintext highlighter-rouge">ReferenceMustResolve</code>: Reference must resolve. The <code class="language-plaintext highlighter-rouge">conceptSelector</code> and <code class="language-plaintext highlighter-rouge">traitName</code> traits MUST NOT be present.</li>
  <li><code class="language-plaintext highlighter-rouge">ReferenceSingleton</code>: At most one reference trait may be present. The <code class="language-plaintext highlighter-rouge">conceptSelector</code> and <code class="language-plaintext highlighter-rouge">traitName</code> traits MUST NOT be present.</li>
  <li><code class="language-plaintext highlighter-rouge">ReferenceTargetsConcept</code>: Target must be a specific concept type. The <code class="language-plaintext highlighter-rouge">conceptSelector</code> trait MUST be present.</li>
  <li><code class="language-plaintext highlighter-rouge">ReferenceTraitAllowed</code>: A specific reference trait is allowed. The <code class="language-plaintext highlighter-rouge">traitName</code> trait MUST be present.</li>
</ul>

<p>Reference constraint semantics MUST follow §9.9.9–§9.9.12 exactly.</p>

<hr />

<h4 id="11108-identity-constraints">11.10.8 Identity Constraints</h4>

<h5 id="identityconstraint"><code class="language-plaintext highlighter-rouge">IdentityConstraint</code></h5>

<p>Constrains entity and identifier semantics.</p>

<h6 id="traits-38">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">type</code> (required; one of the identity constraint types defined below)</li>
  <li><code class="language-plaintext highlighter-rouge">scope</code> (optional; Concept name string defining an identity uniqueness scope)</li>
  <li><code class="language-plaintext highlighter-rouge">pattern</code> (optional; regex string)</li>
  <li><code class="language-plaintext highlighter-rouge">flags</code> (optional; string; SPARQL 1.1 <code class="language-plaintext highlighter-rouge">REGEX</code> flags)</li>
</ul>

<h6 id="types-2">Types</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">MustBeEntity</code>: Instance must be an entity. The <code class="language-plaintext highlighter-rouge">scope</code>, <code class="language-plaintext highlighter-rouge">pattern</code>, and <code class="language-plaintext highlighter-rouge">flags</code> traits MUST NOT be present.</li>
  <li><code class="language-plaintext highlighter-rouge">MustNotBeEntity</code>: Instance must not be an entity. The <code class="language-plaintext highlighter-rouge">scope</code>, <code class="language-plaintext highlighter-rouge">pattern</code>, and <code class="language-plaintext highlighter-rouge">flags</code> traits MUST NOT be present.</li>
  <li><code class="language-plaintext highlighter-rouge">IdentifierUniqueness</code>: Identifiers must be unique within scope. The <code class="language-plaintext highlighter-rouge">scope</code> trait MUST be present. The <code class="language-plaintext highlighter-rouge">pattern</code> and <code class="language-plaintext highlighter-rouge">flags</code> traits MUST NOT be present.</li>
  <li><code class="language-plaintext highlighter-rouge">IdentifierForm</code>: Identifier must match pattern. The <code class="language-plaintext highlighter-rouge">pattern</code> trait MUST be present. The <code class="language-plaintext highlighter-rouge">scope</code> trait MUST NOT be present.</li>
</ul>

<p>Identity constraint semantics MUST follow the entity and identity model defined in §§3.5 and 6.</p>

<p><code class="language-plaintext highlighter-rouge">IdentityConstraint(type=MustBeEntity)</code> MUST report an <code class="language-plaintext highlighter-rouge">IdentityError</code> (§14) unless the focus Concept instance is an Entity under §3.5.</p>

<p><code class="language-plaintext highlighter-rouge">IdentityConstraint(type=MustNotBeEntity)</code> MUST report an <code class="language-plaintext highlighter-rouge">IdentityError</code> (§14) if the focus Concept instance declares an <code class="language-plaintext highlighter-rouge">id</code> Trait.</p>

<p>For <code class="language-plaintext highlighter-rouge">MustBeEntity</code> and <code class="language-plaintext highlighter-rouge">MustNotBeEntity</code>, <code class="language-plaintext highlighter-rouge">scope</code>, <code class="language-plaintext highlighter-rouge">pattern</code>, and <code class="language-plaintext highlighter-rouge">flags</code> MUST NOT be present.</p>

<p><code class="language-plaintext highlighter-rouge">IdentityConstraint(type=IdentifierUniqueness, scope=S)</code> constrains identifiers to be unique within the nearest enclosing scope <code class="language-plaintext highlighter-rouge">S</code>.
Its semantics MUST be identical to <code class="language-plaintext highlighter-rouge">UniqueConstraint(trait=id, scope=S)</code> as defined in §9.9.7 (where <code class="language-plaintext highlighter-rouge">id</code> refers to <code class="language-plaintext highlighter-rouge">codex:declaredId</code>).</p>

<p><code class="language-plaintext highlighter-rouge">IdentityConstraint(type=IdentifierForm, pattern=p, flags=f)</code> constrains the spelling of declared identifiers.
When the focus Concept instance is an Entity, its declared <code class="language-plaintext highlighter-rouge">id</code> value MUST match the regular expression <code class="language-plaintext highlighter-rouge">p</code> under SPARQL 1.1 <code class="language-plaintext highlighter-rouge">REGEX</code> semantics (see §9.5.1).</p>

<p>If <code class="language-plaintext highlighter-rouge">pattern</code> is not provided for <code class="language-plaintext highlighter-rouge">IdentityConstraint(type=IdentifierForm)</code>, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>For <code class="language-plaintext highlighter-rouge">IdentifierForm</code>, <code class="language-plaintext highlighter-rouge">scope</code> MUST NOT be present.</p>

<hr />

<h4 id="11109-context-constraints">11.10.9 Context Constraints</h4>

<h5 id="contextconstraint"><code class="language-plaintext highlighter-rouge">ContextConstraint</code></h5>

<p>Constrains the structural context in which a Concept instance may appear.</p>

<h6 id="traits-39">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">type</code> (required; one of the context constraint types defined below)</li>
  <li><code class="language-plaintext highlighter-rouge">contextSelector</code> (Concept name string; see type-specific requirements below)</li>
</ul>

<h6 id="types-3">Types</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">OnlyValidUnderParent</code>: Requires the immediate parent is of the type specified by the <code class="language-plaintext highlighter-rouge">TargetContext</code> in this constraint’s <code class="language-plaintext highlighter-rouge">Targets</code> block. The <code class="language-plaintext highlighter-rouge">ContextConstraint</code> itself MUST NOT have a <code class="language-plaintext highlighter-rouge">contextSelector</code> trait.</li>
  <li><code class="language-plaintext highlighter-rouge">OnlyValidUnderContext</code>: Requires an ancestor of the specified type exists in the parent chain. The <code class="language-plaintext highlighter-rouge">contextSelector</code> trait MUST be present.</li>
</ul>

<p>Context constraint semantics MUST follow §9.9.8.</p>

<hr />

<h4 id="111010-content-constraints">11.10.10 Content Constraints</h4>

<h5 id="contentconstraint"><code class="language-plaintext highlighter-rouge">ContentConstraint</code></h5>

<p>Constrains content presence or structure.</p>

<h6 id="traits-40">Traits</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">type</code> (required; one of the content constraint types defined below)</li>
</ul>

<h6 id="types-4">Types</h6>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ForbidsContent</code>: Requires content is absent. The <code class="language-plaintext highlighter-rouge">pattern</code> and <code class="language-plaintext highlighter-rouge">flags</code> traits MUST NOT be present.</li>
  <li><code class="language-plaintext highlighter-rouge">ContentRequired</code>: Requires content exists. The <code class="language-plaintext highlighter-rouge">pattern</code> and <code class="language-plaintext highlighter-rouge">flags</code> traits MUST NOT be present.</li>
  <li><code class="language-plaintext highlighter-rouge">ContentMatchesPattern</code>: Requires content matches a pattern. The <code class="language-plaintext highlighter-rouge">pattern</code> trait MUST be present. The <code class="language-plaintext highlighter-rouge">flags</code> trait is permitted.</li>
</ul>

<p>Content constraint semantics MUST follow the content model defined in §3.4 and the validation rules defined in §9.9.5.</p>

<hr />

<h4 id="111011-failure-rules">11.10.11 Failure Rules</h4>

<p>If any atomic constraint:</p>

<ul>
  <li>lacks required traits</li>
  <li>references an unresolved selector</li>
  <li>applies to an incompatible value or structure</li>
  <li>requires semantics not explicitly defined</li>
</ul>

<p>schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14) rather than guess.</p>

<hr />

<h3 id="1111-complete-constraint-example-informative">11.11 Complete Constraint Example (Informative)</h3>

<p>This section provides illustrative examples of constraint definitions authored using the schema definition language.</p>

<p>Examples in this section are <strong>informative</strong> and do not introduce additional normative requirements.</p>

<hr />

<pre><code class="language-cdx">&lt;ConstraintDefinition
	id=example:constraint:recipe-requires-title
	title="Recipe requires Title"
&gt;
	&lt;Targets&gt;
		&lt;TargetConcept conceptSelector="Recipe" /&gt;
	&lt;/Targets&gt;
	&lt;Rule&gt;
		&lt;ChildConstraint
			type="RequiresChildConcept"
			conceptSelector="Title"
		/&gt;
	&lt;/Rule&gt;
&lt;/ConstraintDefinition&gt;
</code></pre>

<hr />

<pre><code class="language-cdx">&lt;ConstraintDefinition
	id=example:constraint:non-nullary-requires-parameters
	title="Non-nullary operators require parameters"
&gt;
	&lt;Targets&gt;
		&lt;TargetConcept conceptSelector="OperatorDefinition" /&gt;
	&lt;/Targets&gt;
	&lt;Rule&gt;
		&lt;ConditionalConstraint&gt;
			&lt;When&gt;
				&lt;Not&gt;
					&lt;TraitEquals trait="arity" value=$Nullary /&gt;
				&lt;/Not&gt;
			&lt;/When&gt;
			&lt;Then&gt;
				&lt;ChildConstraint
					type="RequiresChildConcept"
					conceptSelector="Parameters"
				/&gt;
			&lt;/Then&gt;
		&lt;/ConditionalConstraint&gt;
	&lt;/Rule&gt;
&lt;/ConstraintDefinition&gt;
</code></pre>

<hr />

<p>These examples demonstrate:</p>

<ul>
  <li>targeting constraints to specific Concepts</li>
  <li>use of rule algebra (<code class="language-plaintext highlighter-rouge">Not</code>, <code class="language-plaintext highlighter-rouge">ConditionalConstraint</code>)</li>
  <li>reuse of atomic constraints</li>
  <li>deterministic, schema-first validation intent</li>
</ul>

<hr />

<h3 id="1112-relationship-to-external-systems">11.12 Relationship to External Systems</h3>
<p>Codex schemas are <strong>authoritative</strong> with respect to meaning and validation.</p>

<p>External representations are permitted to be derived from Codex schemas, subject to the following constraints:</p>

<ul>
  <li>Any derived representation (including SHACL, SHACL-SPARQL, or OWL) MUST be a pure, deterministic projection of the Codex schema.</li>
  <li>
    <p>Derived artifacts MUST NOT introduce semantics, defaults, inference rules, or interpretation not explicitly defined by:</p>

    <ul>
      <li>this specification, and</li>
      <li>the governing Codex schema.</li>
    </ul>
  </li>
  <li>Derived artifacts MUST NOT override, weaken, or contradict Codex validation semantics.</li>
  <li>If a Codex constraint or rule cannot be expressed faithfully in the chosen external system, derivation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14) rather than approximate.</li>
</ul>

<p>Codex does not defer to external systems for meaning.</p>

<p>External systems are consumers or validation backends only; they are not normative authorities.</p>

<hr />

<h3 id="1113-summary">11.13 Summary</h3>

<ul>
  <li>The schema definition language is itself Codex.</li>
  <li>Schemas are declarative, closed-world, and deterministic.</li>
  <li>All authorization, structure, and constraints are explicit.</li>
  <li>Content mode, traits, children, collections, and references are schema-defined.</li>
  <li>Constraint logic is compositional and total.</li>
  <li>Schemas may validate other schemas via the bootstrap schema-of-schemas.</li>
  <li>External validation artifacts are optional, derived, and non-authoritative.</li>
</ul>

<p>All schema semantics are governed by this specification and by the schema-first architecture defined in §9.</p>

<hr />

<h2 id="12-schema-loading-and-bootstrapping">12. Schema Loading and Bootstrapping</h2>

<p>This section defines how schemas are associated with documents for schema-first parsing and validation.</p>

<h3 id="121-purpose">12.1 Purpose</h3>

<p>Codex is a schema-first language.</p>

<p>A Codex document MUST NOT be semantically validated without an explicit governing schema.</p>

<p>Codex permits schema-less formatting and well-formedness checks that do not require a governing schema, but such checks MUST NOT perform semantic interpretation or validation (see §9.2 and §10.2.1).</p>

<p>This section normatively defines how a conforming implementation obtains the governing schema for a document.</p>

<p>Its goals are to:</p>

<ul>
  <li>ensure that every semantic validation operation has an explicit governing schema</li>
  <li>define a clear and deterministic schema resolution order</li>
  <li>support bootstrapping of the schema language itself via a built-in schema-of-schemas</li>
  <li>ensure failures are reported clearly and classified correctly when a schema is unavailable or invalid</li>
</ul>

<h3 id="122-schema-provision">12.2 Schema Provision</h3>

<p>A conforming implementation MUST require explicit provision of a governing schema.</p>

<p>The governing schema is provided directly by the caller as an explicit input:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parse(documentBytes, governingSchema) → parsedDocument
</code></pre></div></div>

<p>The implementation MUST use the provided schema and MUST NOT attempt to substitute, infer, or override it.</p>

<p>If no governing schema is provided, parsing MUST fail with a <code class="language-plaintext highlighter-rouge">ParseError</code> (§14).</p>

<p>External systems for schema storage, discovery, or distribution do not affect the parsing, validation, or canonicalization of Codex documents and are outside the scope of this specification.</p>

<h3 id="123-bootstrap-schema-of-schemas">12.3 Bootstrap Schema-of-Schemas</h3>
<p>Codex defines a built-in <strong>bootstrap schema-of-schemas</strong> used to parse and validate schema documents authored in Codex.</p>

<p>The bootstrap schema-of-schemas exists to eliminate circular dependency during schema loading and to make the schema definition language self-hosting.</p>

<p>The bootstrap schema-of-schemas is distinct from domain schemas and from ecosystem meta-schemas.
It governs <strong>only</strong> documents whose root Concept is <code class="language-plaintext highlighter-rouge">Schema</code>.</p>

<p>The bootstrap schema-of-schemas MUST NOT be substituted for a missing governing schema when processing an instance document.</p>

<h4 id="1231-requirements">12.3.1 Requirements</h4>

<p>Every conforming implementation MUST:</p>

<ul>
  <li>include the complete bootstrap schema-of-schemas as built-in, immutable data</li>
  <li>use the bootstrap schema-of-schemas to parse and validate schema documents</li>
  <li>ensure the bootstrap schema-of-schemas is applied deterministically and without extension when no explicit governing schema is provided</li>
</ul>

<p>An explicitly provided governing schema for a schema document MUST either be the bootstrap schema-of-schemas itself or a schema that is valid under the bootstrap schema-of-schemas. An implementation MUST NOT partially extend, modify, or augment the bootstrap schema-of-schemas.</p>

<p>The bootstrap schema-of-schemas MUST itself conform to the Codex language invariants (§2) and the schema-first architecture (§9).</p>

<h4 id="1232-schema-document-detection">12.3.2 Schema Document Detection</h4>

<p>A document is a schema document if and only if its root Concept is <code class="language-plaintext highlighter-rouge">Schema</code>.</p>

<p>A document whose root Concept is <code class="language-plaintext highlighter-rouge">Schema</code> MUST be treated as a schema document and MUST NOT be parsed as an instance document under any schema other than the bootstrap schema-of-schemas or an explicitly provided governing schema.</p>

<p>When a parser encounters a root <code class="language-plaintext highlighter-rouge">Schema</code> Concept:</p>

<ol>
  <li>If an explicit governing schema was provided by the caller, that schema MUST be used.</li>
  <li>Otherwise, the built-in bootstrap schema-of-schemas MUST be used.</li>
</ol>

<p>An implementation MUST NOT use any other detection, inference, or fallback mechanisms.</p>

<h4 id="1233-validation-and-error-classification">12.3.3 Validation and Error Classification</h4>

<p>When processing a schema document:</p>

<ul>
  <li>If the document cannot be decoded, tokenized, or structurally parsed, the failure MUST be classified as <code class="language-plaintext highlighter-rouge">ParseError</code> (§14).</li>
  <li>If the document is structurally readable but violates the bootstrap schema-of-schemas or an explicitly provided governing schema, the failure MUST be classified as <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</li>
</ul>

<p>Implementations MUST NOT attempt partial validation, recovery, or best-effort interpretation.</p>

<h4 id="1234-canonical-authority">12.3.4 Canonical Authority</h4>

<p>All schema-language constructs that appear in schema documents are defined <strong>exactly once</strong>:</p>

<ul>
  <li>in the schema definition language specified in §11 of this document</li>
</ul>

<p>The bootstrap schema-of-schemas MUST accept exactly those schema documents that conform to §11, and MUST reject all others with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>The bootstrap schema-of-schemas MUST NOT introduce additional constructs, defaults, or semantics beyond those defined in §11.</p>

<h3 id="124-schema-caching">12.4 Schema Caching</h3>

<p>Caching behavior, eviction policy, persistence, and invalidation strategies are implementation-defined.</p>

<p>Caching MUST NOT change observable parsing, validation, or error-reporting behavior.</p>

<h3 id="125-error-handling">12.5 Error Handling</h3>
<h4 id="1251-schema-unavailable">12.5.1 Schema Unavailable</h4>

<p>If no schema can be obtained through any supported mechanism:</p>

<ul>
  <li>Error class: <code class="language-plaintext highlighter-rouge">ParseError</code> (§14)</li>
  <li>The report MUST indicate that the governing schema was unavailable</li>
  <li>Parsing MUST NOT proceed</li>
</ul>

<h4 id="1252-schema-load-failure">12.5.2 Schema Load Failure</h4>

<p>If schema resolution succeeds but loading the schema fails (for example, network error or file not found):</p>

<ul>
  <li>Error class: <code class="language-plaintext highlighter-rouge">ParseError</code> (§14)</li>
  <li>The report MUST indicate that the schema could not be loaded</li>
  <li>The report MUST include the schema identifier</li>
</ul>

<h4 id="1253-invalid-schema">12.5.3 Invalid Schema</h4>

<p>If a loaded schema is not valid Codex or is not a valid schema under the bootstrap schema-of-schemas:</p>

<ul>
  <li>Error class: <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14)</li>
  <li>The report MUST indicate that schema validation failed</li>
  <li>Underlying schema validation errors MUST be reported</li>
</ul>

<h3 id="126-relationship-to-other-specifications">12.6 Relationship to Other Specifications</h3>

<ul>
  <li>This specification defines schema-first processing semantics (§9).</li>
  <li>This section defines how governing schemas are obtained and bootstrapped (§12).</li>
  <li>The schema definition language itself is defined normatively in §11.</li>
  <li>Formatting and canonicalization rules apply uniformly to both schema documents and non-schema documents (§10).</li>
</ul>

<p>No other specification overrides or weakens these rules.</p>

<hr />

<h2 id="13-schema-versioning">13. Schema Versioning</h2>

<p>This section normatively defines how schemas are versioned and evolved.</p>

<h3 id="131-purpose">13.1 Purpose</h3>

<p>The goals of this section are to:</p>

<ul>
  <li>allow schemas to change without breaking existing data</li>
  <li>make compatibility explicit and inspectable</li>
  <li>prevent silent semantic drift</li>
  <li>support long-lived data and tooling stability</li>
</ul>

<h3 id="132-core-principles">13.2 Core Principles</h3>

<p>Codex schema versioning is governed by the following principles:</p>

<ol>
  <li>Schemas evolve; data persists.</li>
  <li>Compatibility is explicit, not inferred.</li>
  <li>Breaking changes are deliberate.</li>
  <li>Validation is version-aware and conforms to the determinism invariant (§2).</li>
</ol>

<p>Schemas MUST make their versioning intent explicit.</p>

<h3 id="133-schema-identity">13.3 Schema Identity</h3>
<p>Every Codex schema MUST declare its identity and version explicitly.</p>

<p>Schema identity and versioning are defined exclusively by the root <code class="language-plaintext highlighter-rouge">Schema</code> Concept as specified in §11.</p>

<p>Accordingly:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">id</code> Trait of the root <code class="language-plaintext highlighter-rouge">Schema</code> Concept defines the <strong>stable schema identifier</strong>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">version</code> Trait of the root <code class="language-plaintext highlighter-rouge">Schema</code> Concept defines the <strong>schema version</strong>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">versionScheme</code> Trait of the root <code class="language-plaintext highlighter-rouge">Schema</code> Concept defines the <strong>version ordering scheme</strong>.</li>
</ul>

<p>The schema identifier (<code class="language-plaintext highlighter-rouge">Schema id</code>) identifies the schema lineage.
All versions of the same schema MUST share the same schema identifier.</p>

<p>The schema version (<code class="language-plaintext highlighter-rouge">Schema version</code>) identifies the specific set of rules that apply.</p>

<p>A schema document that omits any of the <code class="language-plaintext highlighter-rouge">id</code>, <code class="language-plaintext highlighter-rouge">version</code>, or <code class="language-plaintext highlighter-rouge">versionScheme</code> Traits on the root <code class="language-plaintext highlighter-rouge">Schema</code> Concept MUST be rejected with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>A schema document MUST NOT declare more than one schema identifier.</p>

<p>Within a schema lineage, the schema identifier MUST NOT be redefined or aliased.</p>

<p>Schema identity and version information MUST be treated as authoritative and MUST NOT be inferred, synthesized, or substituted by tooling.</p>

<h3 id="134-version-semantics">13.4 Version Semantics</h3>
<p>Schemas MUST use monotonic versioning within a schema lineage.</p>

<p>Within a schema lineage, all schema versions MUST use the same <code class="language-plaintext highlighter-rouge">versionScheme</code> value; a schema that changes the <code class="language-plaintext highlighter-rouge">versionScheme</code> within a lineage MUST be rejected with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>Regardless of scheme, schema versions MUST form a <strong>total, unambiguous ordering</strong>. A schema whose version ordering is ambiguous or non-comparable MUST be rejected with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>Tools MUST compare schema versions mechanically according to the comparison rules defined in this section for the declared <code class="language-plaintext highlighter-rouge">versionScheme</code>, and MUST NOT apply heuristics, coercion, or fallback rules.</p>

<h4 id="1341-version-schemes">13.4.1 Version Schemes</h4>
<p>The root <code class="language-plaintext highlighter-rouge">Schema</code> Concept’s <code class="language-plaintext highlighter-rouge">versionScheme</code> Trait MUST be one of the following Enumerated Token Values:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$Semver</code></li>
  <li><code class="language-plaintext highlighter-rouge">$DateYYYYMM</code></li>
  <li><code class="language-plaintext highlighter-rouge">$DateYYYYMMDD</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Lexical</code></li>
</ul>

<p>If <code class="language-plaintext highlighter-rouge">versionScheme</code> is not one of these values, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<h4 id="1342-version-comparison-rules">13.4.2 Version Comparison Rules</h4>
<p>For all schemes below, if a <code class="language-plaintext highlighter-rouge">version</code> string does not conform to the required scheme-specific syntax, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p><code class="language-plaintext highlighter-rouge">$Semver</code></p>

<ul>
  <li>Syntax: <code class="language-plaintext highlighter-rouge">MAJOR.MINOR.PATCH</code> where <code class="language-plaintext highlighter-rouge">MAJOR</code>, <code class="language-plaintext highlighter-rouge">MINOR</code>, and <code class="language-plaintext highlighter-rouge">PATCH</code> are base-10 non-negative integers with no leading zeros (the value zero is represented as a single <code class="language-plaintext highlighter-rouge">0</code> digit).</li>
  <li>Comparison: compare by numeric tuple <code class="language-plaintext highlighter-rouge">(MAJOR, MINOR, PATCH)</code>.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">$DateYYYYMM</code></p>

<ul>
  <li>Syntax: <code class="language-plaintext highlighter-rouge">YYYY-MM</code> where <code class="language-plaintext highlighter-rouge">YYYY</code> is four base-10 digits and <code class="language-plaintext highlighter-rouge">MM</code> is <code class="language-plaintext highlighter-rouge">01</code> through <code class="language-plaintext highlighter-rouge">12</code>.</li>
  <li>Comparison: compare by numeric tuple <code class="language-plaintext highlighter-rouge">(YYYY, MM)</code>.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">$DateYYYYMMDD</code></p>

<ul>
  <li>Syntax: <code class="language-plaintext highlighter-rouge">YYYY-MM-DD</code> where <code class="language-plaintext highlighter-rouge">YYYY</code> is four base-10 digits, <code class="language-plaintext highlighter-rouge">MM</code> is <code class="language-plaintext highlighter-rouge">01</code> through <code class="language-plaintext highlighter-rouge">12</code>, and <code class="language-plaintext highlighter-rouge">DD</code> is <code class="language-plaintext highlighter-rouge">01</code> through <code class="language-plaintext highlighter-rouge">31</code>.</li>
  <li>Comparison: compare by numeric tuple <code class="language-plaintext highlighter-rouge">(YYYY, MM, DD)</code>.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">$Lexical</code></p>

<ul>
  <li>Syntax: any String Value.</li>
  <li>Comparison: compare the <code class="language-plaintext highlighter-rouge">version</code> String Values by Unicode scalar value codepoint order, left-to-right; if all compared codepoints are equal, the shorter string is less than the longer string.</li>
</ul>

<h3 id="135-compatibility-classes">13.5 Compatibility Classes</h3>
<p>Each schema version MUST declare exactly one compatibility class. For all versions except the first, the compatibility class declares the relationship to the immediately preceding version in the same schema lineage.</p>

<p>The compatibility class is declared via the <code class="language-plaintext highlighter-rouge">compatibilityClass</code> Trait on the root <code class="language-plaintext highlighter-rouge">Schema</code> Concept as defined in §11.</p>

<p>The <code class="language-plaintext highlighter-rouge">compatibilityClass</code> Trait MUST be one of the following Enumerated Token Values:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$Initial</code></li>
  <li><code class="language-plaintext highlighter-rouge">$BackwardCompatible</code></li>
  <li><code class="language-plaintext highlighter-rouge">$ForwardCompatible</code></li>
  <li><code class="language-plaintext highlighter-rouge">$Breaking</code></li>
</ul>

<p>If <code class="language-plaintext highlighter-rouge">compatibilityClass</code> is not one of these values, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>The declared compatibility class is <strong>normative and enforceable</strong>.</p>

<p>If a schema version’s declared compatibility class is contradicted by its actual effects on validation semantics, the schema MUST be rejected with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<h4 id="1351-initial">13.5.1 Initial</h4>

<p>The first version in a schema lineage MUST declare <code class="language-plaintext highlighter-rouge">compatibilityClass=$Initial</code>.</p>

<p>A schema version that declares <code class="language-plaintext highlighter-rouge">$Initial</code> MUST be the first version in its lineage; if a non-first version declares <code class="language-plaintext highlighter-rouge">$Initial</code>, schema processing MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<h4 id="1352-backwardcompatible">13.5.2 BackwardCompatible</h4>

<p>A backward-compatible schema version guarantees that:</p>

<ul>
  <li>all Codex data that passed schema validation under the immediately preceding version MUST also pass schema validation under this version</li>
  <li>the meaning of existing Concepts and Traits MUST be preserved</li>
  <li>new Concepts or Traits are permitted to be added</li>
  <li>new constraints are permitted to be added only if they do not invalidate any data that was valid under the preceding version</li>
</ul>

<p>If any previously valid data becomes invalid under a schema version declared as backward-compatible, the schema MUST be rejected with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<h4 id="1353-forwardcompatible">13.5.3 ForwardCompatible</h4>

<p>A forward-compatible schema version guarantees that:</p>

<ul>
  <li>Codex data authored for this version is permitted to pass schema validation under the immediately preceding version</li>
  <li>newly introduced constructs are optional and additive</li>
  <li>existing Concepts, Traits, and constraints remain unchanged in meaning</li>
</ul>

<p>Forward compatibility is intended for extension-oriented evolution where older tools can safely ignore newer constructs.</p>

<p>If data authored for a forward-compatible version cannot pass schema validation under the preceding version without loss of meaning, the schema MUST be rejected with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<h4 id="1354-breaking">13.5.4 Breaking</h4>

<p>A breaking schema version declares that:</p>

<ul>
  <li>Codex data valid under the preceding version is permitted to become invalid</li>
  <li>the meaning or constraints of existing Concepts or Traits are permitted to change</li>
  <li>explicit migration is required</li>
</ul>

<p>Any schema version that introduces a breaking change MUST be declared as breaking.</p>

<h3 id="136-what-constitutes-a-breaking-change">13.6 What Constitutes a Breaking Change</h3>
<p>A schema version introduces a breaking change if and only if it violates any guarantee required by the <code class="language-plaintext highlighter-rouge">$BackwardCompatible</code> or <code class="language-plaintext highlighter-rouge">$ForwardCompatible</code> compatibility classes with respect to the immediately preceding version.</p>

<p>The following changes are breaking and MUST require <code class="language-plaintext highlighter-rouge">compatibilityClass=$Breaking</code>:</p>

<ul>
  <li>removing a <code class="language-plaintext highlighter-rouge">ConceptDefinition</code></li>
  <li>renaming a Concept</li>
  <li>removing a <code class="language-plaintext highlighter-rouge">TraitDefinition</code></li>
  <li>renaming a Trait</li>
  <li>changing the value type or reference semantics of an existing Trait</li>
  <li>changing <code class="language-plaintext highlighter-rouge">entityEligibility</code> for any Concept</li>
  <li>changing collection semantics, including ordering or duplicate allowance</li>
  <li>changing identity, reference, or uniqueness semantics</li>
  <li>tightening constraints in a way that causes any previously valid data to become invalid</li>
  <li>changing the meaning or interpretation of any existing Concept or Trait</li>
</ul>

<p>A schema version that introduces any breaking change without declaring <code class="language-plaintext highlighter-rouge">compatibilityClass=$Breaking</code> is invalid and MUST be rejected with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<p>Documentation-only changes, comments, or purely presentational metadata that do not affect validation or meaning do not constitute breaking changes.</p>

<h3 id="137-non-breaking-changes">13.7 Non-Breaking Changes</h3>
<p>A schema version is permitted to be declared as non-breaking only if it preserves all validation and semantic guarantees required by its declared compatibility class.</p>

<p>The following changes are non-breaking <strong>only when they do not invalidate any data that was valid under the immediately preceding version</strong>:</p>

<ul>
  <li>adding new <code class="language-plaintext highlighter-rouge">ConceptDefinition</code> entries</li>
  <li>adding new <code class="language-plaintext highlighter-rouge">TraitDefinition</code> entries</li>
  <li>adding optional Traits to existing Concepts</li>
  <li>adding new Structural Concepts that do not alter existing structure</li>
  <li>adding new constraints that apply <strong>only</strong> to newly introduced Concepts or Traits</li>
  <li>adding documentation, labels, or descriptive metadata with no semantic effect</li>
</ul>

<p>Non-breaking changes MUST NOT:</p>

<ul>
  <li>alter the interpretation of any existing Concept, Trait, or Value Type</li>
  <li>restrict previously allowed structures, values, or relationships</li>
  <li>introduce new required Traits, Children, or Content on existing Concepts</li>
</ul>

<p>If any change classified as non-breaking would cause previously valid data to fail validation, the schema version MUST instead be declared as <code class="language-plaintext highlighter-rouge">compatibilityClass=$Breaking</code>.</p>

<h3 id="138-schema-validation-behavior">13.8 Schema Validation Behavior</h3>
<p>When validating a Codex document, the governing schema version MUST be explicitly known.</p>

<p>Validation MUST be performed strictly according to the rules of that schema version.</p>

<p>A conforming implementation MUST:</p>

<ul>
  <li>use exactly the rules defined by the declared schema version</li>
  <li>treat schema identifier and version as part of the validation input</li>
  <li>fail validation with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14) if the schema version is missing, ambiguous, or cannot be resolved</li>
  <li>fail validation with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14) if the declared compatibility class is violated by the schema’s actual effects</li>
</ul>

<p>A conforming implementation MUST NOT:</p>

<ul>
  <li>infer schema version intent</li>
  <li>substitute a different schema version</li>
  <li>relax or tighten validation rules across versions</li>
  <li>silently reinterpret data authored under a different schema version</li>
</ul>

<p>If schema version resolution fails for any reason, validation MUST fail with a <code class="language-plaintext highlighter-rouge">SchemaError</code> (§14).</p>

<h3 id="139-relationship-to-data-migration">13.9 Relationship to Data Migration</h3>
<p>This specification defines schema evolution semantics, not data migration mechanisms.</p>

<p>A breaking schema version declaration MUST be treated as a statement that migration is required for existing data to validate under the new schema version.</p>

<p>Codex schemas MUST:</p>

<ul>
  <li>explicitly declare when a version is breaking</li>
  <li>define what semantic rules have changed between versions</li>
  <li>NOT imply or embed migration behavior</li>
</ul>

<p>Codex tooling MUST:</p>

<ul>
  <li>NOT perform implicit or heuristic data migration</li>
  <li>NOT alter data to make it validate under a different schema version</li>
  <li>treat migration as an explicit, external process</li>
</ul>

<p>Any migrated data MUST validate cleanly under the target schema version using ordinary schema validation rules.</p>

<p>Migration tooling, if provided, is outside the scope of this specification and MUST be explicit, deterministic, and non-heuristic.</p>

<h3 id="1310-tooling-responsibilities">13.10 Tooling Responsibilities</h3>
<p>Codex tooling MUST:</p>

<ul>
  <li>surface the governing schema identifier and version as explicit inputs to validation</li>
  <li>surface the declared compatibility class for the schema version</li>
  <li>refuse to validate data against a schema version whose compatibility class does not permit such validation</li>
  <li>refuse to validate data when schema identifier, version, or compatibility class is missing or ambiguous</li>
  <li>treat schema identifier, version, and compatibility class as part of the validation contract</li>
</ul>

<p>Codex tooling MUST NOT:</p>

<ul>
  <li>silently reinterpret data across schema versions</li>
  <li>infer compatibility or intent beyond what is explicitly declared</li>
  <li>downgrade or upgrade schema versions implicitly</li>
  <li>validate data against an incompatible schema version</li>
</ul>

<p>All version handling MUST be explicit, deterministic, and free of heuristics.</p>

<hr />

<h2 id="14-validation-errors">14. Validation Errors</h2>

<h3 id="141-purpose">14.1 Purpose</h3>

<p>This section defines the closed set of validation error classes in Codex.</p>

<p>Its goals are to:</p>

<ul>
  <li>make failures precise and predictable</li>
  <li>ensure consistent classification across tools</li>
  <li>avoid vague reporting and classification approaches that violate the language invariants (§2)</li>
  <li>separate parsing, surface form, formatting/canonicalization, and schema failures cleanly</li>
</ul>

<p>This section governs error classification only, not wording, UI presentation, or recovery behavior.</p>

<h3 id="142-primary-error-class-requirement">14.2 Primary Error Class Requirement</h3>
<p>Every Codex failure MUST belong to exactly one primary error class.</p>

<p>Tools MUST report exactly one primary error class; additional diagnostic details MUST NOT obscure or replace the primary classification.</p>

<h3 id="143-closed-set-of-error-classes-top-level">14.3 Closed Set of Error Classes (Top Level)</h3>
<p>Codex defines the following closed set of top-level error classes:</p>

<ol>
  <li>ParseError</li>
  <li>SurfaceFormError</li>
  <li>FormattingError</li>
  <li>SchemaError</li>
  <li>IdentityError</li>
  <li>ReferenceError</li>
  <li>CollectionError</li>
  <li>ContextError</li>
  <li>ConstraintError</li>
</ol>

<p>An implementation MUST NOT define additional top-level error classes.</p>

<p>Validation MUST proceed in the following order:</p>

<ol>
  <li>Parsing (ParseError)</li>
  <li>Surface form validation (SurfaceFormError)</li>
  <li>Canonicalization (FormattingError)</li>
  <li>Schema validation (SchemaError, IdentityError, ReferenceError, CollectionError, ContextError, ConstraintError)</li>
</ol>

<p>Processing MUST halt at the first failure. A failure in an earlier phase MUST NOT be reported as a later-phase error class.</p>

<p>When a violation matches multiple schema-level error classes (4–9), the implementation MUST classify it as the earliest matching class in the enumerated order.</p>

<h3 id="144-error-class-definitions">14.4 Error Class Definitions</h3>

<h4 id="1441-parseerror">14.4.1 ParseError</h4>

<p>Definition: a <code class="language-plaintext highlighter-rouge">.cdx</code> file cannot be parsed into a syntactic structure.</p>

<p>Characteristics:</p>

<ul>
  <li>input is not structurally readable</li>
  <li>parsing cannot continue</li>
  <li>well-formedness checks MUST NOT require a governing schema</li>
</ul>

<p>Examples (illustrative):</p>

<ul>
  <li>unbalanced Concept markers</li>
  <li>invalid string literal escaping</li>
  <li>malformed Traits</li>
  <li>unterminated Annotation (missing closing <code class="language-plaintext highlighter-rouge">]</code>)</li>
  <li>structurally invalid nesting of markers</li>
</ul>

<h4 id="1442-surfaceformerror">14.4.2 SurfaceFormError</h4>

<p>Definition: a file parses successfully but violates the surface form requirements (§8).</p>

<p>Characteristics:</p>

<ul>
  <li>syntax is readable</li>
  <li>surface requirements are violated</li>
  <li>this class concerns schema-independent surface rules defined in §8</li>
</ul>

<p>Examples (illustrative):</p>

<ul>
  <li>invalid casing in Concept or Trait names</li>
  <li>multiple root Concepts in a file</li>
  <li>forbidden whitespace around <code class="language-plaintext highlighter-rouge">=</code></li>
  <li>annotation opening <code class="language-plaintext highlighter-rouge">[</code> not at first non-whitespace position</li>
</ul>

<h4 id="1443-formattingerror">14.4.3 FormattingError</h4>

<p>Definition: input parses and passes surface-form requirements but cannot be transformed into canonical surface form.</p>

<p>See §10 for canonicalization rules.</p>

<p>Characteristics:</p>

<ul>
  <li>canonicalization MUST be deterministic or MUST fail</li>
  <li>tools MUST NOT guess or “best-effort” normalize</li>
</ul>

<p>Examples (illustrative):</p>

<ul>
  <li>ambiguous annotation attachment</li>
  <li>non-deterministic blank-line/whitespace normalization that would change annotation kind</li>
  <li>whitespace patterns that cannot be normalized without changing structure</li>
  <li>any other canonicalization failure</li>
</ul>

<h4 id="1444-schemaerror">14.4.4 SchemaError</h4>

<p>Definition: parsed Codex violates schema-defined rules.</p>

<p>Characteristics:</p>

<ul>
  <li>the governing schema is consulted</li>
  <li>Concepts or Traits are invalid under the governing schema</li>
</ul>

<p>Examples (illustrative):</p>

<ul>
  <li>unauthorized Trait on a Concept</li>
  <li>missing required Trait</li>
  <li>invalid Trait value type</li>
</ul>

<p>See §9 and §11 for schema rules.</p>

<h4 id="1445-identityerror">14.4.5 IdentityError</h4>

<p>Definition: identity rules are violated.</p>

<p>See §6 for identifier rules.</p>

<p>Characteristics:</p>

<ul>
  <li>concerns Entity eligibility and identifier use</li>
  <li>compromises stable identity or uniqueness</li>
</ul>

<p>Examples (illustrative):</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">id</code> declared on a Concept that MUST NOT be an Entity</li>
  <li>missing required <code class="language-plaintext highlighter-rouge">id</code> where schema requires an Entity</li>
  <li>duplicate identifiers within a schema-defined scope</li>
  <li>identifier form invalid under schema constraints</li>
</ul>

<h4 id="1446-referenceerror">14.4.6 ReferenceError</h4>

<p>Definition: reference Traits are invalid or inconsistent.</p>

<p>See §7 for reference trait semantics.</p>

<p>Characteristics:</p>

<ul>
  <li>involves <code class="language-plaintext highlighter-rouge">reference</code>, <code class="language-plaintext highlighter-rouge">target</code>, or <code class="language-plaintext highlighter-rouge">for</code> Traits</li>
  <li>concerns relationships between Concepts</li>
</ul>

<p>Examples (illustrative):</p>

<ul>
  <li>violation of a governing schema’s <code class="language-plaintext highlighter-rouge">ReferenceConstraint(type=ReferenceSingleton)</code> requirement</li>
  <li>reference to a non-existent Entity (where resolution is required)</li>
  <li>reference to an Entity of an unauthorized Concept type</li>
</ul>

<h4 id="1447-collectionerror">14.4.7 CollectionError</h4>

<p>Definition: schema-defined collection rules are violated.</p>

<p>Characteristics:</p>

<ul>
  <li>concerns schema-defined collection Concepts</li>
  <li>membership, ordering, or cardinality rules are violated</li>
</ul>

<p>See §11 for collection constraint definitions.</p>

<p>Examples (illustrative):</p>

<ul>
  <li>mixed member Concept types in a collection</li>
  <li>missing required members</li>
  <li>duplicate membership where forbidden</li>
  <li>member count outside required bounds</li>
</ul>

<h4 id="1448-contexterror">14.4.8 ContextError</h4>

<p>Definition: a Concept or Trait is used outside its schema-defined context.</p>

<p>Characteristics:</p>

<ul>
  <li>the Concept or Trait name is valid</li>
  <li>the usage violates containment or scope rules</li>
</ul>

<p>See §11 for context constraint definitions.</p>

<p>Examples (illustrative):</p>

<ul>
  <li>Concept allowed only under a specific parent appears elsewhere</li>
  <li>Trait allowed only in a particular context appears outside it</li>
</ul>

<h4 id="1449-constrainterror">14.4.9 ConstraintError</h4>

<p>Definition: schema-defined declarative constraints are violated beyond basic structure and authorization.</p>

<p>Characteristics:</p>

<ul>
  <li>logical or semantic invariants fail</li>
  <li>constraints are schema-defined and mechanically enforceable</li>
</ul>

<p>Examples (illustrative):</p>

<ul>
  <li>mutually exclusive Traits both present</li>
  <li>invalid combinations of Traits</li>
  <li>value range violations</li>
  <li>domain-specific invariant failures</li>
</ul>

<p>See §11 for constraint definitions.</p>

<h3 id="145-error-severity">14.5 Error Severity</h3>
<p>Codex errors are not warnings.</p>

<ul>
  <li>any failure halts compilation or processing</li>
  <li>tools MUST NOT attempt best-effort recovery</li>
  <li>tools MUST NOT silently reinterpret invalid data</li>
</ul>

<h3 id="146-reporting-requirements">14.6 Reporting Requirements</h3>
<p>Tools MUST report validation failures with:</p>

<ul>
  <li>the primary error class</li>
  <li>the Concept name</li>
  <li>the Trait name (if applicable)</li>
  <li>a reference to the violated rule or constraint</li>
  <li>a precise location (line number or Concept path)</li>
</ul>

<p>If any of the above information is not applicable, the tool MUST omit it explicitly rather than infer or guess.</p>

<p>Error wording, formatting, and presentation are tool-defined, but classification and attribution MUST be precise and deterministic.</p>

<h3 id="147-non-goals">14.7 Non-Goals</h3>

<p>This section does not:</p>

<ul>
  <li>define message wording</li>
  <li>mandate UX</li>
  <li>define recovery strategies</li>
  <li>prescribe exception hierarchies</li>
  <li>define logging formats</li>
</ul>

<p>It defines what kind of error occurred, not how it is presented.</p>

<h3 id="148-summary">14.8 Summary</h3>

<ul>
  <li>every failure has exactly one primary error class</li>
  <li>error classes are finite and closed</li>
  <li>parsing, surface form, formatting/canonicalization, and schema are separated</li>
  <li>failures are fatal within their primary error class</li>
</ul>

<hr />

<h2 id="appendix-a-formal-grammar">Appendix A. Formal Grammar</h2>

<p>This appendix defines the formal grammar of the Codex surface form (§8).</p>

<p>Two grammar notations are provided:</p>

<ul>
  <li>EBNF (Normative) — ISO/IEC 14977 Extended Backus-Naur Form</li>
  <li>PEG (Informative) — Parsing Expression Grammar for implementation</li>
</ul>

<h3 id="a1-ebnf">A.1 EBNF</h3>
<h4 id="a11-notation">A.1.1 Notation</h4>

<p>This grammar is based on ISO/IEC 14977 EBNF notation with extensions:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">=</code> defines a production</li>
  <li><code class="language-plaintext highlighter-rouge">,</code> concatenation</li>
  <li><code class="language-plaintext highlighter-rouge">|</code> alternation</li>
  <li><code class="language-plaintext highlighter-rouge">[ ... ]</code> optional (zero or one)</li>
  <li><code class="language-plaintext highlighter-rouge">{ ... }</code> repetition (zero or more)</li>
  <li><code class="language-plaintext highlighter-rouge">( ... )</code> grouping</li>
  <li><code class="language-plaintext highlighter-rouge">" ... "</code> terminal string</li>
  <li><code class="language-plaintext highlighter-rouge">' ... '</code> terminal string (alternative)</li>
  <li><code class="language-plaintext highlighter-rouge">(* ... *)</code> comment</li>
  <li><code class="language-plaintext highlighter-rouge">-</code> exception</li>
  <li><code class="language-plaintext highlighter-rouge">;</code> end of production</li>
</ul>

<p>Character classes use the following extensions:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">#x0000</code> Unicode code point</li>
  <li><code class="language-plaintext highlighter-rouge">[a-z]</code> character range</li>
  <li><code class="language-plaintext highlighter-rouge">\t</code> tab (U+0009)</li>
  <li><code class="language-plaintext highlighter-rouge">\n</code> line feed (U+000A)</li>
</ul>

<hr />

<h4 id="a12-document-structure">A.1.2 Document Structure</h4>

<pre><code class="language-ebnf">(* A Codex document contains exactly one root Concept and MUST end with
   a trailing newline followed by EOF (§8.2). *)

Document
	= OptionalLeadingAnnotations, RootConcept, OptionalTrailingBlankLines, EOF
	;

OptionalLeadingAnnotations
	= { GeneralOrGroupingAnnotationBlock }
	;

OptionalTrailingBlankLines
	= { BlankLine }
	;

EOF
	= (* end of input; no further characters *)
	;

RootConcept
	= ConceptAtColumn0
	;

ConceptAtColumn0
	= ConceptLineStart0, BlockConcept
	| ConceptLineStart0, SelfClosingConcept, Newline
	;

ConceptLineStart0
	= (* beginning of file or immediately after Newline *)
	  [ Newline ]
	;

(* A general or grouping annotation block may appear before the root concept.
	This grammar admits them structurally; their kind/attachment rules are checked
	by the surface-form rules (§8.9). *)
GeneralOrGroupingAnnotationBlock
	= { BlankLine }, Annotation, { BlankLine }
	;

Concept
	= BlockConcept | SelfClosingConcept
	;
</code></pre>

<hr />

<h4 id="a13-block-concepts">A.1.3 Block Concepts</h4>

<pre><code class="language-ebnf">(* Block concepts contain either children or content.
	The parser consults the governing schema (§11) to select the Body production.
	This is schema-directed dispatch, not syntactic ambiguity. *)

BlockConcept
	= OpeningMarkerLine, Body, ClosingMarkerLine
	;

OpeningMarkerLine
	= Indentation, OpeningMarker, Newline
	;

ClosingMarkerLine
	= Indentation, ClosingMarker, Newline
	;

OpeningMarker
	= "&lt;", ConceptName, [ Traits ], "&gt;"
	;

ClosingMarker
	= "&lt;/", ConceptName, "&gt;"
	;

(* Body is selected by schema lookup on ConceptName (§11):
	- If schema indicates children mode: ChildrenBody
	- If schema indicates content mode: ContentBody *)
Body
	= ChildrenBody | ContentBody
	;

ChildrenBody
	= { ChildItem }
	;

(* A ChildItem is either:
	- an annotation line/block, or
	- a child concept (block or self-closing), each on its own structural line.
	Blank-line legality is enforced by surface-form rules (§8); the grammar admits both. *)
ChildItem
	= ( BlankLine
	  | AnnotationLine
	  | AnnotationBlock
	  | ConceptLine
	  )
	;

ConceptLine
	= Indentation, ConceptMarkerOrConcept, Newline
	;

(* Within a children body, a child concept is either a self-closing marker
	or a nested block concept (handled by the Concept production). *)
ConceptMarkerOrConcept
	= SelfClosingMarker
	| Concept
	;

ContentBody
	= { ContentLine }
	;

ContentLine
	= Indentation, ContentText, Newline
	;

ContentText
	= { ContentChar }
	;

ContentChar
	= ContentEscape | ContentSafeChar
	;

ContentEscape
	= "\\", ( "&lt;" | "[" )
	;

(* Raw '&lt;' is forbidden anywhere in content; raw '[' at line start is
	validated by surface-form rules (§8.8). *)
ContentSafeChar
	= AnyCharExceptNewline - "&lt;"
	;
</code></pre>

<hr />

<h4 id="a14-self-closing-concepts">A.1.4 Self-Closing Concepts</h4>

<pre><code class="language-ebnf">SelfClosingConcept
	= SelfClosingMarker
	;

SelfClosingMarker
	= "&lt;", ConceptName, [ Traits ], "/&gt;"
	;
</code></pre>

<hr />

<h4 id="a15-concept-names">A.1.5 Concept Names</h4>

<pre><code class="language-ebnf">(* Naming rule details beyond basic lexical form (e.g., no runs of uppercase)
	are enforced by surface-form validation (§4). *)

ConceptName
	= UppercaseLetter, { Letter | Digit }
	;

UppercaseLetter
	= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
	| "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
	| "U" | "V" | "W" | "X" | "Y" | "Z"
	;

LowercaseLetter
	= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j"
	| "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t"
	| "u" | "v" | "w" | "x" | "y" | "z"
	;

Letter
	= UppercaseLetter | LowercaseLetter
	;

Digit
	= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	;
</code></pre>

<hr />

<h4 id="a16-traits">A.1.6 Traits</h4>

<pre><code class="language-ebnf">Traits
	= WhitespaceNoNewline, Trait, { Whitespace, Trait }
	;

Trait
	= TraitName, "=", Value
	;

(* Naming rule details beyond basic lexical form are enforced by surface-form validation (§4). *)
TraitName
	= LowercaseLetter, { Letter | Digit }
	;
</code></pre>

<hr />

<h4 id="a17-values">A.1.7 Values</h4>

<pre><code class="language-ebnf">Value
	= StringValue
	| CharValue
	| BacktickString
	| BooleanValue
	| NumericValue
	| EnumeratedToken
	| TemporalValue
	| ColorValue
	| UuidValue
	| LookupToken
	| IriReference
	| ListValue
	| SetValue
	| MapValue
	| TupleValue
	| RangeValue
	;
</code></pre>

<hr />

<h4 id="a18-string-values">A.1.8 String Values</h4>

<pre><code class="language-ebnf">StringValue
	= '"', { StringChar }, '"'
	;

StringChar
	= UnescapedStringChar | EscapeSequence
	;

UnescapedStringChar
	= AnyCharExceptQuoteBackslashNewline
	;

EscapeSequence
	= "\\", ( '"' | "\\" | "n" | "r" | "t" | UnicodeEscape )
	;

UnicodeEscape
	= "u", HexDigit, HexDigit, HexDigit, HexDigit
	| "u{", HexDigit, { HexDigit }, "}"
	;

HexDigit
	= Digit
	| "a" | "b" | "c" | "d" | "e" | "f"
	| "A" | "B" | "C" | "D" | "E" | "F"
	;
</code></pre>

<hr />

<h4 id="a19-character-values">A.1.9 Character Values</h4>

<pre><code class="language-ebnf">CharValue
	= "'", CharContent, "'"
	;

CharContent
	= UnescapedChar | CharEscapeSequence
	;

UnescapedChar
	= AnyCharExceptApostropheBackslashNewline
	;

CharEscapeSequence
	= "\\", ( "'" | "\\" | "n" | "r" | "t" | UnicodeEscape )
	;
</code></pre>

<hr />

<h4 id="a110-backtick-strings">A.1.10 Backtick Strings</h4>

<pre><code class="language-ebnf">BacktickString
	= "`", { BacktickChar }, "`"
	;

BacktickChar
	= UnescapedBacktickChar | BacktickEscape
	;

UnescapedBacktickChar
	= AnyCharExceptBacktick
	;

BacktickEscape
	= "\\", "`"
	;
</code></pre>

<hr />

<h4 id="a111-boolean-values">A.1.11 Boolean Values</h4>

<pre><code class="language-ebnf">BooleanValue
	= "true" | "false"
	;
</code></pre>

<hr />

<h4 id="a112-numeric-values">A.1.12 Numeric Values</h4>

<pre><code class="language-ebnf">NumericValue
	= ComplexNumber
	| ImaginaryNumber
	| Fraction
	| Infinity
	| PrecisionNumber
	| ScientificNumber
	| DecimalNumber
	| Integer
	;

Sign
	= "+" | "-"
	;

Integer
	= [ Sign ], IntegerDigits
	;

DecimalNumber
	= [ Sign ], IntegerDigits, ".", DigitSequence
	;

ScientificNumber
	= ( Integer | DecimalNumber ), ( "e" | "E" ), [ Sign ], IntegerDigits
	;

PrecisionNumber
	= DecimalNumber, "p", [ IntegerDigits ]
	;

(* Infinity and -Infinity are permitted; +Infinity is not (§5.4).
	Compiles to XSD INF and -INF respectively. *)
Infinity
	= [ "-" ], "Infinity"
	;

Fraction
	= Integer, "/", IntegerDigits
	;

ImaginaryNumber
	= ( Integer | DecimalNumber ), "i"
	;

ComplexNumber
	= ( Integer | DecimalNumber ), ( "+" | "-" ), ( Integer | DecimalNumber ), "i"
	;

DigitSequence
	= Digit, { Digit }
	;

NonZeroDigit
	= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	;

IntegerDigits
	= "0" | NonZeroDigit, { Digit }
	;
</code></pre>

<hr />

<h4 id="a113-enumerated-tokens">A.1.13 Enumerated Tokens</h4>

<pre><code class="language-ebnf">EnumeratedToken
	= "$", UppercaseLetter, { Letter | Digit }, [ TypeParameters ]
	;

TypeParameters
	= "&lt;", TypeArgument, { ",", TypeArgument }, "&gt;"
	;

TypeArgument
	= EnumeratedToken
	| TypeUnion
	;

TypeUnion
	= "[", EnumeratedToken, { ",", EnumeratedToken }, "]"
	;
</code></pre>

<hr />

<h4 id="a114-temporal-values">A.1.14 Temporal Values</h4>

<pre><code class="language-ebnf">TemporalValue
	= "{", TemporalBody, "}"
	;

(* Temporal kind is determined by the first matching alternative
   in the order listed below (§5.6.1). *)
TemporalBody
	= ZonedDateTime
	| LocalDateTime
	| Date
	| YearMonth
	| MonthDay
	| Time
	| Duration
	| TemporalKeyword
	;

Date
	= Year, "-", Month, "-", Day
	;

YearMonth
	= Year, "-", Month
	;

MonthDay
	= Month, "-", Day
	;

LocalDateTime
	= Date, "T", Time
	;

ZonedDateTime
	= LocalDateTime, TimeZoneOffset, [ TimeZoneId ]
	;

TimeZoneOffset
	= "Z" | ( ( "+" | "-" ), Hour, ":", Minute )
	;

TimeZoneId
	= "[", TimeZoneIdChar, { TimeZoneIdChar }, "]"
	;

TimeZoneIdChar
	= Letter | Digit | "/" | "_" | "-"
	;

Time
	= Hour, ":", Minute, [ ":", Second, [ ".", FractionalSeconds ] ]
	;

Duration
	= "P", DurationComponent, { DurationComponent }, [ "T", { TimeDurationComponent } ]
	| "P", "T", TimeDurationComponent, { TimeDurationComponent }
	;

DurationComponent
	= DigitSequence, ( "Y" | "M" | "W" | "D" )
	;

TimeDurationComponent
	= DigitSequence, [ ".", DigitSequence ], ( "H" | "M" | "S" )
	;

TemporalKeyword
	= "now" | "today"
	;

Year
	= Digit, Digit, Digit, Digit
	;

Month
	= Digit, Digit
	;

Day
	= Digit, Digit
	;

Hour
	= Digit, Digit
	;

Minute
	= Digit, Digit
	;

Second
	= Digit, Digit
	;

FractionalSeconds
	= Digit, { Digit }
	;
</code></pre>

<hr />

<h4 id="a115-color-values">A.1.15 Color Values</h4>

<pre><code class="language-ebnf">(* Color values are accepted as declarative spellings; tools MUST NOT normalize,
	convert, or interpret them (§5.7). Hex digits, function names, and color space
	tokens are case-insensitive for parsing; lowercase is canonical. *)

ColorValue
	= HexColor
	| FunctionColor
	| NamedColor
	;

HexColor
	= "#", HexDigit, HexDigit, HexDigit, [ HexDigit ]
	| "#", HexDigit, HexDigit, HexDigit, HexDigit, HexDigit, HexDigit, [ HexDigit, HexDigit ]
	;

(* §5.7.1, Appendix B: Name MUST be a named color keyword; unrecognized names are a SchemaError (§14). *)
NamedColor
	= "&amp;", LowercaseLetter, { LowercaseLetter }
	;

FunctionColor
	= RgbFunc
	| HslFunc
	| HwbFunc
	| LabFunc
	| LchFunc
	| OklabFunc
	| OklchFunc
	| ColorFunc
	| ColorMixFunc
	| RelativeColorFunc
	| DeviceCmykFunc
	;

RgbFunc
	= ( "rgb" | "rgba" ), "(", ColorFuncPayload, ")"
	;

HslFunc
	= ( "hsl" | "hsla" ), "(", ColorFuncPayload, ")"
	;

HwbFunc
	= "hwb", "(", ColorFuncPayload, ")"
	;

LabFunc
	= "lab", "(", ColorFuncPayload, ")"
	;

LchFunc
	= "lch", "(", ColorFuncPayload, ")"
	;

OklabFunc
	= "oklab", "(", ColorFuncPayload, ")"
	;

OklchFunc
	= "oklch", "(", ColorFuncPayload, ")"
	;

ColorFunc
	= "color", "(", ColorSpace, WhitespaceNoNewline, ColorFuncPayload, ")"
	;

ColorMixFunc
	= "color-mix", "(", ColorFuncPayload, ")"
	;

RelativeColorFunc
	= ( "rgb" | "rgba" | "hsl" | "hsla" | "hwb" | "lab" | "lch" | "oklab" | "oklch" | "color" ),
	  "(", "from", WhitespaceNoNewline, ColorValue, ColorFuncTail, ")"
	;

DeviceCmykFunc
	= "device-cmyk", "(", ColorFuncPayload, ")"
	;

ColorSpace
	= "srgb"
	| "srgb-linear"
	| "display-p3"
	| "a98-rgb"
	| "prophoto-rgb"
	| "rec2020"
	| "xyz"
	| "xyz-d50"
	| "xyz-d65"
	;

(* The payload is an uninterpreted balanced-parentheses token sequence (§A.1.27). *)
ColorFuncPayload
	= { ColorPayloadToken }
	;

ColorFuncTail
	= { ColorPayloadToken }
	;

ColorPayloadToken
	= "(", ColorFuncPayload, ")"
	| ColorPayloadChar
	;

ColorPayloadChar
	= AnyCharExceptParensNewline
	;
</code></pre>

<hr />

<h4 id="a116-uuid-values">A.1.16 UUID Values</h4>

<pre><code class="language-ebnf">(* UUID format: 8-4-4-4-12 hex digits (§5.8).
	Hex digits are case-insensitive for parsing; lowercase is canonical. *)
UuidValue
	= HexOctet, HexOctet, HexOctet, HexOctet, "-",
	  HexOctet, HexOctet, "-",
	  HexOctet, HexOctet, "-",
	  HexOctet, HexOctet, "-",
	  HexOctet, HexOctet, HexOctet, HexOctet, HexOctet, HexOctet
	;

HexOctet
	= HexDigit, HexDigit
	;
</code></pre>

<hr />

<h4 id="a117-iri-reference-values">A.1.17 IRI Reference Values</h4>

<pre><code class="language-ebnf">(* IRI references are unquoted tokens containing a ':' (§5.9).
	They terminate at Value termination (§A.1.27). *)

IriReference
	= IriScheme, ":", IriTokenBody
	;

IriScheme
	= Letter, { Letter | Digit | "+" | "-" | "." }
	;

IriTokenBody
	= { IriTokenChar }
	;

(* Token-level placeholder: the exact admissible character set is RFC 3987
	profiled by §5.9. Surface-form validation (§8) enforces disallowed Unicode
	categories; the grammar enforces only token termination exclusions. *)
IriTokenChar
	= AnyCharExceptValueTerminator
	;
</code></pre>

<hr />

<h4 id="a118-lookup-token-values">A.1.18 Lookup Token Values</h4>

<pre><code class="language-ebnf">(* Lookup tokens reference document-scoped keys (§5.10). *)
LookupToken
	= "~", LowercaseLetter, { Letter | Digit }
	;
</code></pre>

<hr />

<h4 id="a119-list-values">A.1.19 List Values</h4>

<pre><code class="language-ebnf">(* List Values are ordered sequences of zero or more elements (§5.12). *)
ListValue
	= "[", { Whitespace }, [ ListItems ], { Whitespace }, "]"
	;

ListItems
	= Value, { { Whitespace }, ",", { Whitespace }, Value }
	;
</code></pre>

<hr />

<h4 id="a120-set-values">A.1.20 Set Values</h4>

<pre><code class="language-ebnf">(* Set Values are unordered collections; duplicate elements are a ParseError (§5.14, §14). *)
SetValue
	= "set", "[", { Whitespace }, [ SetItems ], { Whitespace }, "]"
	;

SetItems
	= Value, { { Whitespace }, ",", { Whitespace }, Value }
	;
</code></pre>

<hr />

<h4 id="a121-map-values">A.1.21 Map Values</h4>

<pre><code class="language-ebnf">(* Map Values are key-value collections; duplicate keys are a ParseError (§5.15, §14). *)
MapValue
	= "map", "[", { Whitespace }, [ MapItems ], { Whitespace }, "]"
	;

MapItems
	= MapEntry, { { Whitespace }, ",", { Whitespace }, MapEntry }
	;

MapEntry
	= MapKey, { Whitespace }, ":", { Whitespace }, Value
	;

MapKey
	= MapIdentifier
	| StringValue
	| CharValue
	| Integer
	| EnumeratedToken
	;

MapIdentifier
	= LowercaseLetter, { Letter | Digit }
	;
</code></pre>

<hr />

<h4 id="a122-tuple-values">A.1.22 Tuple Values</h4>

<pre><code class="language-ebnf">(* Tuple Values require at least one element (§5.16). *)
TupleValue
	= "(", { Whitespace }, TupleItems, { Whitespace }, ")"
	;

TupleItems
	= Value, { { Whitespace }, ",", { Whitespace }, Value }
	;
</code></pre>

<hr />

<h4 id="a123-range-values">A.1.23 Range Values</h4>

<pre><code class="language-ebnf">(* Range Values are declarative intervals with optional step (§5.17). *)
RangeValue
	= RangeStart, "..", RangeEnd, [ "s", StepValue ]
	;

RangeStart
	= NumericValue | TemporalValue | CharValue
	;

RangeEnd
	= NumericValue | TemporalValue | CharValue
	;

StepValue
	= NumericValue | TemporalValue
	;
</code></pre>

<hr />

<h4 id="a124-annotations">A.1.24 Annotations</h4>

<pre><code class="language-ebnf">(* Codex defines two surface forms for annotations (§8.9):
	- Inline: '[' ... ']' on a single line
	- Block: '[' on its own line, then content lines, then ']' on its own line
	The attachment/grouping/general-kind rules are surface-form validation rules (§8.9). *)

Annotation
	= AnnotationLine | AnnotationBlock
	;

AnnotationLine
	= Indentation, "[", { AnnotationChar }, "]", Newline
	;

AnnotationBlock
	= Indentation, "[", Newline,
	  { AnnotationBlockLine },
	  Indentation, "]", Newline
	;

AnnotationBlockLine
	= Indentation, { AnnotationBlockChar }, Newline
	;

AnnotationChar
	= UnescapedAnnotationChar | AnnotationEscape
	;

UnescapedAnnotationChar
	= AnyCharExceptRightBracketNewline
	;

AnnotationEscape
	= "\\", "]"
	;

(* Inside block annotations, the only escape defined is the same as inline: '\]'. *)
AnnotationBlockChar
	= UnescapedAnnotationBlockChar | AnnotationEscape
	;

UnescapedAnnotationBlockChar
	= AnyCharExceptNewline
	;
</code></pre>

<hr />

<h4 id="a125-whitespace-and-structural-elements">A.1.25 Whitespace and Structural Elements</h4>

<pre><code class="language-ebnf">(* Indentation uses tabs only; spaces in indentation are errors (§8.3). *)
Whitespace
	= WhitespaceChar, { WhitespaceChar }
	;

WhitespaceNoNewline
	= WhitespaceNoNewlineChar, { WhitespaceNoNewlineChar }
	;

WhitespaceChar
	= " " | "\t" | Newline
	;

WhitespaceNoNewlineChar
	= " " | "\t"
	;

Newline
	= "\n"
	;

(* A blank line contains only a newline; no spaces or tabs are permitted. *)
BlankLine
	= Newline
	;

Indentation
	= { "\t" }
	;
</code></pre>

<hr />

<h4 id="a126-character-classes-informative">A.1.26 Character Classes (Informative)</h4>

<p>The following character classes are used but not fully enumerated:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AnyCharExceptNewline</code> — any Unicode scalar except U+000A</li>
  <li><code class="language-plaintext highlighter-rouge">AnyCharExceptQuoteBackslashNewline</code> — any Unicode scalar except <code class="language-plaintext highlighter-rouge">"</code>, <code class="language-plaintext highlighter-rouge">\\</code>, U+000A</li>
  <li><code class="language-plaintext highlighter-rouge">AnyCharExceptApostropheBackslashNewline</code> — any Unicode scalar except <code class="language-plaintext highlighter-rouge">'</code>, <code class="language-plaintext highlighter-rouge">\\</code>, U+000A</li>
  <li><code class="language-plaintext highlighter-rouge">AnyCharExceptBacktick</code> — any Unicode scalar except <code class="language-plaintext highlighter-rouge">`</code></li>
  <li><code class="language-plaintext highlighter-rouge">AnyCharExceptRightParenNewline</code> — any Unicode scalar except <code class="language-plaintext highlighter-rouge">)</code>, U+000A</li>
  <li><code class="language-plaintext highlighter-rouge">AnyCharExceptParensNewline</code> — any Unicode scalar except <code class="language-plaintext highlighter-rouge">(</code>, <code class="language-plaintext highlighter-rouge">)</code>, U+000A</li>
  <li><code class="language-plaintext highlighter-rouge">AnyCharExceptRightBracketNewline</code> — any Unicode scalar except <code class="language-plaintext highlighter-rouge">]</code>, U+000A</li>
  <li><code class="language-plaintext highlighter-rouge">AnyCharExceptBackslashNewline</code> — any Unicode scalar except <code class="language-plaintext highlighter-rouge">\\</code>, U+000A</li>
  <li><code class="language-plaintext highlighter-rouge">AnyCharExceptValueTerminator</code> — any Unicode scalar except a Value terminator (defined in §A.1.27)</li>
</ul>

<hr />

<h4 id="a127-value-termination-and-disambiguation">A.1.27 Value Termination and Disambiguation</h4>
<pre><code class="language-ebnf">(* Value termination is token-level, not type-level.

	In a Concept marker, an unquoted Value token MUST terminate at the first of:
	- whitespace (space, tab, or newline)
	- "&gt;" or "/&gt;" (end of marker)

	While scanning for termination, parsers MUST respect balanced delimiters for
	delimited value spellings and composite literals, including:
	[], {}, (), '', "", and backticks.

	This appendix provides type grammars for each Value form, but conformance requires
	the termination behavior above.

	Value disambiguation is performed by deterministic precedence, applied to the
	maximal token recognized under the termination rule.

	Precedence (highest first):

	1. Delimited: StringValue, CharValue, BacktickString
	2. BooleanValue ("true" | "false")
	3. EnumeratedToken ($...)
	4. LookupToken (~...)
	5. TemporalValue ({...})
	6. SetValue (set[...])
	7. MapValue (map[...])
	8. ListValue ([...])
	9. TupleValue ((...))
	10. ColorValue (all permitted color literal spellings, including functions and named colors)
	11. UuidValue (8-4-4-4-12 with hex digits)
	12. RangeValue (contains ".." with valid endpoints)
	13. NumericValue (Complex/Imaginary/Fraction/Infinity/Precision/Scientific/Decimal/Integer per §A.1.12)
	14. IriReference (fallback: token contains ":" and matches IriReference)

	If a token matches multiple forms at the same precedence level, parsing MUST fail
	with a ParseError (§14) rather than guess. *)
</code></pre>
<h3 id="a2-peg-informative">A.2 PEG (Informative)</h3>

<p>The PEG grammar is informative. It provides an implementation-ready, unambiguous grammar.</p>

<p>In case of discrepancy between EBNF and PEG, the EBNF grammar in §A.1 takes precedence.</p>

<h4 id="a21-notation">A.2.1 Notation</h4>

<p>This grammar uses standard PEG notation:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;-</code> defines a rule</li>
  <li><code class="language-plaintext highlighter-rouge">/</code> ordered choice (try left first)</li>
  <li><code class="language-plaintext highlighter-rouge">*</code> zero or more</li>
  <li><code class="language-plaintext highlighter-rouge">+</code> one or more</li>
  <li><code class="language-plaintext highlighter-rouge">?</code> optional (zero or one)</li>
  <li><code class="language-plaintext highlighter-rouge">&amp;</code> positive lookahead</li>
  <li><code class="language-plaintext highlighter-rouge">!</code> negative lookahead</li>
  <li><code class="language-plaintext highlighter-rouge">( ... )</code> grouping</li>
  <li><code class="language-plaintext highlighter-rouge">" ... "</code> literal string</li>
  <li><code class="language-plaintext highlighter-rouge">' ... '</code> literal string (alternative)</li>
  <li><code class="language-plaintext highlighter-rouge">[ ... ]</code> character class</li>
  <li><code class="language-plaintext highlighter-rouge">.</code> any character</li>
  <li><code class="language-plaintext highlighter-rouge">#</code> comment to end of line</li>
</ul>

<hr />

<h4 id="a22-document-structure">A.2.2 Document Structure</h4>

<pre><code class="language-peg"># A Codex document contains exactly one root Concept.
# Surface-form rules constrain root count, blank-line placement, and annotation kinds.

Document &lt;- LeadingAnnotationBlocks? RootConcept TrailingBlankLines EOF

LeadingAnnotationBlocks &lt;- (BlankLine* Annotation BlankLine*)*

TrailingBlankLines &lt;- BlankLine*

RootConcept &lt;- ConceptAtColumn0

ConceptAtColumn0 &lt;- BOL BlockConcept
                 / BOL SelfClosingConcept Newline

BOL &lt;- &amp;(StartOfFile / Newline)
StartOfFile &lt;- !.

Concept &lt;- BlockConcept / SelfClosingConcept
</code></pre>

<hr />

<h4 id="a23-block-concepts">A.2.3 Block Concepts</h4>

<pre><code class="language-peg"># Block concepts contain either children or content.
# The parser consults the governing schema (ContentRules) to decide which Body to parse.
# This is schema-directed dispatch, not syntactic ambiguity.

BlockConcept &lt;- OpeningMarkerLine Body ClosingMarkerLine

OpeningMarkerLine &lt;- Indentation OpeningMarker Newline
ClosingMarkerLine &lt;- Indentation ClosingMarker Newline

OpeningMarker &lt;- '&lt;' ConceptName Traits? '&gt;'
ClosingMarker &lt;- '&lt;/' ConceptName '&gt;'

# Body is selected by schema lookup on ConceptName (§11):
# - children mode: ChildrenBody
# - content mode: ContentBody
Body &lt;- ChildrenBody / ContentBody

# ChildrenBody admits BlankLine and Annotation; their legality and attachment kinds
# are checked by surface-form rules and canonicalization rules.
ChildrenBody &lt;- ChildItem*

ChildItem &lt;- BlankLine / AnnotationLine / AnnotationBlock / ConceptLine

ConceptLine &lt;- Indentation (SelfClosingMarker / Concept) Newline

ContentBody &lt;- ContentLine*

ContentLine &lt;- Indentation ContentText Newline

ContentText &lt;- ContentChar*
ContentChar &lt;- ContentEscape / ContentSafeChar
ContentEscape &lt;- '\\' ('&lt;' / '[')
ContentSafeChar &lt;- !Newline !'&lt;' .
</code></pre>

<hr />

<h4 id="a24-self-closing-concepts">A.2.4 Self-Closing Concepts</h4>

<pre><code class="language-peg">SelfClosingConcept &lt;- SelfClosingMarker

SelfClosingMarker &lt;- '&lt;' ConceptName Traits? '/&gt;'
</code></pre>

<hr />

<h4 id="a25-concept-names">A.2.5 Concept Names</h4>

<pre><code class="language-peg">ConceptName &lt;- UppercaseLetter (Letter / Digit)*
UppercaseLetter &lt;- [A-Z]
LowercaseLetter &lt;- [a-z]
Letter &lt;- [A-Za-z]
Digit &lt;- [0-9]
</code></pre>

<hr />

<h4 id="a26-traits">A.2.6 Traits</h4>

<pre><code class="language-peg"># Traits are whitespace-separated tokens in the opening marker.
# Newline is permitted in Whitespace, enabling multi-line trait layout;
# formatting rules define canonical layout.

Traits &lt;- (WhitespaceNoNewline Trait (Whitespace Trait)*) / (Whitespace Trait (Whitespace Trait)*)

Trait &lt;- TraitName '=' Value

TraitName &lt;- LowercaseLetter (Letter / Digit)*
</code></pre>

<hr />

<h4 id="a27-values">A.2.7 Values</h4>

<pre><code class="language-peg"># Values are tried in deterministic precedence order.
# Token termination in markers is governed by the surface rules (see A.1.27);
# this PEG uses explicit constructs for balanced literals.

Value &lt;- StringValue
      / CharValue
      / BacktickString
      / BooleanValue
      / EnumeratedToken
      / LookupToken
      / TemporalValue
      / SetValue
      / MapValue
      / ListValue
      / TupleValue
      / ColorValue
      / UuidValue
      / RangeValue
      / NumericValue
      / IriReference
</code></pre>

<hr />

<h4 id="a28-string-values">A.2.8 String Values</h4>

<pre><code class="language-peg">StringValue &lt;- '"' StringChar* '"'
StringChar &lt;- EscapeSequence / (!["\\\n] .)
EscapeSequence &lt;- '\\' ( ["\\nrt] / UnicodeEscape )
UnicodeEscape &lt;- 'u' HexDigit HexDigit HexDigit HexDigit
             / 'u{' HexDigit+ '}'
HexDigit &lt;- [0-9A-Fa-f]
</code></pre>

<hr />

<h4 id="a29-character-values">A.2.9 Character Values</h4>

<pre><code class="language-peg">CharValue &lt;- "'" CharContent "'"
CharContent &lt;- CharEscapeSequence / (!['\\\n] .)
CharEscapeSequence &lt;- '\\' ( ["'\\nrt] / UnicodeEscape )
</code></pre>

<hr />

<h4 id="a210-backtick-strings">A.2.10 Backtick Strings</h4>

<pre><code class="language-peg">BacktickString &lt;- '`' BacktickChar* '`'
BacktickChar &lt;- BacktickEscape / (!'`' .)
BacktickEscape &lt;- '\\' '`'
</code></pre>

<hr />

<h4 id="a211-boolean-values">A.2.11 Boolean Values</h4>

<pre><code class="language-peg">BooleanValue &lt;- 'true' / 'false'
</code></pre>

<hr />

<h4 id="a212-numeric-values">A.2.12 Numeric Values</h4>

<pre><code class="language-peg">NumericValue &lt;- ComplexNumber
             / ImaginaryNumber
             / Fraction
             / Infinity
             / PrecisionNumber
             / ScientificNumber
             / DecimalNumber
             / Integer

ComplexNumber &lt;- (Integer / DecimalNumber) ([+-]) (Integer / DecimalNumber) 'i'
ImaginaryNumber &lt;- (Integer / DecimalNumber) 'i'
Fraction &lt;- Integer '/' IntDigits
Infinity &lt;- '-'? 'Infinity'
PrecisionNumber &lt;- DecimalNumber 'p' IntDigits?
ScientificNumber &lt;- (Integer / DecimalNumber) [eE] Sign? IntDigits
DecimalNumber &lt;- Sign? IntDigits '.' Digits
Integer &lt;- Sign? IntDigits

Sign &lt;- [+-]
Digits &lt;- Digit+
IntDigits &lt;- '0' / [1-9] Digit*
</code></pre>

<hr />

<h4 id="a213-enumerated-tokens">A.2.13 Enumerated Tokens</h4>

<pre><code class="language-peg">EnumeratedToken &lt;- '$' UppercaseLetter (Letter / Digit)* TypeParameters?

TypeParameters &lt;- '&lt;' TypeArgument (',' TypeArgument)* '&gt;'

TypeArgument &lt;- EnumeratedToken / TypeUnion

TypeUnion &lt;- '[' EnumeratedToken (',' EnumeratedToken)* ']'
</code></pre>

<hr />

<h4 id="a214-lookup-tokens">A.2.14 Lookup Tokens</h4>

<pre><code class="language-peg">LookupToken &lt;- '~' LowercaseLetter (Letter / Digit)*
</code></pre>

<hr />

<h4 id="a215-temporal-values">A.2.15 Temporal Values</h4>

<pre><code class="language-peg">TemporalValue &lt;- '{' TemporalBody '}'

TemporalBody &lt;- ZonedDateTime / LocalDateTime / Date / YearMonth / MonthDay / Time / Duration / TemporalKeyword

Date &lt;- Year '-' Month '-' Day
YearMonth &lt;- Year '-' Month
MonthDay &lt;- Month '-' Day

LocalDateTime &lt;- Date 'T' Time
ZonedDateTime &lt;- LocalDateTime TimeZoneOffset TimeZoneId?

TimeZoneOffset &lt;- 'Z' / ([+-] Hour ':' Minute)
TimeZoneId &lt;- '[' TimeZoneIdChar+ ']'
TimeZoneIdChar &lt;- Letter / Digit / '/' / '_' / '-'

Time &lt;- Hour ':' Minute (':' Second ('.' FractionalSeconds)?)?

Duration &lt;- 'P' DurationComponent+ ('T' TimeDurationComponent*)?
          / 'P' 'T' TimeDurationComponent+
DurationComponent &lt;- Digits [YMWD]
TimeDurationComponent &lt;- Digits ('.' Digits)? [HMS]

TemporalKeyword &lt;- 'now' / 'today'

Year &lt;- Digit Digit Digit Digit
Month &lt;- Digit Digit
Day &lt;- Digit Digit
Hour &lt;- Digit Digit
Minute &lt;- Digit Digit
Second &lt;- Digit Digit
FractionalSeconds &lt;- Digit+
</code></pre>

<hr />

<h4 id="a216-list-values">A.2.16 List Values</h4>

<pre><code class="language-peg"># Lists permit arbitrary whitespace (including newlines) between tokens.

ListValue &lt;- '[' WS* ListItems? WS* ']'
ListItems &lt;- Value (WS* ',' WS* Value)*
</code></pre>

<hr />

<h4 id="a217-set-values">A.2.17 Set Values</h4>

<pre><code class="language-peg">SetValue &lt;- 'set' '[' WS* SetItems? WS* ']'
SetItems &lt;- Value (WS* ',' WS* Value)*
</code></pre>

<hr />

<h4 id="a218-map-values">A.2.18 Map Values</h4>

<pre><code class="language-peg">MapValue &lt;- 'map' '[' WS* MapItems? WS* ']'
MapItems &lt;- MapEntry (WS* ',' WS* MapEntry)*
MapEntry &lt;- MapKey WS* ':' WS* Value
MapKey &lt;- MapIdentifier / StringValue / CharValue / Integer / EnumeratedToken
MapIdentifier &lt;- LowercaseLetter (Letter / Digit)*
</code></pre>

<hr />

<h4 id="a219-tuple-values">A.2.19 Tuple Values</h4>

<pre><code class="language-peg">TupleValue &lt;- '(' WS* TupleItems WS* ')'
TupleItems &lt;- Value (WS* ',' WS* Value)*
</code></pre>

<hr />

<h4 id="a220-range-values">A.2.20 Range Values</h4>

<pre><code class="language-peg">RangeValue &lt;- RangeStart '..' RangeEnd ('s' StepValue)?
RangeStart &lt;- TemporalValue / CharValue / NumericValue
RangeEnd &lt;- TemporalValue / CharValue / NumericValue
StepValue &lt;- TemporalValue / NumericValue
</code></pre>

<hr />

<h4 id="a221-uuid-values">A.2.21 UUID Values</h4>

<pre><code class="language-peg">UuidValue &lt;- HexOctet HexOctet HexOctet HexOctet '-' HexOctet HexOctet '-' HexOctet HexOctet '-' HexOctet HexOctet '-' HexOctet HexOctet HexOctet HexOctet HexOctet HexOctet
HexOctet &lt;- HexDigit HexDigit
</code></pre>

<hr />

<h4 id="a222-color-values">A.2.22 Color Values</h4>

<pre><code class="language-peg"># Color spellings are accepted as declarative literals; no semantic evaluation occurs.
# For function spellings, we accept any balanced-parentheses payload up to ')'.

ColorValue &lt;- HexColor / NamedColor / ColorFunction

HexColor &lt;- '#' (HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit
              / HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit
              / HexDigit HexDigit HexDigit HexDigit
              / HexDigit HexDigit HexDigit)

NamedColor &lt;- '&amp;' [a-z]+

ColorFunction &lt;- ColorFuncName '(' ColorPayload ')'
ColorFuncName &lt;- 'rgb' / 'rgba' / 'hsl' / 'hsla' / 'hwb' / 'lab' / 'lch' / 'oklab' / 'oklch' / 'color'
              / 'color-mix' / 'device-cmyk'

# Payload with balanced parentheses support.
ColorPayload &lt;- ColorPayloadToken*
ColorPayloadToken &lt;- '(' ColorPayload ')' / (![()\n] .)
</code></pre>

<hr />

<h4 id="a223-iri-references">A.2.23 IRI References</h4>

<pre><code class="language-peg"># IRI references are fallback unquoted values that contain ':'.
# Exact RFC 3987 profiling is enforced by surface-form validation, not this PEG.

IriReference &lt;- IriScheme ':' IriBody
IriScheme &lt;- Letter (Letter / Digit / [+\-\.])*
IriBody &lt;- IriTokenChar*
IriTokenChar &lt;- !ValueTerminator .
</code></pre>

<hr />

<h4 id="a224-annotations">A.2.24 Annotations</h4>

<pre><code class="language-peg">Annotation &lt;- AnnotationLine / AnnotationBlock

AnnotationLine &lt;- Indentation '[' AnnotationChar* ']' Newline

AnnotationBlock &lt;- Indentation '[' Newline AnnotationBlockLine* Indentation ']' Newline

AnnotationBlockLine &lt;- Indentation AnnotationBlockChar* Newline

AnnotationChar &lt;- AnnotationEscape / (!(']' / '\n') .)
AnnotationEscape &lt;- '\\' ']'

AnnotationBlockChar &lt;- AnnotationEscape / (!'\n' .)
</code></pre>

<hr />

<h4 id="a225-whitespace-and-structural-elements">A.2.25 Whitespace and Structural Elements</h4>

<pre><code class="language-peg">Newline &lt;- '\n'

WhitespaceChar &lt;- [ \t\n]
Whitespace &lt;- WhitespaceChar+

WhitespaceNoNewline &lt;- [ \t]+

WS &lt;- [ \t\n]

BlankLine &lt;- Newline

Indentation &lt;- '\t'*

# Conservative terminators for unquoted tokens in markers:
ValueTerminator &lt;- [ \t\n] / '&gt;' / '/'
</code></pre>

<hr />

<h4 id="a226-end-of-file">A.2.26 End of File</h4>

<pre><code class="language-peg">EOF &lt;- !.
</code></pre>

<hr />

<h2 id="appendix-b-codex-named-colors">Appendix B. Codex Named Colors</h2>
<p>This appendix defines the exhaustive set of named color keywords permitted in Codex Named Color Values (§5.7). A color name is valid if and only if it appears in this appendix.</p>

<p>Aliases and duplicates (for example, <code class="language-plaintext highlighter-rouge">gray</code>/<code class="language-plaintext highlighter-rouge">grey</code>, <code class="language-plaintext highlighter-rouge">cyan</code>/<code class="language-plaintext highlighter-rouge">aqua</code>) are intentional and are part of the Codex named color set.</p>

<h3 id="b1-named-color-keyword-table">B.1 Named Color Keyword Table</h3>

<p>Each entry defines a valid Codex Named Color Value (<code class="language-plaintext highlighter-rouge">&amp;name</code>). The sRGB hex column is informative and does not define Codex color semantics.</p>

<table>
  <thead>
    <tr>
      <th>Named color</th>
      <th style="text-align: right">sRGB hex</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;aliceblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#f0f8ff</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;antiquewhite</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#faebd7</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;aqua</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#00ffff</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;aquamarine</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#7fffd4</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;azure</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#f0ffff</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;beige</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#f5f5dc</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;bisque</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffe4c4</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;black</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#000000</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;blanchedalmond</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffebcd</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;blue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#0000ff</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;blueviolet</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#8a2be2</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;brown</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#a52a2a</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;burlywood</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#deb887</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;cadetblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#5f9ea0</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;chartreuse</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#7fff00</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;chocolate</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#d2691e</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;coral</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ff7f50</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;cornflowerblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#6495ed</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;cornsilk</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#fff8dc</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;crimson</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#dc143c</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;cyan</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#00ffff</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#00008b</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkcyan</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#008b8b</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkgoldenrod</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#b8860b</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkgray</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#a9a9a9</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkgrey</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#a9a9a9</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkgreen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#006400</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkkhaki</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#bdb76b</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkmagenta</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#8b008b</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkolivegreen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#556b2f</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkorange</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ff8c00</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkorchid</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#9932cc</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkred</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#8b0000</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darksalmon</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#e9967a</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkseagreen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#8fbc8f</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkslateblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#483d8b</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkslategray</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#2f4f4f</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkslategrey</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#2f4f4f</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkturquoise</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#00ced1</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;darkviolet</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#9400d3</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;deeppink</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ff1493</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;deepskyblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#00bfff</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;dimgray</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#696969</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;dimgrey</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#696969</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;dodgerblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#1e90ff</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;firebrick</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#b22222</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;floralwhite</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#fffaf0</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;forestgreen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#228b22</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;fuchsia</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ff00ff</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;gainsboro</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#dcdcdc</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;ghostwhite</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#f8f8ff</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;gold</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffd700</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;goldenrod</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#daa520</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;gray</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#808080</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;grey</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#808080</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;green</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#008000</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;greenyellow</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#adff2f</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;honeydew</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#f0fff0</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;hotpink</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ff69b4</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;indianred</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#cd5c5c</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;indigo</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#4b0082</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;ivory</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#fffff0</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;khaki</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#f0e68c</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lavender</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#e6e6fa</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lavenderblush</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#fff0f5</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lawngreen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#7cfc00</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lemonchiffon</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#fffacd</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#add8e6</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightcoral</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#f08080</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightcyan</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#e0ffff</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightgoldenrodyellow</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#fafad2</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightgray</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#d3d3d3</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightgrey</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#d3d3d3</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightgreen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#90ee90</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightpink</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffb6c1</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightsalmon</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffa07a</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightseagreen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#20b2aa</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightskyblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#87cefa</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightslategray</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#778899</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightslategrey</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#778899</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightsteelblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#b0c4de</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lightyellow</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffffe0</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;lime</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#00ff00</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;limegreen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#32cd32</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;linen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#faf0e6</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;magenta</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ff00ff</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;maroon</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#800000</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;mediumaquamarine</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#66cdaa</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;mediumblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#0000cd</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;mediumorchid</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ba55d3</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;mediumpurple</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#9370db</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;mediumseagreen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#3cb371</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;mediumslateblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#7b68ee</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;mediumspringgreen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#00fa9a</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;mediumturquoise</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#48d1cc</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;mediumvioletred</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#c71585</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;midnightblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#191970</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;mintcream</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#f5fffa</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;mistyrose</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffe4e1</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;moccasin</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffe4b5</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;navajowhite</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffdead</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;navy</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#000080</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;oldlace</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#fdf5e6</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;olive</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#808000</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;olivedrab</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#6b8e23</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;orange</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffa500</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;orangered</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ff4500</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;orchid</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#da70d6</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;palegoldenrod</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#eee8aa</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;palegreen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#98fb98</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;paleturquoise</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#afeeee</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;palevioletred</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#db7093</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;papayawhip</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffefd5</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;peachpuff</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffdab9</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;peru</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#cd853f</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;pink</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffc0cb</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;plum</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#dda0dd</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;powderblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#b0e0e6</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;purple</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#800080</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;rebeccapurple</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#663399</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;red</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ff0000</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;rosybrown</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#bc8f8f</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;royalblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#4169e1</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;saddlebrown</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#8b4513</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;salmon</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#fa8072</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;sandybrown</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#f4a460</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;seagreen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#2e8b57</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;seashell</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#fff5ee</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;sienna</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#a0522d</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;silver</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#c0c0c0</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;skyblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#87ceeb</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;slateblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#6a5acd</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;slategray</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#708090</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;slategrey</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#708090</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;snow</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#fffafa</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;springgreen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#00ff7f</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;steelblue</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#4682b4</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;tan</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#d2b48c</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;teal</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#008080</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;thistle</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#d8bfd8</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;tomato</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ff6347</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;turquoise</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#40e0d0</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;violet</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ee82ee</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;wheat</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#f5deb3</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;white</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffffff</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;whitesmoke</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#f5f5f5</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;yellow</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#ffff00</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;yellowgreen</code></td>
      <td style="text-align: right"><code class="language-plaintext highlighter-rouge">#9acd32</code></td>
    </tr>
  </tbody>
</table>

<h3 id="b2-context-dependent-keywords">B.2 Context-Dependent Keywords</h3>

<p>The following keywords are valid Codex named colors but do not have a single fixed sRGB value in all contexts. Codex does not define any fixed expansion or interpretation for them.</p>

<table>
  <thead>
    <tr>
      <th>Named color</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;transparent</code></td>
      <td>Context-dependent; informative reference sRGB form: <code class="language-plaintext highlighter-rouge">#00000000</code>.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">&amp;currentcolor</code></td>
      <td>Context-dependent.</td>
    </tr>
  </tbody>
</table>

<hr />

<p><strong>End of Codex Language Specification v1.0.0</strong></p>


	<!-- Your Prism JS -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
	<script src="/assets/js/prism-cdx.js"></script>
</body>

</html>