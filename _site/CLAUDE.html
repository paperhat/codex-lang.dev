<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>My Codex Site</title>

	<!-- Your Prism CSS -->
	<link rel="stylesheet"
		href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
	<link rel="stylesheet" href="/assets/css/style.css" media="all">

	<!-- Optional: Add basic styling if removing theme -->
	<style>
		body {
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
		}

		pre {
			background: #f6f8fa;
			padding: 16px;
			border-radius: 6px;
			overflow: auto;
		}

		code {
			font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
		}
	</style>
</head>

<body>
	<h1 id="codex-language--ai-reference">Codex Language — AI Reference</h1>

<h2 id="critical-no-conventions-without-approval">Critical: No Conventions Without Approval</h2>

<p>Codex eliminates ambiguity for byte-identical output across implementations. Standard spec conventions (RFC 2119, precedence clauses, optional features) introduce the ambiguity Codex rejects.</p>

<p><strong>Do not apply conventional patterns automatically.</strong> Ask before introducing any standard spec-writing convention.</p>

<h2 id="specification-principles">Specification Principles</h2>

<ul>
  <li><strong>No <code class="language-plaintext highlighter-rouge">may</code></strong>: Only <code class="language-plaintext highlighter-rouge">must</code>/<code class="language-plaintext highlighter-rouge">must not</code>. No optionality at any level.</li>
  <li><strong>No redundancy</strong>: Each requirement stated once. Use references.</li>
  <li><strong>No conflict clauses</strong>: Conflicts are defects to fix, not resolve via precedence.</li>
  <li><strong>Round-trippability</strong>: Applies to canonical form. Canonicalization normalizes first.</li>
  <li><strong>Ordering</strong>: No semantic meaning to Codex; preserved for round-trippability.</li>
  <li><strong>Content vs children</strong>: First non-indentation char <code class="language-plaintext highlighter-rouge">&lt;</code> or <code class="language-plaintext highlighter-rouge">[</code> = children mode; else content mode.</li>
  <li><strong>Bootstrap schema</strong>: Hardcoded, not loaded at runtime.</li>
</ul>

<h2 id="what-codex-is">What Codex Is</h2>

<p>Declarative semantic markup for the Paperhat Workshop system, backed by RDF/OWL2/SHACL/SPARQL. Primary use: ontologies and instance data in triple stores. Design goal: constrain LLM output via closed-world semantics and deterministic validation.</p>

<h2 id="core-primitives">Core Primitives</h2>

<ul>
  <li><strong>Concept</strong>: Named unit (PascalCase). Children XOR Content.</li>
  <li><strong>Trait</strong>: Name-value pair (camelCase). Schema-authorized.</li>
  <li><strong>Value</strong>: Literal datum. Parsed, never evaluated.</li>
  <li><strong>Content</strong>: Opaque text. Preserved without interpretation.</li>
  <li><strong>Entity</strong>: <code class="language-plaintext highlighter-rouge">$MustBeEntity</code> or <code class="language-plaintext highlighter-rouge">$MustNotBeEntity</code>. No default.</li>
</ul>

<h2 id="authoring-modes-and-canonical-representation">Authoring Modes and Canonical Representation</h2>

<ul>
  <li><strong>Canonical Representation</strong> (semantic authority): RDF 1.1 graph (optionally expressed as SHACL / SHACL-SPARQL).</li>
  <li><strong>Canonical Authoring Mode</strong>: the author writes the Canonical Representation directly via <code class="language-plaintext highlighter-rouge">RdfGraph</code>/<code class="language-plaintext highlighter-rouge">RdfTriple</code>.</li>
  <li><strong>Simplified Authoring Mode</strong>: the author writes Codex-native schema-definition concepts; this is an authoring surface only and expands deterministically and losslessly into the Canonical Representation.</li>
</ul>

<h2 id="key-invariants">Key Invariants</h2>

<ul>
  <li><strong>Closed-world</strong>: No inference from omission.</li>
  <li><strong>Deterministic</strong>: Same inputs → identical outputs.</li>
  <li><strong>Canonical</strong>: One surface form per valid document.</li>
  <li><strong>Schema-first</strong>: Well-formedness is schema-free; validity requires schema.</li>
</ul>

<h2 id="file-locations">File Locations</h2>

<table>
  <thead>
    <tr>
      <th>Path</th>
      <th>Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">spec/1.0.0/index.md</code></td>
      <td>Normative specification</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">spec/1.0.0/bootstrap-schema/schema.cdx</code></td>
      <td>Canonical Authoring Mode bootstrap (SHACL)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">spec/1.0.0/bootstrap-schema/expanded/schema.cdx</code></td>
      <td>Simplified Authoring Mode bootstrap (human-readable)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">conformance/1.0.0/</code></td>
      <td>Conformance test suite</td>
    </tr>
  </tbody>
</table>

<h2 id="specification-structure">Specification Structure</h2>

<p>§1-2: Front matter, invariants · §3: Core model · §4: Naming (PascalCase/camelCase) · §5: Value literals · §6: Identity · §7: Reference Traits · §8: Surface form · §9: Schema architecture, Canonical Representation, SHACL · §10: Canonicalization · §11: Schema definition · §12: Bootstrapping · §13: Versioning · §14: Errors · Appendix A: Grammars · Appendix B: Named colors</p>

<h2 id="established-decisions-18">Established Decisions (§1–§8)</h2>

<p>Do not regress:</p>

<ul>
  <li><strong>§1.3</strong>: Only must/must not. may undefined.</li>
  <li><strong>§4.1</strong>: Names: ASCII letters/digits, non-empty. PascalCase uppercase-first, camelCase lowercase-first.</li>
  <li><strong>§4.2</strong>: No 3+ consecutive uppercase (mechanically enforces acronym-as-word).</li>
  <li><strong>§4.3</strong>: Authors must treat acronyms as words (not fully mechanical).</li>
  <li><strong>§5.1</strong>: Empty strings permitted.</li>
  <li><strong>§5.4</strong>: No infinity/NaN. <code class="language-plaintext highlighter-rouge">-0</code> distinct from <code class="language-plaintext highlighter-rouge">0</code>. No leading zeros (sign excluded). Precision <code class="language-plaintext highlighter-rouge">p</code> on any numeric (inferred from decimal places; explicit overrides).</li>
  <li><strong>§5.5</strong>: Enumerated tokens: <code class="language-plaintext highlighter-rouge">$</code> + PascalCase.</li>
  <li><strong>§5.6</strong>: Two grammars: Temporal Value (braced literal) vs Temporal Body (content).</li>
  <li><strong>§5.7</strong>: Lowercase canonical: hex digits, function names, color space tokens. Named colors: <code class="language-plaintext highlighter-rouge">&amp;</code> + lowercase (Appendix B).</li>
  <li><strong>§5.8</strong>: UUID: lowercase hex canonical.</li>
  <li><strong>§5.10</strong>: Lookup tokens: <code class="language-plaintext highlighter-rouge">~</code> + camelCase.</li>
  <li><strong>§5.11</strong>: Character literal delimiter: single quote (<code class="language-plaintext highlighter-rouge">'</code>).</li>
  <li><strong>§5.13</strong>: Value equality over parsed values. Case-insensitive: hex/function names/color space tokens (Colors), hex (UUIDs).</li>
  <li><strong>§5.14–15</strong>: Set/Map duplicates are errors. Canonical order = source order.</li>
  <li><strong>§6.1</strong>: Two identity mechanisms: <code class="language-plaintext highlighter-rouge">id</code> (IRI, global scope) and <code class="language-plaintext highlighter-rouge">key</code> (Lookup Token, document scope).</li>
  <li><strong>§6.2</strong>: Entity must have exactly one <code class="language-plaintext highlighter-rouge">id</code>; non-Entity must not have <code class="language-plaintext highlighter-rouge">id</code>. Values unique within document.</li>
  <li><strong>§6.3</strong>: Concept has zero or one <code class="language-plaintext highlighter-rouge">key</code>. Resolution via §9.8 bindings.</li>
  <li><strong>§7.1</strong>: Exactly three reference traits: <code class="language-plaintext highlighter-rouge">reference</code>, <code class="language-plaintext highlighter-rouge">target</code>, <code class="language-plaintext highlighter-rouge">for</code>. Values: IRI or Lookup Token. must not imply dereferencing/loading/execution/transformation.</li>
  <li><strong>§7.2–4</strong>: Intent statements are non-normative guidance for schema authors.</li>
  <li><strong>§7.5</strong>: Singleton rule via <code class="language-plaintext highlighter-rouge">ReferenceConstraint(type=ReferenceSingleton)</code>.</li>
  <li><strong>§8.1–2</strong>: UTF-8 default (no BOM); UTF-16 requires BOM. LF canonical; CRLF normalized; bare CR error; trailing LF required.</li>
  <li><strong>§8.3</strong>: Tabs only (U+0009) for indentation. Spaces in indentation = error.</li>
  <li><strong>§8.5–6</strong>: Empty block <code class="language-plaintext highlighter-rouge">&lt;X&gt;&lt;/X&gt;</code> is error; use self-closing. No whitespace around <code class="language-plaintext highlighter-rouge">=</code>. 1–2 traits inline; 3+ multiline with <code class="language-plaintext highlighter-rouge">&gt;</code> or <code class="language-plaintext highlighter-rouge">/&gt;</code> on own line.</li>
  <li><strong>§8.8</strong>: Content is opaque. Escaping: <code class="language-plaintext highlighter-rouge">\&lt;</code> and <code class="language-plaintext highlighter-rouge">\[</code> (line-initial only). Indentation stripped (schema-free). <code class="language-plaintext highlighter-rouge">whitespaceMode</code>: <code class="language-plaintext highlighter-rouge">$Preformatted</code> (preserve) or <code class="language-plaintext highlighter-rouge">$Flow</code> (collapse, wrap 100 chars) — schema-directed.</li>
  <li><strong>§8.9</strong>: Three annotation kinds: attached, grouping, general. Block directives: <code class="language-plaintext highlighter-rouge">FLOW:</code>, <code class="language-plaintext highlighter-rouge">CODE:</code>, <code class="language-plaintext highlighter-rouge">MARKDOWN:</code>.</li>
  <li><strong>§10.5</strong>: Two-phase canonicalization: Phase 1 (schema-free) for encoding/indentation/layout; Phase 2 (schema-directed) for content whitespace mode.</li>
</ul>


	<!-- Your Prism JS -->
	<script
		src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
	<script src="/assets/js/prism-cdx.js"></script>
</body>

</html>