12	Codex Language Specification — Version 1.0.0	All normative requirements for Codex 1.0.0 MUST appear exactly once in this document.
50	Codex Language Specification — Version 1.0.0 > 1. Front Matter > 1.3 Normativity and Conformance	This document uses the capitalized keywords **MUST** and **MUST NOT** to indicate requirements.
52	Codex Language Specification — Version 1.0.0 > 1. Front Matter > 1.3 Normativity and Conformance	Any statement that uses **MUST** or **MUST NOT** is normative.
60	Codex Language Specification — Version 1.0.0 > 1. Front Matter > 1.3 Normativity and Conformance	All statements that do not use **MUST** or **MUST NOT** are informative.
72	Codex Language Specification — Version 1.0.0 > 1. Front Matter > 1.3 Normativity and Conformance > 1.3.1 Consistency Guarantee	If an implementer discovers an apparent conflict between any parts of this specification or between this specification and the bootstrap schemas, that conflict is a defect. Implementers MUST NOT guess which source prevails. Implementers MUST report the defect.
82	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.1 Declarative and Closed-World Model	A conforming implementation MUST treat something not explicitly declared as not present.
84	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.1 Declarative and Closed-World Model	An implementation MUST NOT infer meaning from omission, shape, or other non-specified cues.
86	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.1 Declarative and Closed-World Model	An implementation MUST NOT assume defaults unless explicitly defined by this specification or by the governing schema.
88	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.1 Declarative and Closed-World Model	Structural ordering carries no semantic meaning to Codex itself. Trait order in canonical form is alphabetical by Trait name (§10.4); implementations MUST NOT treat Trait order as semantically significant. For children and collection elements, schemas define whether ordering is semantically significant (§11.3). Implementations MUST preserve the ordering of children and collection elements both for round-trippability (see §2.6) and to support schema-defined ordering constraints.
92	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.2 Determinism and Explainability	Given the same inputs, all conforming implementations MUST produce identical results.
103	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.2 Determinism and Explainability	- Parsing MUST be deterministic.
104	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.2 Determinism and Explainability	- Well-formedness checking MUST be deterministic.
105	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.2 Determinism and Explainability	- Schema validation MUST be deterministic.
106	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.2 Determinism and Explainability	- Canonicalization MUST be deterministic.
108	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.2 Determinism and Explainability	An implementation MUST NOT exhibit non-deterministic or heuristic behavior.
110	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.2 Determinism and Explainability	For any well-formedness, schema validation, or canonicalization result, an implementation MUST be able to attribute the result to:
127	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.3 Separation of Responsibility	- Parsing MUST determine only the syntactic structure of the document.
128	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.3 Separation of Responsibility	- Formatting and canonicalization MUST be mechanical and MUST NOT perform schema validation.
129	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.3 Separation of Responsibility	- Semantic validation MUST evaluate schema rules (including content-mode interpretation, constraints, value types, identity, and references) and MUST NOT be performed implicitly during parsing.
135	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.4 Target Agnosticism	Codex constructs and Codex-conforming tool behavior MUST NOT assume or require any particular target format, runtime, storage backend, inference system, rendering model, or execution semantics.
146	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.5 Well-Formedness and Validity	* A conforming implementation MUST be able to parse and check well-formedness without a governing schema.
147	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.5 Well-Formedness and Validity	* A conforming implementation MUST NOT perform schema validation without an explicit governing schema.
153	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.5 Well-Formedness and Validity	The bootstrap schema-of-schemas provides a built-in governing schema only for schema documents (§12.3) and MUST NOT be used as a fallback governing schema for instance documents.
161	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.6 Round-Trippability	A conforming implementation MUST support round-tripping: a canonicalized Codex document, after transformation to RDF triples, storage, retrieval via SPARQL, and reconstruction, MUST produce a byte-identical canonicalized document.
163	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.6 Round-Trippability	This invariant ensures that Codex serves as a lossless serialization format for RDF data. Structural ordering, annotations, and all surface-form details MUST survive the round-trip. The round-trip guarantee is achieved through the triple store projection alone, with no sidecar artifacts required.
165	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.6 Round-Trippability	To guarantee round-trippability, a conforming implementation MUST provide the following capabilities:
173	Codex Language Specification — Version 1.0.0 > 2. Language Invariants > 2.6 Round-Trippability	These capabilities MUST compose such that: for any valid input, canonicalizing the reconstructed output produces a byte-identical result to canonicalizing the original input.
183	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.1 Concept	A Concept instance MUST have exactly one Concept name.
185	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.1 Concept	A Concept instance MUST declare zero or more Traits.
187	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.1 Concept	A Concept instance MUST be in exactly one of two body modes:
196	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.2 Trait	A Trait instance MUST be declared on exactly one containing Concept instance.
198	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.2 Trait	A Trait instance MUST NOT have independent identity.
200	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.2 Trait	A Concept instance MUST NOT declare two or more Traits with the same Trait name. A violation MUST be rejected with a `SurfaceFormError` (§14).
202	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.2 Trait	Trait meaning and permissibility MUST be defined by the governing schema, except for language-level traits whose meaning is defined by this specification (§6, §7).
208	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.3 Value	A Value instance MUST be expressed using one of the literal spellings defined by this specification.
210	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.3 Value	A Value instance MUST be treated as declarative and immutable.
212	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.3 Value	Codex-conforming tools MUST parse Value spellings mechanically and MUST NOT evaluate Values as expressions.
214	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.3 Value	The meaning of a Value beyond its literal form MUST be defined by the governing schema or consuming system.
220	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.4 Content	Content MUST NOT be treated as a Value.
222	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.4 Content	Content MUST NOT be typed, evaluated, or interpreted as Concepts, Traits, Values, or Annotations.
224	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.4 Content	Content MUST be preserved through Codex-conforming processing, subject only to the surface-form normalization and canonicalization rules defined by this specification.
232	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.5 Entity	The governing schema MUST declare exactly one `entityEligibility` value for each Concept. The valid values are:
234	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.5 Entity	- `$MustBeEntity`: each instance of that Concept MUST declare an `id` Trait.
235	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.5 Entity	- `$MustNotBeEntity`: each instance of that Concept MUST NOT declare an `id` Trait.
237	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.5 Entity	If the governing schema does not declare `entityEligibility` for a Concept, schema validation MUST fail with a `SchemaError` (§14).
239	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.5 Entity	Codex-conforming formatting and canonicalization MUST NOT synthesize identity by adding an `id` Trait or inventing an identifier value.
245	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.6 Marker	Markers MUST be one of:
251	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.6 Marker	Markers MUST delimit Concept structure and nesting.
253	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.6 Marker	Each closing marker MUST match the most recent unclosed opening marker. If a closing marker does not match, or if any opening marker remains unclosed at end of input, the document MUST be rejected with a `ParseError` (§14).
255	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.6 Marker	A self-closing marker MUST represent a Concept with no children and no Content.
261	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.7 Annotation	Annotations MUST NOT affect parsing, schema validation outcomes, or domain semantics.
263	Codex Language Specification — Version 1.0.0 > 3. Core Model > 3.7 Annotation	Annotations MUST be preserved through Codex-conforming processing, subject only
278	Codex Language Specification — Version 1.0.0 > 4. Naming Rules > 4.1 Name Forms	* **PascalCase**: a name composed only of ASCII letters and digits; the first character MUST be an ASCII uppercase letter.
279	Codex Language Specification — Version 1.0.0 > 4. Naming Rules > 4.1 Name Forms	* **camelCase**: a name composed only of ASCII letters and digits; the first character MUST be an ASCII lowercase letter.
281	Codex Language Specification — Version 1.0.0 > 4. Naming Rules > 4.1 Name Forms	A name MUST contain at least one character.
283	Codex Language Specification — Version 1.0.0 > 4. Naming Rules > 4.1 Name Forms	Concept names MUST use PascalCase.
285	Codex Language Specification — Version 1.0.0 > 4. Naming Rules > 4.1 Name Forms	Trait names MUST use camelCase.
293	Codex Language Specification — Version 1.0.0 > 4. Naming Rules > 4.1 Name Forms > 4.1.1 Qualified Names	A **namespace prefix** MUST be a camelCase name (same form as a Trait name per §4.1).
300	Codex Language Specification — Version 1.0.0 > 4. Naming Rules > 4.1 Name Forms > 4.1.1 Qualified Names	The namespace prefix and the local name MUST each satisfy the naming rules of §4.1 and §4.2 independently.
302	Codex Language Specification — Version 1.0.0 > 4. Naming Rules > 4.1 Name Forms > 4.1.1 Qualified Names	Qualified names MUST only appear in contexts where schema imports are in effect (§11.2.1). The namespace prefix MUST resolve to an imported schema via the document's `SchemaImports` declarations.
304	Codex Language Specification — Version 1.0.0 > 4. Naming Rules > 4.1 Name Forms > 4.1.1 Qualified Names	Language-level Trait names (`id`, `key`, `reference`, `target`, `for`) MUST NOT be namespace-qualified. These Traits are defined by this specification (§6–§7), not by any schema.
308	Codex Language Specification — Version 1.0.0 > 4. Naming Rules > 4.2 Consecutive Uppercase Restriction	Concept names and Trait names MUST NOT contain three or more consecutive ASCII uppercase letters.
314	Codex Language Specification — Version 1.0.0 > 4. Naming Rules > 4.3 Acronyms and Initialisms (Author Responsibility)	Authors MUST write acronyms and initialisms as single words with only the first letter capitalized.
333	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.1 Text Values	In the Surface Form, Text Values MUST be spelled as quoted text literals or backtick text (see §5.2). Appendix A.1.8 and A.2.8 provide informative grammar projections of these rules.
335	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.1 Text Values	A quoted text literal is delimited by double-quote characters (`"..."`) and MUST NOT contain raw newlines (U+000A). Within the quotes, any Unicode scalar value other than `"` (U+0022), `\` (U+005C), or newline (U+000A) may appear literally. The `\` character introduces an escape sequence. The permitted escape sequences are:
342	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.1 Text Values	Hexadecimal digits in escape sequences are case-insensitive for parsing. A Unicode escape MUST identify a Unicode scalar value (U+0000 to U+D7FF or U+E000 to U+10FFFF).
344	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.1 Text Values	After interpreting escape sequences, the resulting character sequence MUST be transformed into the resulting Text Value by applying the following whitespace normalization:
346	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.1 Text Values	- Each maximal run of characters with the Unicode `White_Space` property (as defined by Unicode 16.0.0) MUST be replaced with a single U+0020 SPACE.
347	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.1 Text Values	- Leading and trailing U+0020 SPACE MUST be removed.
349	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.1 Text Values	This normalization applies to all Text Value spellings (quoted text and backtick text). The resulting Text Value MUST be single-line.
355	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.2 Backtick Text	Backtick text MUST allow authors to write Text Values that span multiple source lines.
366	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.3 Boolean Values	In the Surface Form, Boolean Values MUST be spelled as the tokens `true` and `false`.
374	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.4 Numeric Values	When the surface spelling could match multiple type grammars, the type MUST be the first match in this order: ComplexNumber, ImaginaryNumber, PrecisionNumber, ExponentialNumber, Fraction, PositiveInfinity, NegativeInfinity, DecimalNumber, Integer.
376	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.4 Numeric Values	Codex performs no arithmetic and no numeric normalization. Spellings MUST be preserved exactly. Value-level `+` signs MUST NOT appear; absence of a sign indicates a positive value. Exponent signs in ExponentialNumber (§5.4.3) and complex-number signs in ComplexNumber (§5.4.9) are not value-level signs.
378	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.4 Numeric Values	Integer digit sequences MUST NOT have leading zeros, except that the single digit `0` is permitted. A sign character (if present) is not part of the integer component. This applies to: Integer values, the integer part of DecimalNumber, the exponent digits of ExponentialNumber, the precision suffix digits of PrecisionNumber, and Fraction denominators.
380	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.4 Numeric Values	NaN MUST NOT appear.
382	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.4 Numeric Values	When mapped to XSD datatypes for the RDF canonical representation (§9), `Infinity` MUST be translated to `INF` and `-Infinity` MUST be translated to `-INF`.
390	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.4 Numeric Values > 5.4.1 Integer	The spelling `-0` MUST NOT appear. A conforming implementation MUST reject it as a `SurfaceFormError` (§14).
421	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.4 Numeric Values > 5.4.4 PrecisionNumber	Consuming systems MUST preserve the declared precision.
429	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.4 Numeric Values > 5.4.5 Fraction	The denominator MUST NOT be `0`. A conforming implementation MUST reject a zero denominator as a `SurfaceFormError` (§14).
431	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.4 Numeric Values > 5.4.5 Fraction	Fractions MUST NOT be reduced or normalized. The spelling is preserved exactly.
445	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.4 Numeric Values > 5.4.7 NegativeInfinity	`+Infinity` MUST NOT appear. `$Infinity` (§11.5) is a union type token accepting either PositiveInfinity or NegativeInfinity. It is not a parent type.
461	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.4 Numeric Values > 5.4.9 ComplexNumber	The meaning of any value of these types beyond its literal spelling MUST be defined by the governing schema or consuming system.
467	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.5 Enumerated Token Values	In the Surface Form, Enumerated Token Values MUST be spelled with a leading `$` sigil followed by a token name. The token name MUST use PascalCase. An Enumerated Token Value spelling may include type parameters as defined in §5.18.
469	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.5 Enumerated Token Values	Enumerated Token Values MUST NOT be treated as Text Values.
471	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.5 Enumerated Token Values	Enumerated Token Values MUST NOT be evaluated.
477	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values	In the Surface Form, Temporal Values MUST be spelled as `{` followed by a Temporal Body followed by `}`.
481	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values	During semantic validation, when a schema declares an expected temporal value type (for example, `$PlainDate`), tools MUST parse the braced payload into that temporal type and MUST reject values that are semantically invalid for that type (for example, an impossible date).
483	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values	Temporal Keywords (`{now}` and `{today}`) MUST remain symbolic during semantic validation unless the governing schema explicitly defines otherwise; they MUST NOT be evaluated implicitly.
487	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.1 Temporal Kind Determination	To classify a Temporal Value as a specific temporal kind, tools MUST parse the Temporal Body using the spelling rules defined in §5.6.2.
491	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.1 Temporal Kind Determination	The temporal kind MUST be determined by the first matching alternative in the following ordered list:
504	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.1 Temporal Kind Determination	Temporal Values MUST NOT be treated as Enumerated Token Values, even when the braced payload is a reserved literal such as `now` or `today`.
514	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	- A `Year` MUST be spelled as exactly four decimal digits (`0`–`9`).
515	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	- A `Month` MUST be spelled as exactly two decimal digits.
516	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	- A `Day` MUST be spelled as exactly two decimal digits.
517	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	- An `Hour` MUST be spelled as exactly two decimal digits.
518	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	- A `Minute` MUST be spelled as exactly two decimal digits.
519	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	- A `Second` MUST be spelled as exactly two decimal digits.
520	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	- `FractionalSeconds` MUST be spelled as one or more decimal digits.
521	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	- A `WeekNumber` MUST be spelled as exactly two decimal digits.
525	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	A `PlainDate` MUST be spelled as `Year`, `-`, `Month`, `-`, `Day` (for example, `2024-03-15`).
529	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	A `YearWeek` MUST be spelled as `Year`, `-`, `W` or `w`, `WeekNumber` (for example, `2024-W12`).
533	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	A `PlainYearMonth` MUST be spelled as `Year`, `-`, `Month` (for example, `2024-03`).
537	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	A `PlainMonthDay` MUST be spelled as `Month`, `-`, `Day` (for example, `03-15`).
541	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	A `PlainTime` MUST be spelled as `Hour`, `:`, `Minute`, optionally followed by `:`, `Second`, which itself is optionally followed by `.`, `FractionalSeconds` (for example, `14:30`, `14:30:00`, `14:30:00.123`).
545	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	A `PlainDateTime` MUST be spelled as a `PlainDate`, followed by `T`, followed by a `PlainTime` (for example, `2024-03-15T14:30:00`).
549	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	A timezone offset MUST be spelled as either `Z` or as `+` or `-` followed by `Hour`, `:`, `Minute` (for example, `Z`, `+05:30`, `-08:00`).
553	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	A timezone identifier MUST be spelled as `[`, followed by one or more timezone identifier characters, followed by `]`. A timezone identifier character MUST be an ASCII letter, an ASCII digit, `/`, `_`, or `-` (for example, `[America/New_York]`).
557	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	An `Instant` MUST be spelled as a `PlainDateTime` followed by a timezone offset (for example, `2024-03-15T14:30:00Z`).
561	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	A `ZonedDateTime` MUST be spelled as a `PlainDateTime`, followed by a timezone offset, followed by a timezone identifier (for example, `2024-03-15T14:30:00-05:00[America/New_York]`).
565	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	A `Duration` MUST be spelled in one of two forms:
570	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	A date duration component MUST be spelled as one or more decimal digits followed by one of `Y`, `M`, `W`, or `D`.
572	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	A time duration component MUST be spelled as one or more decimal digits, optionally followed by `.` and one or more decimal digits, followed by one of `H`, `M`, or `S`.
578	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.6 Temporal Values > 5.6.2 Temporal Spelling Rules	A `TemporalKeyword` MUST be exactly `now` or `today`.
582	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values	A Color Value MUST NOT be treated as a Text Value.
586	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values	During semantic validation, when a schema declares an expected color value type (for example, `$Color` or a more specific built-in color type), tools MUST interpret the lexical spelling into a semantic color value of the expected type and MUST reject values that cannot be converted into a valid color in that type.
588	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values	In the Surface Form, Color Values MUST be spelled using one of the following literal forms:
604	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values	Hex digits in hexadecimal colors are case-insensitive for parsing. In canonical surface form, hexadecimal digits in Color Values MUST be lowercase.
606	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values	Color function names are case-insensitive for parsing. In canonical surface form, color function names MUST be lowercase.
608	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values	Color space tokens in `color(...)` are case-insensitive for parsing. In canonical surface form, color space tokens MUST be lowercase. The color space token MUST be one of:
622	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.1 Color Kind Determination	To classify a Color Value as a specific color kind, tools MUST identify the surface spelling and apply the first matching rule in the following ordered list:
645	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.2 Named Color Values	In the Surface Form, a Named Color Value MUST be spelled as `&` followed immediately by a color name.
647	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.2 Named Color Values	The color name MUST consist only of ASCII lowercase letters (`a` through `z`).
649	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.2 Named Color Values	The color name MUST be one of the named color keywords defined in Appendix B; an unrecognized color name is a ParseError (§14).
651	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.2 Named Color Values	During semantic validation, a recognized named color MUST be interpreted as the sRGB RGBA value defined for that keyword in Appendix B.
664	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.3 Deterministic Conversion-Based Validity (Lab/LCH, OKLab/OKLCH)	tools MUST:
670	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.3 Deterministic Conversion-Based Validity (Lab/LCH, OKLab/OKLCH)	Tools MUST NOT clamp, normalize, wrap hues, or apply gamut mapping.
672	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.3 Deterministic Conversion-Based Validity (Lab/LCH, OKLab/OKLCH)	For `lch(...)` and `oklch(...)`, hue MUST satisfy the Hue rule defined in §5.7.4.
676	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.3 Deterministic Conversion-Based Validity (Lab/LCH, OKLab/OKLCH)	The conversion MUST be computed using a deterministic binary floating-point arithmetic model with precision `p = 256` bits, using round-to-nearest ties-to-even.
678	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.3 Deterministic Conversion-Based Validity (Lab/LCH, OKLab/OKLCH)	Every non-dot-product arithmetic operation used by this subsection (addition, subtraction, multiplication, division, comparisons, and the cube computations used by the `lab(...)` transfer) MUST compute its result in this `p = 256` model, rounding to `p = 256` before any subsequent operation.
680	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.3 Deterministic Conversion-Based Validity (Lab/LCH, OKLab/OKLCH)	All matrix-vector multiplications in this subsection MUST be evaluated using the following single mandated dot-product procedure.
688	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.3 Deterministic Conversion-Based Validity (Lab/LCH, OKLab/OKLCH)	Each matrix-vector product component MUST be computed by applying the above procedure to the corresponding matrix row and input vector.
692	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.3 Deterministic Conversion-Based Validity (Lab/LCH, OKLab/OKLCH)	The trigonometric functions `sin` and `cos` used by `lch(...)` and `oklch(...)` MUST be computed as correctly-rounded results in precision `p = 256`.
694	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.3 Deterministic Conversion-Based Validity (Lab/LCH, OKLab/OKLCH)	The functions `sqrt`, `cbrt`, and `atan2` used by §5.7 MUST be computed as correctly-rounded results in precision `p = 256`.
696	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.3 Deterministic Conversion-Based Validity (Lab/LCH, OKLab/OKLCH)	The real-exponent power computations required by §5.7 (for example, raising a channel to `2.4`, `1/2.4`, `563/256`, `256/563`, `1.8`, `1/1.8`, `0.45`, and `1/0.45`) MUST be computed as correctly-rounded results in precision `p = 256`.
698	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.3 Deterministic Conversion-Based Validity (Lab/LCH, OKLab/OKLCH)	Tools MUST NOT use lower-precision arithmetic for any intermediate step, and MUST NOT approximate this procedure using binary64 or binary128.
821	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	These rules apply only during schema-driven semantic validation. They MUST NOT rewrite or normalize the canonical surface spelling.
825	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	All arithmetic required by this subsection (including percent conversion, normalization by division, and range comparisons) MUST be performed using the deterministic binary floating-point model defined by §5.7.3 (precision `p=256`, round-to-nearest ties-to-even).
827	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	All component inputs and computed intermediates used by this subsection MUST be finite, per the non-finite rejection rule in §5.7.3.
837	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	Newlines MUST NOT appear inside color function parentheses. Whitespace inside color function parentheses consists of spaces (U+0020) and tabs (U+0009) only.
839	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	Numeric arguments in color functions use the real-number subset of the Numeric Value form (§5.4): integers, decimal numbers, exponential numbers, precision-annotated numbers, rational fractions, and `Infinity`/`-Infinity`. Complex and imaginary numbers MUST NOT appear in color function arguments.
848	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	`rgb(...)`/`rgba(...)` and `hsl(...)`/`hsla(...)` MUST accept both modern and legacy syntax. All other color functions MUST use modern syntax only.
869	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- If alpha is spelled as a percentage, it MUST be in `[0%,100%]` and is interpreted as `alpha` in `[0,1]`.
870	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- If alpha is spelled as a number, it MUST be in `[0,1]` and is interpreted as `alpha` in `[0,1]`.
876	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	Where a hue component is permitted (in `hsl(...)`, `hwb(...)`, `lch(...)`, and `oklch(...)`), hue is a bare numeric angle in degrees. A hue component MUST NOT be spelled as a percentage. Hue values MUST be finite and MUST satisfy `0 <= h < 360`. See §5.7.3 for the general prohibition on clamping, normalization, hue wrapping, and gamut mapping.
882	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `$HexColor`: tools MUST decode the hex spelling into a semantic RGBA value with 8-bit components.
887	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `$NamedColor`: tools MUST validate that the name is a keyword in Appendix B and compile the semantic value as the corresponding sRGB RGBA value defined by Appendix B.
889	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `$RgbColor`: tools MUST parse `rgb(...)`/`rgba(...)` — three RGB components (red, green, blue) and an optional alpha, in modern or legacy syntax — and compile a semantic sRGB value `(r,g,b,alpha)` where each component is in `[0,1]`.
891	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- If spelled as a percentage, it MUST be in `[0%,100%]` and is interpreted by dividing by 100.
892	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- If spelled as a number, it MUST be in `[0,255]` and is interpreted by dividing by 255.
894	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `$HslColor`: tools MUST parse `hsl(...)`/`hsla(...)` — a hue, two percentages, and an optional alpha, in modern or legacy syntax — and compile a semantic HSL value `(h,s,l,alpha)` where:
898	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `$HwbColor`: tools MUST parse `hwb(...)` — a hue, two percentages, and an optional alpha, in modern syntax — and compile a semantic HWB value `(h,w,b,alpha)` where:
901	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- Additionally, `w + b` MUST satisfy `<= 1`.
903	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `$LabColor`: tools MUST parse `lab(...)` — a percentage, two numbers, and an optional alpha, in modern syntax — and compile a semantic Lab value `(L,a,b,alpha)` where:
906	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- The value MUST additionally satisfy the deterministic conversion validity rule in §5.7.3.
908	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `$LchColor`: tools MUST parse `lch(...)` — a percentage, two numbers, and an optional alpha, in modern syntax — and compile a semantic LCH value `(L,C,h,alpha)` where:
910	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `C` MUST be finite and MUST satisfy `C >= 0`.
912	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- The value MUST additionally satisfy the deterministic conversion validity rule in §5.7.3.
914	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `$OklabColor`: tools MUST parse `oklab(...)` — three numbers and an optional alpha, in modern syntax — and compile a semantic OKLab value `(L,a,b,alpha)` where:
915	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `L` MUST be in `[0,1]`.
917	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- The value MUST additionally satisfy the deterministic conversion validity rule in §5.7.3.
919	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `$OklchColor`: tools MUST parse `oklch(...)` — three numbers and an optional alpha, in modern syntax — and compile a semantic OKLCH value `(L,C,h,alpha)` where:
920	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `L` MUST be in `[0,1]`.
921	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `C` MUST be finite and MUST satisfy `C >= 0`.
923	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- The value MUST additionally satisfy the deterministic conversion validity rule in §5.7.3.
926	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `$ColorSpaceColor`: tools MUST parse `color(...)` — a `ColorSpace` token followed by three numeric components and an optional alpha, in modern syntax — and compile a semantic color-space value `(space, c1, c2, c3, alpha)` where:
931	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `$DeviceCmyk`: tools MUST parse `device-cmyk(...)` — four CMYK components (each a percentage or number) and an optional alpha, in modern syntax — and compile a semantic device-CMYK value `(c,m,y,k,alpha)` where each of `c,m,y,k,alpha` is in `[0,1]`.
932	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- If a CMYK component is spelled as a percentage, it MUST be in `[0%,100%]` and is interpreted as a fraction in `[0,1]`.
933	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- If a CMYK component is spelled as a number, it MUST be in `[0,1]`.
935	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `$ColorMix`: tools MUST parse `color-mix(...)` per the argument spelling rules above and compile a semantic color-mix value `(space, stops)`.
939	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- The nested `color` value in each stop MUST be semantically valid as `$Color`.
940	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- When a schema expects `$Color` and the spelling is `color-mix(...)`, tools MUST additionally evaluate the mix deterministically as specified by §5.7.7.
943	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `$ColorSpaceColorFunction`: tools MUST accept any function-based Color Value spelling and compile the corresponding semantic function-domain value (including `rgb(...)`, `hsl(...)`, `hwb(...)`, `lab(...)`, `lch(...)`, `oklab(...)`, `oklch(...)`, `color(...)`, `color-mix(...)`, relative-color forms, and `device-cmyk(...)`).
944	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- If the spelling is a relative color form, tools MUST interpret `from <color>` deterministically as specified by §5.7.8.
945	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- If the spelling is `color-mix(...)`, tools MUST interpret the stop list deterministically as specified by §5.7.7.
947	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	- `$Color`: tools MUST accept any Color Value spelling and compile a semantic color value as follows.
951	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.4 Schema-Directed Semantic Color IR	If a schema expects a specific built-in color ValueType token and the Trait value uses a different Color Value form, schema validation MUST fail with a `SchemaError` (§14).
962	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.5 Deterministic Conversions for `color(...)` Spaces (`XYZ_D65` Interchange)	All arithmetic required by this subsection MUST use the deterministic numeric model of §5.7.3.
964	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.5 Deterministic Conversions for `color(...)` Spaces (`XYZ_D65` Interchange)	All matrix-vector multiplications required by §5.7.5–§5.7.8 MUST use the single mandated dot-product procedure defined by §5.7.3.
1335	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.6 Semantic Interpretation of `color(...)`	When a schema expects a `color(...)` spelling as `$Color` or `$ColorSpaceColorFunction`, tools MUST interpret the components and alpha as follows.
1339	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.6 Semantic Interpretation of `color(...)`	- If a component is spelled as a percentage, it MUST be in `[0%,100%]` and is interpreted by dividing by 100.
1340	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.6 Semantic Interpretation of `color(...)`	- If a component is spelled as a number, it MUST be in `[0,1]` and is interpreted as-is.
1344	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.6 Semantic Interpretation of `color(...)`	- Each of `x`, `y`, and `z` MUST be finite and MUST satisfy `>= 0`.
1350	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.7 Deterministic Semantic Evaluation of `color-mix(...)`	When a schema expects `$Color` and the Trait value is `color-mix(in S, stop1, stop2, ...)`, tools MUST evaluate the mix deterministically.
1353	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.7 Deterministic Semantic Evaluation of `color-mix(...)`	2. Each stop MUST be `(color, weight?)` where `color` is a Color Value.
1356	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.7 Deterministic Semantic Evaluation of `color-mix(...)`	- If any stop provides a weight, then every stop MUST provide a weight; otherwise it is a `SchemaError`.
1357	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.7 Deterministic Semantic Evaluation of `color-mix(...)`	- Each provided weight MUST be in `[0%,100%]`.
1385	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.8 Deterministic Semantic Evaluation of Relative Colors (`from <color>`)	When a schema expects `$Color` or `$ColorSpaceColorFunction` and the Trait value is a relative color form, tools MUST evaluate `from <color>` deterministically as follows.
1405	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.7 Color Values > 5.7.8 Deterministic Semantic Evaluation of Relative Colors (`from <color>`)	5. After substitution, the resulting non-relative color spelling MUST satisfy the semantic rules for that function/value type (including hue and range rules). Otherwise it is a `SchemaError`.
1440	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.8 UUID Values	A UUID Value MUST NOT be a Text Value.
1442	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.8 UUID Values	A UUID Value MUST NOT include braces, prefixes, or other delimiters.
1444	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.8 UUID Values	Hyphens MUST appear at character positions 9, 14, 19, and 24 (1-indexed).
1446	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.8 UUID Values	Hexadecimal digits in UUID Values are case-insensitive for parsing. In canonical surface form, UUID Values MUST be spelled using lowercase hexadecimal digits.
1454	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.9 IRI Reference Values	An IRI Reference Value MUST contain a `:` character separating the scheme from the remainder.
1456	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.9 IRI Reference Values	In the Surface Form, IRI Reference Values MUST be spelled using the IRI reference grammar defined by this specification.
1458	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.9 IRI Reference Values	IRI Reference Values MUST permit non-ASCII Unicode characters directly and MUST permit percent-encoding, as defined for IRI-references by RFC 3987: https://www.rfc-editor.org/rfc/rfc3987.
1460	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.9 IRI Reference Values	For all Unicode character classifications referenced by this section (whitespace, control, bidirectional control, and private-use), tools MUST use the Unicode 16.0.0 character property tables.
1462	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.9 IRI Reference Values	IRI Reference Values MUST NOT contain Unicode whitespace characters.
1464	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.9 IRI Reference Values	IRI Reference Values MUST NOT contain Unicode control characters.
1466	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.9 IRI Reference Values	IRI Reference Values MUST NOT contain Unicode bidirectional control characters.
1468	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.9 IRI Reference Values	IRI Reference Values MUST NOT contain Unicode private-use characters.
1470	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.9 IRI Reference Values	An IRI Reference Value MUST NOT end with a `:` character.
1472	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.9 IRI Reference Values	An IRI Reference Value MUST NOT be a Text Value.
1474	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.9 IRI Reference Values	IRI Reference Values MUST be compared as opaque sequences of Unicode scalar values (Unicode 16.0.0).
1476	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.9 IRI Reference Values	Codex-conforming tools MUST NOT dereference IRI Reference Values.
1478	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.9 IRI Reference Values	Where this specification defines deterministic resolution (for example, lookup-token resolution and reference-constraint resolution), tools MUST apply only the mechanisms defined by this specification and MUST NOT perform any external lookup, registry query, or network dereferencing.
1484	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.10 Lookup Token Values	In the Surface Form, Lookup Token Values MUST be spelled as `~` followed immediately by a token name.
1486	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.10 Lookup Token Values	The token name MUST use camelCase.
1488	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.10 Lookup Token Values	A Lookup Token Value MUST NOT be a Text Value.
1490	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.10 Lookup Token Values	Codex-conforming tools MUST NOT dereference Lookup Token Values.
1496	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.11 Character Values	In the Surface Form, Character Values MUST be spelled as character literals delimited by single quotes (`'...'`). A character literal MUST NOT contain raw newlines (U+000A). Within the quotes, any Unicode scalar value other than `'` (U+0027), `\` (U+005C), or newline (U+000A) may appear literally. The `\` character introduces an escape sequence. The permitted escape sequences are:
1506	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.11 Character Values	Hexadecimal digits in escape sequences are case-insensitive for parsing. A Unicode escape MUST identify a Unicode scalar value (U+0000 to U+D7FF or U+E000 to U+10FFFF).
1508	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.11 Character Values	A Character Value MUST NOT be a Text Value.
1510	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.11 Character Values	After interpreting the character literal's escape sequences, the resulting Character Value MUST contain exactly one Unicode scalar value.
1518	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.12 List Values	Each element of a List Value MUST be a Value.
1520	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.12 List Values	A List Value MUST permit nesting.
1522	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.12 List Values	A List Value MUST NOT require all elements to have the same Value kind.
1524	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.12 List Values	A List Value MUST represent exactly the elements explicitly present in its literal spelling.
1529	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.13 Value Equality for Collection Uniqueness	For purposes of detecting duplicates in Set Values, Map Values, and Record Values, Codex-conforming tools MUST use the following Value equality relation.
1531	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.13 Value Equality for Collection Uniqueness	Equality is defined over parsed Values (after interpreting escape sequences, Text whitespace normalization, and other value-specific decoding rules) and MUST NOT be defined over raw source bytes.
1556	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.14 Set Values	A Set Value is an unordered collection of zero or more Value elements. Set Values have no semantic ordering; however, in canonical surface form, elements MUST be serialized in the order they appear in the source spelling.
1560	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.14 Set Values	Each element of a Set Value MUST be a Value.
1562	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.14 Set Values	A Set Value MUST permit nesting.
1564	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.14 Set Values	A Set Value MUST NOT require all elements to have the same Value kind.
1566	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.14 Set Values	A Set Value MUST contain no duplicate elements.
1568	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.14 Set Values	Duplicate elements MUST be determined using the Value equality relation in §5.13.
1570	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.14 Set Values	If a set literal spelling contains duplicate elements, Codex-conforming tools MUST reject that spelling with a `ParseError` (§14).
1576	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.15 Map Values	A Map Value is a collection of key-value pairs. Map Values have no semantic ordering; however, in canonical surface form, entries MUST be serialized in the order they appear in the source spelling.
1580	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.15 Map Values	A Map Value MUST permit zero entries.
1582	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.15 Map Values	Each entry in a Map Value MUST bind exactly one key to exactly one Value.
1584	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.15 Map Values	A Map Value MUST permit nesting.
1586	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.15 Map Values	A Map Value MUST NOT require all bound Values to have the same Value kind.
1588	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.15 Map Values	A Map Value MUST contain no duplicate keys.
1590	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.15 Map Values	Duplicate keys MUST be determined using the Value equality relation in §5.13.
1592	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.15 Map Values	If a map literal spelling contains duplicate keys, Codex-conforming tools MUST reject that spelling with a `ParseError` (§14).
1598	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.15 Map Values > 5.15.1 Map Keys	In the Surface Form, a map key MUST be one of:
1607	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.15 Map Values > 5.15.1 Map Keys	An unquoted identifier key MUST use camelCase.
1615	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.16 Tuple Values	A Tuple Value MUST contain at least one element.
1617	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.16 Tuple Values	Each element of a Tuple Value MUST be a Value.
1619	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.16 Tuple Values	A Tuple Value MUST permit nesting.
1621	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.16 Tuple Values	A Tuple Value MUST NOT require all elements to have the same Value kind.
1623	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.16 Tuple Values	For any Tuple Value used by a Trait, the governing schema MUST define the required arity and the meaning of each position.
1633	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.17 Range Values	Range endpoints and step values MUST be ordered numeric types (Integer, DecimalNumber, Fraction, ExponentialNumber, or PrecisionNumber), Temporal Values, or Character Values (Character Values are permitted as endpoints only, not as step values). ComplexNumber, ImaginaryNumber, and Infinity MUST NOT appear as range endpoints or step values.
1635	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.17 Range Values	A Range Value MUST contain a start endpoint and an end endpoint.
1637	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.17 Range Values	The start endpoint and end endpoint MUST be Values of the same base Value kind (e.g., both Integer, both PlainDate), independent of any parameterized type constraints.
1639	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.17 Range Values	A Range Value MUST contain either zero steps or one step.
1641	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.17 Range Values	If a step is present, the governing schema MUST define which Value kinds are valid for the step.
1643	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.17 Range Values	Range endpoints MUST be treated as inclusive.
1645	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.17 Range Values	Codex-conforming tools MUST NOT enumerate Range Values.
1647	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.17 Range Values	The semantics of a Range Value beyond these structural requirements MUST be defined by the governing schema or consuming system.
1670	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.18 Parameterized Value Types > 5.18.2 Type Arguments	A type argument MUST be one of:
1678	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.18 Parameterized Value Types > 5.18.2 Type Arguments	When a parameterized type has multiple type arguments, the arguments MUST be separated by a comma followed by exactly one space (`, `). Within a type union, members MUST be separated by a comma followed by exactly one space (`, `).
1680	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.18 Parameterized Value Types > 5.18.2 Type Arguments	Type arguments MUST NOT contain whitespace. No whitespace is permitted immediately after `<`, immediately before `>`, immediately after `[`, or immediately before `]`.
1711	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.19 Record Values	A Record Value MUST permit zero fields.
1713	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.19 Record Values	Each entry in a Record Value MUST bind exactly one field name to exactly one Value.
1715	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.19 Record Values	A Record Value MUST permit nesting.
1717	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.19 Record Values	A Record Value MUST NOT require all bound Values to have the same Value kind.
1719	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.19 Record Values	A Record Value MUST contain no duplicate field names.
1721	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.19 Record Values	Duplicate field names MUST be determined using the Value equality relation in §5.13.
1723	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.19 Record Values	If a record literal spelling contains duplicate field names, Codex-conforming tools MUST reject that spelling with a `ParseError` (§14).
1729	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.19 Record Values > 5.19.1 Record Field Names	In the Surface Form, a record field name MUST be an unquoted identifier using camelCase.
1735	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	Host Name Values are defined to avoid reliance on external internationalization profiles. Implementations MUST treat Host Name Values as already being in ASCII (for example, A-label form for internationalized names).
1737	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	In the Surface Form, Host Name Values MUST be spelled as the keyword `host` followed by a parenthesized Text Value. Optional whitespace is permitted after `(` and before `)`:
1741	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	The keyword `host` MUST be spelled using ASCII lowercase letters.
1743	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	After interpreting the Text Value's escape sequences, the decoded `hostname` text MUST NOT contain Unicode whitespace characters.
1745	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	The decoded `hostname` text MUST NOT contain Unicode control characters.
1747	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	The decoded `hostname` text MUST NOT contain Unicode bidirectional control characters.
1749	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	The decoded `hostname` text MUST NOT contain Unicode private-use characters.
1751	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	For all Unicode character classifications referenced by this section (whitespace, control, bidirectional control, and private-use), tools MUST use the Unicode 16.0.0 character property tables.
1753	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	Host Name Values MUST be canonicalized as follows:
1758	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	- The hostname MUST NOT be empty.
1759	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	- The hostname MUST NOT start or end with `.`.
1760	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	- The hostname MUST be at most 253 characters.
1761	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	- The hostname MUST consist of one or more labels separated by `.`.
1762	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	- Each label MUST be 1–63 characters.
1763	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	- Each label MUST contain only ASCII letters `a`–`z`, digits `0`–`9`, and hyphen `-`.
1764	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	- Each label MUST NOT start with `-` and MUST NOT end with `-`.
1766	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	If any step fails, Codex-conforming tools MUST reject the Host Name Value spelling with a `SchemaError` (§14).
1768	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	In canonical surface form, Host Name Values MUST be spelled as `host("<hostname>")`, where `<hostname>` is the lowercase ASCII hostname produced by the canonicalization procedure above.
1770	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.20 Host Name Values	A Host Name Value MUST NOT be treated as a Text Value.
1776	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.21 Email Address Values	In the Surface Form, Email Address Values MUST be spelled as the keyword `email` followed by a parenthesized Text Value. Optional whitespace is permitted after `(` and before `)`:
1780	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.21 Email Address Values	The keyword `email` MUST be spelled using ASCII lowercase letters.
1782	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.21 Email Address Values	After interpreting the Text Value's escape sequences, the decoded `address` text MUST contain exactly one `@` character.
1786	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.21 Email Address Values	The decoded `address` text MUST NOT contain Unicode whitespace characters.
1788	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.21 Email Address Values	The decoded `address` text MUST NOT contain Unicode control characters.
1790	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.21 Email Address Values	The decoded `address` text MUST NOT contain Unicode bidirectional control characters.
1792	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.21 Email Address Values	The decoded `address` text MUST NOT contain Unicode private-use characters.
1794	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.21 Email Address Values	For all Unicode character classifications referenced by this section (whitespace, control, bidirectional control, and private-use), tools MUST use the Unicode 16.0.0 character property tables.
1796	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.21 Email Address Values	The `local` part MUST be non-empty.
1798	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.21 Email Address Values	The `domain` part MUST be non-empty.
1800	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.21 Email Address Values	Email Address Values MUST be canonicalized as follows:
1806	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.21 Email Address Values	If any step fails, Codex-conforming tools MUST reject the Email Address Value spelling with a `SchemaError` (§14).
1808	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.21 Email Address Values	In canonical surface form, Email Address Values MUST be spelled as `email("<local>@<ascii-domain>")`, where `<local>` is the NFC-normalized local part and `<ascii-domain>` is the canonicalized lowercase ASCII domain.
1810	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.21 Email Address Values	An Email Address Value MUST NOT be treated as a Text Value.
1818	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values	In the Surface Form, URL Values MUST be spelled using one of the following two forms:
1823	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values	The keyword `url` MUST be spelled using ASCII lowercase letters.
1825	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values	Both arguments MUST be Text Values. Optional whitespace is permitted after `(`, before `)`, and around the comma in the two-argument form.
1827	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values	For all Unicode character classifications referenced by this section (whitespace, control, bidirectional control, and private-use), tools MUST use the Unicode 16.0.0 character property tables.
1829	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values	After interpreting Text Value escape sequences, the decoded URL text MUST NOT contain Unicode whitespace characters, Unicode control characters, Unicode bidirectional control characters, or Unicode private-use characters.
1831	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values	The decoded URL text MUST contain only ASCII characters.
1846	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values > 5.22.1 URL Parsing Model	1. The decoded URL text MUST contain a `:` character.
1847	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values > 5.22.1 URL Parsing Model	2. The `scheme` MUST be non-empty.
1848	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values > 5.22.1 URL Parsing Model	3. The first character of `scheme` MUST be an ASCII letter (`A`–`Z` or `a`–`z`).
1849	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values > 5.22.1 URL Parsing Model	4. The remaining characters of `scheme` MUST be ASCII letters, digits, `+`, `-`, or `.`.
1850	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values > 5.22.1 URL Parsing Model	5. If an `authority` is present, it MUST be non-empty.
1874	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values > 5.22.2 URL Resolution (two-argument form)	If parsing or resolution fails, tools MUST reject with a `SchemaError` (§14).
1878	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values > 5.22.3 URL Canonicalization	After obtaining the resolved URL components (one-argument form parses directly; two-argument form resolves then parses), tools MUST canonicalize as follows:
1892	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values > 5.22.3 URL Canonicalization	If canonicalization fails at any step, tools MUST reject with a `SchemaError` (§14).
1894	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values > 5.22.3 URL Canonicalization	In canonical surface form, URL Values MUST be spelled using the single-argument form `url("<canonical-url>")` where `<canonical-url>` is the canonical serialized URL string.
1896	Codex Language Specification — Version 1.0.0 > 5. Value Literal Catalog > 5.22 URL Values > 5.22.3 URL Canonicalization	A URL Value MUST NOT be treated as a Text Value.
1915	Codex Language Specification — Version 1.0.0 > 6. Identity > 6.2 Entity Identity > 6.2.1 The `id` Trait	Every Entity MUST have exactly one `id` trait. If an Entity lacks an `id` trait, Codex-conforming tools MUST reject that document with an `IdentityError` (§14).
1917	Codex Language Specification — Version 1.0.0 > 6. Identity > 6.2 Entity Identity > 6.2.1 The `id` Trait	Every non-Entity MUST NOT have an `id` trait. If a non-Entity declares an `id` trait, Codex-conforming tools MUST reject that document with an `IdentityError` (§14).
1919	Codex Language Specification — Version 1.0.0 > 6. Identity > 6.2 Entity Identity > 6.2.1 The `id` Trait	The value of an `id` trait MUST be an IRI Reference Value (§5.9). If the value of an `id` trait is not an IRI Reference Value, Codex-conforming tools MUST reject that document with an `IdentityError` (§14).
1921	Codex Language Specification — Version 1.0.0 > 6. Identity > 6.2 Entity Identity > 6.2.1 The `id` Trait	Codex-conforming tools MUST NOT synthesize an `id` trait.
1925	Codex Language Specification — Version 1.0.0 > 6. Identity > 6.2 Entity Identity > 6.2.2 Uniqueness	Within a single document, each `id` value MUST be unique across all Entities. If a document contains duplicate `id` values, Codex-conforming tools MUST reject that document with an `IdentityError` (§14).
1931	Codex Language Specification — Version 1.0.0 > 6. Identity > 6.2 Entity Identity > 6.2.3 Stability	Once an `id` value is assigned to an Entity, that `id` value MUST continue to refer to the same Entity.
1933	Codex Language Specification — Version 1.0.0 > 6. Identity > 6.2 Entity Identity > 6.2.3 Stability	Changing an Entity's `id` value MUST be treated as creating a new Entity.
1939	Codex Language Specification — Version 1.0.0 > 6. Identity > 6.3 Concept Keys > 6.3.1 The `key` Trait	A Concept MUST NOT declare more than one `key` trait (see §3 for the general duplicate trait name prohibition).
1941	Codex Language Specification — Version 1.0.0 > 6. Identity > 6.3 Concept Keys > 6.3.1 The `key` Trait	The value of a `key` trait MUST be a Lookup Token Value (§5.10). If the value of a `key` trait is not a Lookup Token Value, Codex-conforming tools MUST reject that document with an `IdentityError` (§14).
1943	Codex Language Specification — Version 1.0.0 > 6. Identity > 6.3 Concept Keys > 6.3.1 The `key` Trait	Codex-conforming tools MUST NOT synthesize a `key` trait.
1947	Codex Language Specification — Version 1.0.0 > 6. Identity > 6.3 Concept Keys > 6.3.2 Uniqueness	Within a single document, each `key` value MUST be unique across all Concepts. If a document contains duplicate `key` values, Codex-conforming tools MUST reject that document with an `IdentityError` (§14).
1971	Codex Language Specification — Version 1.0.0 > 7. Reference Traits > 7.1 Reference Traits Overview	The value of each reference Trait MUST be either an IRI Reference Value (see §5.9) or a Lookup Token Value (see §5.10). The value of a reference Trait MUST NOT be any other Value kind. If the value of a reference Trait is not an IRI Reference Value or a Lookup Token Value, Codex-conforming tools MUST reject that document with a `ReferenceError` (§14).
1973	Codex Language Specification — Version 1.0.0 > 7. Reference Traits > 7.1 Reference Traits Overview	Reference Traits MUST be interpreted only as declarative relationships.
1975	Codex Language Specification — Version 1.0.0 > 7. Reference Traits > 7.1 Reference Traits Overview	Reference Traits MUST NOT imply dereferencing, loading, execution, or transformation.
1977	Codex Language Specification — Version 1.0.0 > 7. Reference Traits > 7.1 Reference Traits Overview	Reference Traits MUST NOT imply any automatic or external resolution beyond what is explicitly defined by this specification or the governing schema.
1979	Codex Language Specification — Version 1.0.0 > 7. Reference Traits > 7.1 Reference Traits Overview	A Concept instance MUST NOT declare a reference Trait unless authorized by the governing schema. If a Concept instance declares an unauthorized reference Trait, Codex-conforming tools MUST reject that document with a `SchemaError` (§14).
1981	Codex Language Specification — Version 1.0.0 > 7. Reference Traits > 7.1 Reference Traits Overview	Where reference Traits are authorized, the governing schema MUST define any additional semantics beyond the intent statements in this section.
1989	Codex Language Specification — Version 1.0.0 > 7. Reference Traits > 7.2 `reference`	The `reference` Trait MUST NOT imply action, application, scope, execution, or transformation.
1999	Codex Language Specification — Version 1.0.0 > 7. Reference Traits > 7.4 `for`	If a `for` reference is used to denote a Concept type, it MUST reference the `ConceptDefinition` Entity for that Concept by identity reference.
2003	Codex Language Specification — Version 1.0.0 > 7. Reference Traits > 7.5 Singleton Rule	If a governing schema requires that at most one of `reference`, `target`, or `for` be present on a Concept instance, it MUST express that requirement using `ReferenceConstraint(type=ReferenceSingleton)`.
2054	Codex Language Specification — Version 1.0.0 > 8. Surface Form	A Codex document MUST contain exactly one root Concept instance.
2058	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.1 File Encoding	Codex documents MUST be encoded in UTF-8 or UTF-16.
2060	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.1 File Encoding	The canonical encoding is UTF-8 with no Byte Order Mark (BOM). Canonicalization MUST normalize UTF-16 encoded input to UTF-8, removing the BOM.
2062	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.1 File Encoding	UTF-8 encoded files MUST NOT include a Byte Order Mark (BOM).
2064	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.1 File Encoding	UTF-16 encoding MUST be indicated by a BOM at the start of the file:
2069	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.1 File Encoding	Codex-conforming tools MUST determine the file encoding as follows:
2075	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.1 File Encoding	Codex-conforming tools MUST reject any other encoding with a `ParseError` (§14).
2081	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.2 Line Endings	Codex-conforming tools MUST normalize CRLF (`\r\n`) sequences to LF on input.
2083	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.2 Line Endings	Codex-conforming tools MUST reject bare CR (`\r`) with a `ParseError` (§14).
2085	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.2 Line Endings	In canonical surface form, a Codex document MUST end with a trailing LF.
2093	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.3 Indentation	- A root Concept instance MUST have no indentation (column 0).
2094	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.3 Indentation	- Direct children of a root Concept instance MUST be indented by exactly one tab.
2095	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.3 Indentation	- Each additional nesting level MUST increase indentation by exactly one additional tab.
2097	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.3 Indentation	Codex-conforming formatters MUST normalize indentation before semantic validation proceeds.
2099	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.3 Indentation	Codex-conforming tools MUST NOT treat author indentation as authoritative.
2101	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.3 Indentation	In the Surface Form, indentation MUST use U+0009 TAB characters only.
2103	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.3 Indentation	Codex-conforming tools MUST reject any U+0020 SPACE character that appears in the indentation prefix of any of the following lines with a `ParseError` (§14):
2109	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.3 Indentation	If indentation cannot be normalized deterministically, Codex-conforming tools MUST fail with a `FormattingError` (§14).
2115	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.4 Blank Lines	In canonical surface form, a Codex document MUST NOT start with a blank line.
2117	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.4 Blank Lines	Outside of content blocks (see §8.8) and annotations (see §8.9), Codex-conforming tools MUST NOT produce two consecutive blank lines in canonical surface form.
2119	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.4 Blank Lines	In canonical surface form, if no grouping or general annotations appear between two sibling Concept instances, there MUST be exactly one blank line between them.
2121	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.4 Blank Lines	For the purposes of this rule, an attached-annotation stack (see §8.9.6.1) MUST be treated as part of the Concept instance it attaches to.
2125	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.4 Blank Lines	In canonical surface form, Codex-conforming tools MUST reject documents containing any of the following with a `FormattingError` (§14):
2133	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.4 Blank Lines	Codex-conforming tools MUST treat a line containing only whitespace as empty after normalization. This is a canonicalization rule: trailing whitespace on a line is stripped during Phase 1 canonicalization (§10.4). In canonical form, a blank line contains no characters before its newline.
2135	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.4 Blank Lines	Annotation blank-line rules MUST be defined by the rules for annotations (see §8.9).
2137	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.4 Blank Lines	Blank line restrictions in this section MUST NOT be applied to content.
2141	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.5 Concept Markers	A Concept instance MUST be delimited by a Concept marker.
2151	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.5 Concept Markers > 8.5.1 Opening Marker	An opening marker MUST be spelled as:
2165	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.5 Concept Markers > 8.5.1 Opening Marker	The Concept name (or qualified Concept name) MUST follow the naming rules defined by this specification (§4.1). If the name does not conform to §4.1, Codex-conforming tools MUST reject the document with a `ParseError` (§14).
2169	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.5 Concept Markers > 8.5.1 Opening Marker	If multiple Traits are present, they MUST be ordered per §8.6.
2173	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.5 Concept Markers > 8.5.2 Closing Marker	A closing marker MUST be spelled as:
2185	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.5 Concept Markers > 8.5.2 Closing Marker	The closing marker MUST match the most recent unclosed opening marker (see §3.6). A qualified closing marker MUST match a qualified opening marker exactly, including the namespace prefix.
2187	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.5 Concept Markers > 8.5.2 Closing Marker	The closing marker MUST appear on its own line after indentation. If the closing marker does not appear on its own line, Codex-conforming tools MUST reject the document with a `SurfaceFormError` (§14).
2189	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.5 Concept Markers > 8.5.2 Closing Marker	Additional content MUST NOT appear on the closing marker line. If additional content appears on the closing marker line, Codex-conforming tools MUST reject the document with a `SurfaceFormError` (§14).
2193	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.5 Concept Markers > 8.5.3 Self-Closing Marker	A self-closing marker MUST be spelled as:
2209	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.5 Concept Markers > 8.5.3 Self-Closing Marker	Whitespace MUST appear immediately before `/>` in a self-closing marker.
2213	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.5 Concept Markers > 8.5.3 Self-Closing Marker	If multiple Traits are present, they MUST be ordered per §8.6.
2217	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.5 Concept Markers > 8.5.4 Empty Block Concepts	Codex-conforming tools MUST reject the form `<ConceptName></ConceptName>` with a `ParseError` (§14).
2221	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.6 Traits	A Trait MUST be spelled as:
2227	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.6 Traits	The `traitName` MUST follow the naming rules defined by this specification (§4.1). If the name does not conform to §4.1, Codex-conforming tools MUST reject the document with a `ParseError` (§14).
2229	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.6 Traits	Whitespace MUST NOT appear around the `=` separator. If whitespace appears around `=`, Codex-conforming tools MUST reject the document with a `SurfaceFormError` (§14).
2231	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.6 Traits	Traits MUST be separated by whitespace (space or newline).
2233	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.6 Traits	If multiple Traits are present, canonical form MUST order them alphabetically by Trait name.
2239	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.6 Traits > 8.6.1 Canonical Trait Formatting	To determine layout, Codex-conforming tools MUST compute the total length of the Concept marker as if all Traits appeared on a single line: leading indentation, the `<` character, the Concept name, a space before each Trait, each `name=value` pair, and the closing `>` or ` />`. For this computation, each tab character (U+0009) MUST be counted as 2 characters.
2241	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.6 Traits > 8.6.1 Canonical Trait Formatting	If the computed length is 100 characters or fewer, all Traits MUST appear on the same line as the Concept marker.
2243	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.6 Traits > 8.6.1 Canonical Trait Formatting	If the computed length exceeds 100 characters, all Traits MUST be stacked: each Trait MUST appear on its own line, indented exactly one nesting level deeper than the Concept marker. The closing `>` or `/>` MUST appear on its own line at the same indentation level as the opening `<`.
2245	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.6 Traits > 8.6.1 Canonical Trait Formatting	A single `name=value` pair MUST NOT be wrapped across lines, even if it exceeds 100 characters.
2247	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.6 Traits > 8.6.1 Canonical Trait Formatting	A Backtick Text Value MUST NOT appear as an inline Trait value. If a Trait value is expressed as a Backtick Text Value, it MUST use its multiline form, which forces the Concept marker into stacked layout. Alternatively, the value MUST be converted to a Quoted Text Value.
2249	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.6 Traits > 8.6.1 Canonical Trait Formatting	If a document violates any formatting rule in this section, Codex-conforming tools MUST reject the document with a `FormattingError` (§14).
2283	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes)	Codex-conforming tools MUST NOT evaluate, interpret, or normalize Values beyond recognizing their Value type and literal structure.
2285	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes)	A Trait value spelling MUST match exactly one Value spelling defined by this specification (see §5).
2287	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes)	If a Trait value spelling does not match any Value spelling defined by this specification, Codex-conforming tools MUST reject it with a `ParseError` (§14).
2289	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes)	Within a Concept marker, a Value MUST terminate at the first of the following:
2294	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes)	While scanning for Value termination, Codex-conforming tools MUST respect balanced delimiters as required by the Value spellings defined in §5, including `[]`, `{}`, `()`, `''`, and `""`.
2296	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes)	Except where permitted by a Value spelling (for example, within text and character literals), leading and trailing whitespace MUST NOT be treated as part of a Value.
2300	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes) > 8.7.1 Value Type Disambiguation	When a maximal Value token (recognized under the termination rules above) could match the spelling rules of more than one Value type, tools MUST resolve the type by deterministic precedence. The Value type MUST be the first match in the following order:
2318	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes) > 8.7.1 Value Type Disambiguation	If a token matches multiple Value type spellings at the same precedence level, tools MUST reject it with a `ParseError` (§14).
2322	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes) > 8.7.2 Multiline Value Literals	Codex-conforming tools MUST accept multiline spellings for Value literals that use balanced delimiters, including list (`[...]`), set (`set[...]`), map (`map[...]`), record (`record[...]`), and tuple (`(...)`).
2326	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes) > 8.7.2 Multiline Value Literals	* Line breaks within a balanced Value literal MUST be treated as whitespace.
2327	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes) > 8.7.2 Multiline Value Literals	* Whitespace between elements, entries, or delimiters MUST NOT be treated as significant.
2328	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes) > 8.7.2 Multiline Value Literals	* Whitespace MUST NOT terminate the Value.
2330	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes) > 8.7.2 Multiline Value Literals	In canonical surface form, exactly one space MUST follow each comma separator within a balanced Value literal. All other optional whitespace within balanced Value literals MUST be removed. Mandatory whitespace required by a specific production MUST be preserved.
2332	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes) > 8.7.2 Multiline Value Literals	Outside of balanced delimiters, a Value literal MUST be fully contained on a single line.
2334	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.7 Values (Surface Parsing Notes) > 8.7.2 Multiline Value Literals	Codex-conforming tools MUST determine Value boundaries solely by balanced delimiter matching and MUST NOT treat line boundaries as semantically significant within a Value literal.
2340	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks	Content MUST NOT be interpreted as Codex structure, Traits, or Values.
2344	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.1 Content Termination	Codex-conforming tools MUST identify the end of content by scanning for the closing marker that matches the opening Concept name: `</ConceptName>`.
2356	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.2 Content Escaping	A raw `<` character MUST NOT appear anywhere in content.
2358	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.2 Content Escaping	A raw `[` character MUST NOT appear as the first non-indentation character of a content line. This preserves schema-less determinism of content-versus-children body mode (see §10.1.1.1).
2360	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.2 Content Escaping	Codex-conforming tools MUST reject violations of these content escaping rules with a `ParseError` (§14).
2364	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.3 Content Indentation Normalization	Codex-conforming tools MUST store and process content without its canonical leading indentation.
2366	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.3 Content Indentation Normalization	In canonical surface form, each non-blank content line MUST be indented exactly one nesting level deeper than its enclosing Concept instance.
2370	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.3 Content Indentation Normalization	Codex-conforming tools MUST remove exactly that canonical leading indentation from each non-blank content line when producing the logical content.
2372	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.3 Content Indentation Normalization	Codex-conforming tools MUST preserve all characters following the removed indentation, including any additional leading whitespace.
2374	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.3 Content Indentation Normalization	If a non-blank content line does not have the required canonical leading indentation after indentation normalization, Codex-conforming tools MUST fail with a `FormattingError` (§14).
2376	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.3 Content Indentation Normalization	Indentation normalization is schema-free and MUST be performed before schema-directed processing.
2380	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.4 Whitespace Mode Normalization	Whitespace mode normalization is schema-directed and MUST be performed during schema-directed processing.
2386	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.4 Whitespace Mode Normalization	* Codex-conforming tools MUST preserve all content whitespace exactly after indentation normalization.
2390	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.4 Whitespace Mode Normalization	* Codex-conforming tools MUST collapse each run of whitespace characters (spaces, tabs, and line breaks) to a single U+0020 SPACE.
2391	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.4 Whitespace Mode Normalization	* Codex-conforming tools MUST trim leading and trailing whitespace from the resulting content.
2392	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.4 Whitespace Mode Normalization	* In canonical surface form, Codex-conforming tools MUST wrap content to lines of at most 100 characters, including canonical indentation, breaking at whitespace boundaries. For this computation, each tab character (U+0009) MUST be counted as 2 characters. If a non-breakable sequence plus its canonical indentation exceeds 100 characters, it MUST appear on its own line without wrapping.
2393	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.4 Whitespace Mode Normalization	* Each wrapped line MUST be indented exactly one nesting level deeper than the enclosing Concept instance.
2395	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.8 Content Blocks > 8.8.4 Whitespace Mode Normalization	Schema-less processing MUST treat all content as `$Preformatted` (preserve all whitespace after indentation normalization).
2466	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations	Codex-conforming tools MUST preserve annotations without interpretation.
2474	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.1 Annotation Forms > 8.9.1.1 Inline Annotation	An inline annotation MUST use `[` and `]` on the same line.
2483	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.1 Annotation Forms > 8.9.1.2 Block Annotation	A block annotation MUST use `[` and `]` on their own lines.
2496	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.1 Annotation Forms > 8.9.1.2 Block Annotation	Annotations MUST be permitted at top-level and within bodies interpreted as containing child Concepts.
2498	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.1 Annotation Forms > 8.9.1.2 Block Annotation	Annotations MUST NOT appear inside Concept markers (that is, inside `<Concept …>`, `</Concept>`, or `<Concept />`).
2502	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.2 Structural Rules	The opening `[` MUST be the first non-whitespace character on its line.
2504	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.2 Structural Rules	For an inline annotation, the closing `]` MUST appear on the same line.
2508	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.2 Structural Rules	* The line containing `[` MUST contain no other non-whitespace characters.
2509	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.2 Structural Rules	* The closing `]` MUST appear as the first non-whitespace character on its own line.
2510	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.2 Structural Rules	* The closing `]` line MUST contain no other non-whitespace characters.
2512	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.2 Structural Rules	If a document violates any structural rule in this section, Codex-conforming tools MUST reject the document with a `SurfaceFormError` (§14).
2529	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.4 Canonical Form > 8.9.4.1 Inline Annotation Canonicalization	Codex-conforming tools MUST canonicalize inline annotations as follows:
2531	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.4 Canonical Form > 8.9.4.1 Inline Annotation Canonicalization	* Leading and trailing whitespace inside the brackets MUST be trimmed.
2532	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.4 Canonical Form > 8.9.4.1 Inline Annotation Canonicalization	* Internal runs of whitespace (spaces and tabs) MUST be collapsed to a single space.
2533	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.4 Canonical Form > 8.9.4.1 Inline Annotation Canonicalization	* Escaped closing brackets MUST remain escaped (that is, `\]` MUST remain spelled as `\]`).
2537	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.4 Canonical Form > 8.9.4.2 Block Annotation Canonicalization	Block annotations MUST preserve their internal line structure.
2539	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.4 Canonical Form > 8.9.4.2 Block Annotation Canonicalization	Codex-conforming tools MUST normalize block-annotation line endings to LF.
2541	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.4 Canonical Form > 8.9.4.2 Block Annotation Canonicalization	For a block annotation with no directive, Codex-conforming tools MUST:
2550	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.5 Block Annotation Directives	If present, the directive line MUST be exactly one of:
2556	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.5 Block Annotation Directives	Directive recognition MUST be performed prior to any canonicalization other than newline normalization.
2558	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.5 Block Annotation Directives	If present, the directive line MUST be preserved in canonical output.
2562	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.5 Block Annotation Directives	* `CODE:` — Codex-conforming tools MUST preserve the block annotation bytes verbatim except for newline normalization.
2563	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.5 Block Annotation Directives	* `MARKDOWN:` — Codex-conforming tools MUST preserve the block annotation bytes verbatim except for newline normalization.
2564	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.5 Block Annotation Directives	* `FLOW:` — Codex-conforming tools MUST trim leading and trailing whitespace from the remaining content, MUST collapse internal runs of whitespace to single spaces, and MUST interpret escapes per §8.9.3.
2566	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.5 Block Annotation Directives	If no directive is present, the block annotation MUST be canonicalized as described in §8.9.4.2.
2568	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.5 Block Annotation Directives	For `FLOW:` directives, Codex-conforming tools MUST render canonical output as follows:
2571	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.5 Block Annotation Directives	* For each paragraph, wrap words to lines using the 100-character line limit defined in §8.8.4, including canonical indentation and counting tabs as 2 characters. If a non-breakable sequence plus its canonical indentation exceeds 100 characters, it MUST appear on its own line without wrapping.
2591	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.6 Annotation Kinds > 8.9.6.1 Attached Annotations	Stacked attached annotations MUST be contiguous and MUST NOT be separated by blank lines.
2602	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.6 Annotation Kinds > 8.9.6.2 Grouping Annotations	`<label>` MUST be non-empty text after trimming.
2604	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.6 Annotation Kinds > 8.9.6.2 Grouping Annotations	Grouping recognition MUST be performed after applying the inline annotation canonicalization rules in §8.9.4.1.
2606	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.6 Annotation Kinds > 8.9.6.2 Grouping Annotations	Label comparison MUST use the canonical label form (trimmed, with internal whitespace collapsed to single spaces).
2608	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.6 Annotation Kinds > 8.9.6.2 Grouping Annotations	Grouping annotations MUST conform to the canonical blank-line requirements in §8.9.8.
2623	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.7 Group Nesting and Matching	* `[END: X]` MUST match the most recent unmatched `[GROUP: X]`.
2625	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.7 Group Nesting and Matching	If an `END` label does not match the most recent open group label, or if an `END` appears with no open group, Codex-conforming tools MUST reject the document with a `ParseError` (§14).
2631	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.8 Canonical Blank Line Requirements	* Attached annotations MUST appear directly above the annotated Concept opening marker with no blank line.
2632	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.8 Canonical Blank Line Requirements	* Grouping and general annotations MUST be surrounded by exactly one blank line above and below, where file boundaries count as blank-line boundaries.
2634	Codex Language Specification — Version 1.0.0 > 8. Surface Form > 8.9 Annotations > 8.9.8 Canonical Blank Line Requirements	If an annotation does not qualify as an attached annotation, a grouping annotation, or a general annotation, Codex-conforming tools MUST reject the document with a `ParseError` (§14).
2640	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture	A conforming implementation MUST provide schema-directed validation.
2644	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture	Canonical Authoring Mode permits authors to write the canonical RDF representation directly. Simplified Authoring Mode permits authors to write a Codex-native surface form that has no independent semantics and exists only as a deterministic, lossless authoring convenience; documents written in Simplified Authoring Mode MUST expand to a byte-identical canonical RDF representation.
2646	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture	No other semantic layers, representations, or interpretive stages exist in Codex, and implementations MUST treat the canonical RDF representation as the sole source of truth.
2650	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.1 Scope and Inputs	Given the same required inputs, a conforming implementation MUST produce the same validation and canonicalization results.
2659	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.1 Scope and Inputs	Other external inputs—including environment state, configuration, registries, network access, clocks, or randomness—MUST NOT influence processing.
2661	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.1 Scope and Inputs	If any required input is missing, schema-directed processing MUST fail with a `SchemaError` (§14).
2663	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.1 Scope and Inputs	Given a Codex document and a governing schema, a conforming implementation MUST dispatch validation according to that schema.
2667	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.2 Schema-Less Formatting / Well-Formedness Checks	Schema-less checks MUST be limited to rules that are explicitly defined by this specification as independent of schema semantics.
2677	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.2 Schema-Less Formatting / Well-Formedness Checks	Without a governing schema, an implementation MUST NOT:
2686	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.3 Schema-Required Semantic Validation	An implementation MUST NOT perform semantic validation without a governing schema.
2688	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.3 Schema-Required Semantic Validation	Given a governing schema, an implementation MUST perform semantic validation as defined by that schema.
2690	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.3 Schema-Required Semantic Validation	Schema-driven semantic validation MUST be traceable to the specific schema rule(s) applied.
2692	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.3 Schema-Required Semantic Validation	Schema-driven semantic validation MUST include evaluation of all schema-defined authorizations and constraints:
2706	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	A schema document MUST be validated under exactly one authoring mode.
2713	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	All conforming implementations MUST support both authoring modes.
2715	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	The schema document's root `Schema` concept MUST have an `authoringMode` trait.
2717	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	`authoringMode` MUST be exactly one of `$SimplifiedMode` or `$CanonicalMode`; any other value or a missing `authoringMode` trait is a `SchemaError` (§14).
2719	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	The following mode-specific constraints MUST hold:
2721	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	- Simplified mode schemas MUST contain exactly one `ConceptDefinitions` and MUST NOT contain `RdfGraph`.
2722	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	- Canonical mode schemas MUST contain exactly one `RdfGraph` and MUST NOT contain Codex-native schema-definition concepts (including `ConceptDefinitions`, `TraitDefinitions`, `EnumeratedValueSets`, `ConstraintDefinitions`, `ValueTypeDefinitions`, and `ValidatorDefinitions`).
2723	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	- Simplified-mode expansion MUST generate the Canonical Representation as a canonical RDF graph; different simplified spellings that are semantically identical MUST expand to byte-identical canonical RDF graphs.
2724	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	- Canonicalization of the Canonical Representation MUST make semantically identical graphs byte-identical.
2730	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface)	To support a total, deterministic projection to derived validation artifacts, simplified-mode schema authoring MUST support the following extensions.
2734	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.1 Pattern Flags	The following atomic constraints MUST support an optional `flags` trait whose value is text:
2740	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.1 Pattern Flags	If `flags` is omitted, it MUST be treated as empty text.
2742	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.1 Pattern Flags	The `pattern` and `flags` semantics MUST be SPARQL 1.1 `REGEX` semantics.
2746	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	Simplified Authoring Mode MUST support explicit validator definitions that make `ValueIsValid` deterministic.
2754	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	Each `ValidatorDefinition` MUST have these traits:
2760	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	`ValidatorDefinition` names MUST be unique within the Schema.
2762	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	Each `ValidatorDefinition` MUST be in content mode.
2764	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	The content of `ValidatorDefinition` MUST be a SPARQL `SELECT` query text.
2766	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	The `SELECT` results MUST follow the SHACL-SPARQL convention (returning one row per violation with `?this` bound to the focus node).
2768	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	If a derived validation artifact is expressed using SHACL-SPARQL, the embedding contract for `ValueIsValid validatorName=$X` MUST be:
2773	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	If `$X` cannot be resolved to exactly one `ValidatorDefinition`, schema processing MUST fail with a `SchemaError` (§14).
2779	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	To produce a total, deterministic mapping, Simplified Authoring Mode MUST provide explicit rule-node forms that bind exactly one path to exactly one nested rule.
2781	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	Simplified Authoring Mode MUST provide the following rule nodes:
2787	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	Each of these MUST have exactly one `Path` child and exactly one `Rule` child.
2789	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	`OnPathCount` MUST additionally have:
2794	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	The `Path` child MUST be exactly one of:
2801	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	`ChildSatisfies(conceptSelector=X, Rule=R)` MUST be interpreted as equivalent to `OnPathForAll(Path=ChildPath(X), Rule=R)`.
2814	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	the constraint node MUST have exactly one `Path` child that selects the collection members the constraint applies to.
2816	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	That member-selection path MUST be either `ChildPath` or `DescendantPath`.
2818	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	If the member-selection path is not one of these, expansion MUST fail with a `SchemaError` (§14).
2820	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	For `CollectionAllowsDuplicates` with `allowed=false`, the constraint node MUST include a required `keyTrait` trait whose value is a Trait name.
2822	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	If `keyTrait` is `id`, it MUST refer to the declared identifier as specified by the instance-graph identity rules.
2828	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL)	The Canonical Representation MUST be deterministic and canonical:
2830	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL)	- The Canonical Representation MUST NOT contain RDF blank nodes.
2831	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL)	- All RDF nodes in the Canonical Representation MUST be IRIs.
2832	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL)	- Where SHACL commonly uses blank nodes (for example, `sh:property` values and RDF lists), the Canonical Representation MUST use deterministically derived skolem IRIs instead.
2833	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL)	- The Canonical Representation MUST be treated as a set of RDF triples.
2834	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL)	- The Canonical Representation MUST NOT contain duplicate triples.
2838	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.1 Canonical Triple Form	When the Canonical Representation is authored as a Codex graph form, it MUST use:
2843	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.1 Canonical Triple Form	`RdfGraph` MUST be in children mode.
2845	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.1 Canonical Triple Form	`RdfGraph` children MUST include one or more `RdfTriple`. `RdfGraph` children MUST be `RdfTriple` children and annotations only; no other Concept children are allowed.
2847	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.1 Canonical Triple Form	Each `RdfTriple` MUST have these traits:
2862	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.1 Canonical Triple Form	If `language` is present, `datatype` MUST be absent.
2864	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.1 Canonical Triple Form	If `datatype` is absent and `language` is absent, the literal datatype MUST be `xsd:string`.
2870	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	`objectKey` MUST be:
2875	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	`datatypeOrDefault` MUST be: `datatype` if present; otherwise `rdf:langString` if `language` is present; otherwise `xsd:string`.
2877	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	`languageOrEmpty` MUST be: `language` if present; otherwise the empty string.
2879	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	If two triples have identical sort keys, the duplicate MUST be removed.
2881	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	When an `RdfGraph` contains no grouping annotations (§8.9.7), all `RdfTriple` children MUST be sorted by sort key.
2885	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	1. Within each group, `RdfTriple` children MUST be sorted by sort key.
2886	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	2. Groups at the same nesting level MUST be sorted in ascending lexicographic order of their canonical group label.
2887	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	3. `RdfTriple` children not enclosed in any group MUST be sorted by sort key and MUST appear before all groups at the same nesting level.
2888	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	4. An attached annotation (§8.9.6.1) on an `RdfTriple` MUST move with that triple during sorting.
2892	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.3 RDF List Encoding (No Blank Nodes)	If the Canonical Representation includes an RDF list (for example, as the object of `sh:in`), it MUST be encoded using the standard RDF list vocabulary (`rdf:first`, `rdf:rest`, `rdf:nil`).
2894	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.3 RDF List Encoding (No Blank Nodes)	All RDF list nodes MUST be IRIs.
2896	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.3 RDF List Encoding (No Blank Nodes)	Where the RDF list encoding would otherwise use blank nodes, the Canonical Representation MUST use deterministically derived skolem IRIs instead.
2898	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.3 RDF List Encoding (No Blank Nodes)	At most one RDF list MUST be attached as the object of triples sharing a given `(subject, predicate)` pair.
2900	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.3 RDF List Encoding (No Blank Nodes)	For an RDF list attached as the object of a triple `(subject, predicate, _)`, list node IRIs MUST be derived as follows:
2905	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.3 RDF List Encoding (No Blank Nodes)	- The final list node's `rdf:rest` MUST be `rdf:nil`.
2909	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.4 Deterministic IRI Hashing	When a derived IRI embeds another IRI or name as a path component, the embedded value MUST be hashed to produce fixed-length, path-safe text.
2911	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.4 Deterministic IRI Hashing	`iriHash(value)` MUST be computed as:
2919	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.5 Deterministic Derived IRIs (One Way To Say It)	To preserve "one way to say it", every derived IRI used by schema processing, instance graph mapping, and derived validation artifact generation MUST be computed by a single deterministic algorithm.
2930	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.6 Node Shape IRIs	The node shape IRI for a concept class IRI `K` MUST be deterministically derived as:
2936	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.7 Property Shape IRIs	Each property shape MUST have a deterministic IRI.
2952	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.8 Document Node Shape IRI	The document node shape IRI MUST be deterministically derived as:
2958	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.9 SPARQL Constraint IRIs	Each SHACL-SPARQL constraint node emitted for a `ConstraintDefinition` MUST have a deterministic IRI.
2968	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping	The mapping MUST be deterministic and MUST NOT use RDF blank nodes.
2972	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping	If `documentBaseIri` is missing, the mapping MUST fail with a `SchemaError` (§14).
2976	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.1 Document Node	The instance graph MUST include a single document node.
2978	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.1 Document Node	The RDF node IRI for the Document context MUST be exactly `documentBaseIri`.
2982	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.2 Node Identity and Declared Identifiers	Each Concept instance in the Codex document MUST map to exactly one RDF node whose identity is a deterministic skolem IRI derived from its structural position within the document. The `codex:` prefix used in this section is shorthand; full IRI derivations are defined in §9.7.5.
2999	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.2 Node Identity and Declared Identifiers > 9.7.2.1 Skolem IRI Derivation (`nodeIri`)	`ordinalIndex(C)` MUST be zero-based.
3001	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.2 Node Identity and Declared Identifiers > 9.7.2.1 Skolem IRI Derivation (`nodeIri`)	`ordinalIndex(C)` MUST be expressed in base-10 with no leading zeros (except that `0` is permitted).
3011	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.2 Node Identity and Declared Identifiers > 9.7.2.1 Skolem IRI Derivation (`nodeIri`)	The RDF node IRI MUST NOT be derived from the Concept instance's declared `id` trait value.
3013	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.2 Node Identity and Declared Identifiers > 9.7.2.1 Skolem IRI Derivation (`nodeIri`)	If a Concept instance declares an `id` trait, that declared identifier MUST be represented as data via a dedicated predicate `codex:declaredId`.
3015	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.2 Node Identity and Declared Identifiers > 9.7.2.1 Skolem IRI Derivation (`nodeIri`)	If a concept instance `C` declares an `id` trait with value `v`, the mapping MUST emit:
3021	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.3 Entity Marker	If and only if a Concept instance is an Entity, the mapped RDF node MUST be marked as an Entity using a dedicated predicate `codex:isEntity`.
3023	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.3 Entity Marker	The mapping MUST emit an entity marker for every Concept instance node:
3030	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.4 Parent Link and Ordered Children	For each non-root Concept instance, the instance graph MUST include a parent link using a dedicated predicate `codex:parentNode`.
3032	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.4 Parent Link and Ordered Children	For each parent Concept instance `C` and each direct child Concept instance `D`, the instance graph MUST emit:
3036	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.4 Parent Link and Ordered Children	For each child Concept instance `D` of parent Concept instance `C`, the instance graph MUST emit the structural child triple:
3040	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.4 Parent Link and Ordered Children	The instance graph MUST additionally represent the ordered child sequence using explicit edge nodes that carry a stable numeric index (see §9.7.6).
3068	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	Their IRIs MUST be deterministically derived from `schemaIri` as follows:
3070	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:parent` MUST be `schemaIri + "#codex/parent"`
3071	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:child` MUST be `schemaIri + "#codex/child"`
3072	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:index` MUST be `schemaIri + "#codex/index"`
3073	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:parentNode` MUST be `schemaIri + "#codex/parentNode"`
3074	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:isEntity` MUST be `schemaIri + "#codex/isEntity"`
3075	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:declaredId` MUST be `schemaIri + "#codex/declaredId"`
3076	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:content` MUST be `schemaIri + "#codex/content"`
3077	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:annotationParent` MUST be `schemaIri + "#codex/annotationParent"`
3078	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:annotationIndex` MUST be `schemaIri + "#codex/annotationIndex"`
3079	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:annotationText` MUST be `schemaIri + "#codex/annotationText"`
3080	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:annotationForm` MUST be `schemaIri + "#codex/annotationForm"`
3081	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:annotationKind` MUST be `schemaIri + "#codex/annotationKind"`
3082	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:annotationDirective` MUST be `schemaIri + "#codex/annotationDirective"`
3083	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:annotationTarget` MUST be `schemaIri + "#codex/annotationTarget"`
3084	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:mapKey` MUST be `schemaIri + "#codex/mapKey"`
3085	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:mapValue` MUST be `schemaIri + "#codex/mapValue"`
3086	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:rangeStart` MUST be `schemaIri + "#codex/rangeStart"`
3087	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:rangeEnd` MUST be `schemaIri + "#codex/rangeEnd"`
3088	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:rangeStep` MUST be `schemaIri + "#codex/rangeStep"`
3098	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.6 Ordered Children Encoding	The mapping MUST emit an edge node `e` and three triples:
3104	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.6 Ordered Children Encoding	The edge node IRI MUST be:
3115	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.7 Annotation Nodes	The mapping MUST emit an annotation edge node `e` with the following triples:
3123	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.7 Annotation Nodes	The annotation edge node IRI MUST be:
3127	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.7 Annotation Nodes	If the annotation has a block directive (§8.9.5), the mapping MUST additionally emit:
3133	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.7 Annotation Nodes	If the annotation is an attached annotation (§8.9.6.1), the mapping MUST additionally emit:
3139	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	For each trait `t=v` on a concept instance `C`, the instance graph MUST emit exactly one triple:
3145	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	- If `t` is `id`, the mapping MUST NOT emit a `traitPredicateIri("id")` triple.
3146	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	- Instead, `id` MUST be represented only by `codex:declaredId`, with the `id` value as an IRI (not a literal).
3148	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	Because `id` has no `traitPredicateIri` representation in the instance graph, schema definitions MUST NOT target `id` through generic trait mechanisms (`TraitRules`, `TraitPath`, `TraitExists`, `TraitMissing`, `TraitEquals`). The `id` trait is governed by `entityEligibility` (§6.1) and identity constraints (§9.9.6, §9.9.7). If a generic trait mechanism references `id`, derived validation artifact generation MUST fail with a `SchemaError` (§14).
3150	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	`valueTerm(v)` MUST be:
3157	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	For typed literals, the datatype IRI MUST be computed by `valueDatatypeIri(v)` and the lexical form MUST be computed by `valueLex(v)`.
3159	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	Both `valueDatatypeIri(v)` and `valueLex(v)` MUST be derived by parsing `v` according to the Codex value catalog.
3161	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	`valueDatatypeIri(v)` MUST be:
3168	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	For all other scalar value types, `valueDatatypeIri(v)` MUST be the deterministic URN:
3176	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	`valueLex(v)` MUST be:
3183	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	For all other scalar value types, `valueLex(v)` MUST be the canonical surface spelling of `v`.
3185	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	Lookup Token Values MUST be represented as typed literals with:
3190	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	When an Enumerated Token Value `v` appears on a trait that is constrained by an `EnumeratedValueSet` `E` (via `AllowedValues` containing an `EnumeratedConstraint` referencing `E`), `valueTerm(v)` MUST be the IRI:
3202	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	If a schema constraint requires an interpreted value (for example, numeric comparisons or text length), schema processing MUST provide the interpreted value in a deterministic RDF representation.
3206	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	When a trait value `v` is a collection (List, Set, Map, Record, Tuple, or Range), `valueTerm(v)` MUST NOT be a typed literal. Instead, the value MUST be represented as a structured collection graph using the standard RDF list vocabulary (`rdf:first`, `rdf:rest`, `rdf:nil`) and reserved Codex predicates.
3208	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	All collection graph nodes MUST be IRIs. No blank nodes are permitted (§9.6.1).
3217	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	List node IRIs MUST follow the same pattern as §9.6.3:
3221	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	The list head node is at position 0. `valueTerm(v)` for the trait MUST be `listNodeIri(collectionAnchor, 0)`.
3223	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	If the collection is empty (zero elements), `valueTerm(v)` MUST be `rdf:nil`.
3229	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	For each position `i` from 0 to n-1, the mapping MUST emit:
3236	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	Sets use the same RDF list encoding as Lists. Element order in the RDF list MUST match canonical source order (§5.14).
3242	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	For each position `i` from 0 to n-1, let `entryIri = listNodeIri(collectionAnchor, i) + "/__entry"`. The mapping MUST emit:
3249	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	Entry order in the RDF list MUST match canonical source order.
3253	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	For a Range `start..end` (with optional step), let the components be `start`, `end`, and (if present) `step`. A Range MUST be encoded as a single RDF resource (not a list). Let `rangeIri = nodeIri(C) + "/range/" + iriHash(traitPredIri)`. The mapping MUST emit:
3259	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	`valueTerm(v)` for a Range MUST be `rangeIri`.
3263	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	Each element `e` within a collection MUST be mapped to an RDF term as follows:
3265	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	- If `e` is an IRI Reference Value, `elementTerm(e)` MUST be the IRI.
3266	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	- If `e` is an Enumerated Token Value and the governing trait is constrained by an `EnumeratedValueSet` `E`, `elementTerm(e)` MUST be the IRI `E.id + "#" + tokenName(e)`.
3267	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	- If `e` is a nested collection (List, Set, Map, Record, Tuple, or Range), `elementTerm(e)` MUST be the head IRI of the nested collection's graph. Let `nestedAnchor = listNodeIri(collectionAnchor, i) + "/__value"`, where `i` is the position of the element in the parent collection. For nested List, Set, Map, Record, or Tuple collections, the nested collection anchor is `nestedAnchor` and the list head IRI is `nestedAnchor + "/0"`. For a nested Range, the range IRI is `nestedAnchor` directly. The nested collection graph MUST be emitted following the same rules defined in this section.
3268	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	- Otherwise, `elementTerm(e)` MUST be the typed literal `valueLex(e)^^valueDatatypeIri(e)`, using the scalar rules defined in §9.7.8.
3270	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	This rule replaces the typed-literal representation for collection values. A collection value on a trait MUST always produce a collection graph; it MUST NOT produce a typed literal.
3274	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.9 Content	If a concept instance is in content mode, the mapping MUST emit:
3278	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.9 Content	`contentText` MUST be an `xsd:string` literal containing the concept's content after applying the Codex content escaping rules.
3282	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	Trait predicate IRIs MUST be derived as follows.
3286	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	- If the governing schema contains exactly one `TraitDefinition` for `t`, `traitPredicateIri(t)` MUST be that `TraitDefinition`'s `id`.
3287	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	- If an imported schema contains the `TraitDefinition` for `t` (resolved via a qualified Trait name in the governing schema's `ConceptDefinition`), `traitPredicateIri(t)` MUST be the imported schema's `TraitDefinition.id` for `t`.
3288	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	- If the governing schema contains zero `TraitDefinition` entries for `t` (including imported schemas), validation MUST fail with a `SchemaError` (§14).
3289	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	- If the governing schema contains more than one `TraitDefinition` for `t`, validation MUST fail with a `SchemaError` (§14).
3291	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	Child predicate IRIs MUST be derived as follows.
3295	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	- `childPredicateIri(P,Q)` MUST be `P + "#child/" + iriHash(Q)`.
3297	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	When the child Concept `Q` is from an imported schema (referenced via a qualified Concept name per §4.1.1), `Q` MUST be the `ConceptDefinition.id` from the imported schema. The child predicate IRI derivation MUST use the imported schema's `ConceptDefinition.id`.
3301	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.11 RDF Types	Each Concept instance MUST emit an RDF type triple:
3305	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.11 RDF Types	`conceptClassIri(X)` MUST be the `ConceptDefinition.id` for concept name `X` in the governing schema, or in the imported schema if `X` is a qualified Concept name (§4.1.1).
3307	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.11 RDF Types	If `conceptClassIri(X)` cannot be resolved to exactly one `ConceptDefinition`, schema-driven validation MUST fail with a `SchemaError` (§14).
3313	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.12 Conformance Graph (`G₁`)	A conforming implementation MUST emit `G₁` in the Codex `RdfGraph` form defined in §9.6.1 and MUST apply the canonical ordering and duplicate-removal rules defined in §9.6.2.
3321	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.1 Resolution Table	The resolution table MUST be constructed solely from explicit `key` and `id` trait declarations. Resolution entries MUST NOT be inferred, synthesized, or imported implicitly.
3327	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.2 Resolution Semantics	* A lookup token MUST resolve to exactly one identifier in the resolution table.
3328	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.2 Resolution Semantics	* If no matching entry is found for a required lookup token, validation MUST fail with a `ReferenceError` (§14).
3330	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.2 Resolution Semantics	Lookup token resolution is declarative only and MUST NOT imply loading, dereferencing, or execution.
3334	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.3 Schema Interaction	A governing schema MUST specify, for each context where lookup token values are permitted, one of the following resolution requirements:
3336	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.3 Schema Interaction	* The lookup token MUST be resolvable.
3337	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.3 Schema Interaction	* The lookup token MUST NOT appear in the context.
3338	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.3 Schema Interaction	* The lookup token MUST pass through without resolution.
3342	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	Derived validation artifacts MUST be generated deterministically.
3344	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	Any derived validation artifact MUST be a pure function of:
3349	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	Derived validation artifact generation MUST fail with a `SchemaError` (§14) if any of the following hold:
3357	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	Derived validation artifacts MUST be expressed as SHACL, including SHACL-SPARQL constraints.
3359	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	A derived SHACL artifact MUST apply each constraint to the target node shape(s) determined as follows:
3361	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- For `TargetConcept conceptSelector="X"`, the constraint MUST be applied to the node shape derived from the `ConceptDefinition` whose `name` is `X`.
3362	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- For `TargetContext contextSelector="Document"`, the constraint MUST be applied to a special node shape with IRI `schemaIri + "#shape/Document"` and MUST include at least:
3365	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	If `documentBaseIri` is not available as an external input, derived validation artifact generation MUST fail with a `SchemaError` (§14).
3366	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- If `contextSelector` is a concept name (not `Document`), the constraint MUST be applied to the node shape for that concept.
3368	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	If a derived validation artifact is produced as a SHACL graph, it MUST be canonical and MUST include the following structural shape triples:
3370	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- For each `ConceptDefinition` in the governing schema with concept name `X`, let `K = conceptClassIri(X)` and let `S = nodeShapeIri(K)`. The derived artifact MUST include:
3373	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- If the derived artifact includes any constraint expressed on a property shape `PS`, it MUST include:
3376	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	and `PS` MUST be deterministically derived as follows:
3377	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- for a trait name `t`: `PS = propertyShapeIri(S,t)` and the artifact MUST include `(PS, sh:path, traitPredicateIri(t))`
3378	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- for a child class IRI `Q`: `PS = propertyShapeIri(S,Q)` and the artifact MUST include `(PS, sh:path, childPredicateIri(K,Q))`
3379	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- for a predicate IRI `p`: `PS = predicatePropertyShapeIri(S,p)` and the artifact MUST include `(PS, sh:path, p)`
3381	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	If a derived validation artifact expresses any constraint using SHACL-SPARQL, the `sh:select` text MUST be a SPARQL 1.1 `SELECT` query that returns one row per violating focus node using the SHACL-SPARQL convention:
3383	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- the focus node variable MUST be `?this`
3384	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- a row returned by the query MUST indicate a violation
3386	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	SPARQL text in derived artifacts MUST be canonically formatted. Internal SPARQL variables introduced during constraint translation MUST be allocated as follows:
3390	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- Any internal variable introduced while translating that node MUST append suffix `$k$` to a base name.
3391	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- Variables introduced for one rule node MUST NOT be referenced outside the `EXISTS { ... }` block created for that node.
3395	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.1 Enumerated Value Sets (`sh:in`)	A derived SHACL artifact encoding an enumerated value-set constraint MUST emit a triple `(PS, sh:in, listHead)` on the property shape `PS`.
3397	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.1 Enumerated Value Sets (`sh:in`)	The list encoding MUST conform to §9.6.3.
3401	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.2 Pattern Constraints (`sh:pattern`, `sh:flags`)	A derived SHACL artifact encoding a pattern constraint MUST emit a triple `(PS, sh:pattern, p)` on the property shape `PS`.
3403	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.2 Pattern Constraints (`sh:pattern`, `sh:flags`)	When `flags` is present and non-empty, the artifact MUST also emit a triple `(PS, sh:flags, f)`.
3405	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.2 Pattern Constraints (`sh:pattern`, `sh:flags`)	The `pattern` and `flags` semantics MUST be SPARQL 1.1 `REGEX` semantics (see §9.5.1).
3409	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.3 SHACL Core Value Constraints	A derived SHACL artifact encoding a value-length constraint on a property shape `PS` MUST emit:
3414	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.3 SHACL Core Value Constraints	A derived SHACL artifact encoding a non-empty constraint on a property shape `PS` MUST emit:
3418	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.3 SHACL Core Value Constraints	A derived SHACL artifact encoding a numeric-range constraint on a property shape `PS` MUST use SHACL Core numeric bounds. The active value datatype MUST be `xsd:integer`; any other active datatype is a `SchemaError` (§14).
3420	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.3 SHACL Core Value Constraints	The artifact MUST emit:
3429	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.4 Child Constraints	A derived SHACL artifact encoding a required-child constraint for a child concept selector `X` on a property shape `PS` MUST emit:
3435	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.4 Child Constraints	A derived SHACL artifact encoding a forbidden-child constraint for a child concept selector `X` on a property shape `PS` MUST emit:
3440	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.4 Child Constraints	An allowed-without-required child relationship MUST NOT produce a constraint in the derived SHACL artifact.
3444	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.5 Content Constraints	For content constraints, let `S` be the owning node shape. The property shape IRI MUST be `PS = predicatePropertyShapeIri(S, codex:content)`.
3446	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.5 Content Constraints	A derived SHACL artifact encoding a content-required constraint MUST emit:
3451	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.5 Content Constraints	A derived SHACL artifact encoding a content pattern constraint MUST emit:
3456	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.5 Content Constraints	When `flags` is present and non-empty, the artifact MUST also emit `(PS, sh:flags, f)`.
3458	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.5 Content Constraints	The `pattern` and `flags` semantics MUST be SPARQL 1.1 `REGEX` semantics (see §9.5.1).
3462	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	For identity constraints, let `S` be the owning node shape. The property shape IRI MUST be `PS = predicatePropertyShapeIri(S, codex:isEntity)`.
3464	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	A derived SHACL artifact encoding an identity constraint requiring an entity MUST emit:
3469	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	A derived SHACL artifact encoding an identity constraint requiring a non-entity MUST emit:
3474	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	Derived validation artifacts MUST support `IdentityConstraint(type=IdentifierUniqueness, scope=S)`.
3476	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	The `scope` trait MUST be present. For derived artifact purposes, `IdentityConstraint(type=IdentifierUniqueness, scope=S)` MUST be treated as `UniqueConstraint(trait=id, scope=S)` and MUST follow §9.9.7.
3478	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	Derived validation artifacts MUST support `IdentityConstraint(type=IdentifierForm, pattern=p, flags=f)`.
3480	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	This constraint MUST be expressed using SHACL-SPARQL.
3481	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	It MUST report a violation if the focus node is an Entity and either:
3486	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	The SHACL-SPARQL constraint MUST use the following boolean condition:
3497	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	where `p` is the required pattern and `f` is the flags text if present. When `flags` is absent, the generated constraint MUST use the 2-argument `REGEX(text, pattern)` form.
3501	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.7 Uniqueness Constraints	Derived validation artifacts MUST support the `UniqueConstraint` constraint (§11.9.4).
3503	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.7 Uniqueness Constraints	When a uniqueness constraint refers to `t = id`, it MUST refer to the declared identifier as represented by `codex:declaredId`.
3505	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.7 Uniqueness Constraints	For nearest-scope uniqueness, `UniqueConstraint(trait=t, scope=S)` MUST mean:
3519	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.7 Uniqueness Constraints	Derived validation artifact generation MUST fail with a `SchemaError` (§14) if no nearest scope node exists.
3521	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.7 Uniqueness Constraints	Derived validation artifacts MUST also enforce the document-wide uniqueness invariants for `id` (§6.2.2) and `key` (§6.3.2). Within a single document, two nodes MUST NOT share the same value for `codex:declaredId`, and two nodes MUST NOT share the same `key` trait value.
3525	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.8 Context Constraints	Derived validation artifacts MUST express `ContextConstraint(type=OnlyValidUnderParent)`.
3527	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.8 Context Constraints	The `contextSelector` trait MUST NOT be present. The SHACL-SPARQL constraint MUST use the following boolean condition:
3536	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.8 Context Constraints	Derived validation artifacts MUST express `ContextConstraint(type=OnlyValidUnderContext, contextSelector=A)`.
3538	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.8 Context Constraints	The `contextSelector` trait MUST be present. The SHACL-SPARQL constraint MUST use the following boolean condition:
3549	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.9 Reference Constraints (Reference Trait Predicates)	The set of reference-trait predicates MUST be exactly:
3555	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.9 Reference Constraints (Reference Trait Predicates)	Derived validation artifacts MUST support `ReferenceConstraint(type=ReferenceSingleton)`. The constraint MUST report a violation when more than one reference-trait predicate is present on the same focus node.
3557	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.9 Reference Constraints (Reference Trait Predicates)	Derived validation artifacts MUST support `ReferenceConstraint(type=ReferenceTraitAllowed)`. The constraint MUST provide a `traitName` trait whose value is one of `reference`, `target`, or `for`; a missing or invalid `traitName` is a `SchemaError` (§14).
3561	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	For the purposes of reference constraints, a reference value `v` MUST be one of:
3566	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	Given a reference value `v`, its resolved IRI `r` MUST be computed as follows:
3571	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	- Otherwise, `v` MUST be treated as unresolved.
3572	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	- Otherwise, `v` MUST be treated as unresolved.
3574	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	Derived validation artifacts MUST support `ReferenceConstraint(type=ReferenceTargetsEntity)`.
3576	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	`ReferenceTargetsEntity` MUST mean:
3579	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	- A violation MUST be reported if `v` is treated as unresolved.
3580	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	- A violation MUST be reported unless there exists a node `n` in the same Document such that:
3586	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.11 Reference Constraints (Targets a Concept)	Derived validation artifacts MUST support `ReferenceConstraint(type=ReferenceTargetsConcept, conceptSelector=X)`.
3588	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.11 Reference Constraints (Targets a Concept)	`ReferenceTargetsConcept` MUST mean:
3591	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.11 Reference Constraints (Targets a Concept)	- A violation MUST be reported if `v` is treated as unresolved.
3592	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.11 Reference Constraints (Targets a Concept)	- A violation MUST be reported unless there exists a node `n` in the same Document such that:
3598	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.12 Reference Constraints (Must Resolve)	Derived validation artifacts MUST support `ReferenceConstraint(type=ReferenceMustResolve)`.
3600	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.12 Reference Constraints (Must Resolve)	`ReferenceMustResolve` MUST mean:
3603	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.12 Reference Constraints (Must Resolve)	- A violation MUST be reported if `v` is treated as unresolved.
3604	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.12 Reference Constraints (Must Resolve)	- A violation MUST be reported unless there exists a node `n` in the same Document such that `(n, codex:declaredId, r)` holds.
3606	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.12 Reference Constraints (Must Resolve)	The projection of a derived validation artifact to a concrete RDF syntax MUST be exactly:
3613	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.10 Failure Rules (No Guessing)	Schema processing, schema-driven validation, instance-graph mapping, and derived-artifact projection MUST fail with an appropriate error rather than guess when required information is missing or ambiguous.
3615	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.10 Failure Rules (No Guessing)	Processing MUST fail in any of the following cases:
3634	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.2 Preconditions	The expansion MUST fail with a `SchemaError` (§14) if any precondition defined in §9.9 is violated.
3654	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.4 TraitRules → SHACL Property Shapes	The expansion MUST emit one SHACL property shape node `PS` with:
3660	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.4 TraitRules → SHACL Property Shapes	`PS` MUST be `propertyShapeIri(NS, t)`.
3664	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.4 TraitRules → SHACL Property Shapes	- `RequiresTrait` MUST emit `(PS, sh:minCount, "1"^^xsd:integer)`.
3665	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.4 TraitRules → SHACL Property Shapes	- `ForbidsTrait` MUST emit `(PS, sh:maxCount, "0"^^xsd:integer)`.
3669	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.4 TraitRules → SHACL Property Shapes	- When a value type token maps to an RDF datatype IRI, the expansion MUST emit `(PS, sh:datatype, datatypeIri)`.
3670	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.4 TraitRules → SHACL Property Shapes	- When a value type token constrains by enumerated set, the expansion MUST emit `(PS, sh:in, listNodeIri)` and MUST emit the RDF list structure using deterministic skolem IRIs (see §9.6.3).
3672	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.4 TraitRules → SHACL Property Shapes	Any value-type token without a defined mapping MUST cause expansion failure with a `SchemaError` (§14).
3678	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.5 ChildRules → SHACL Property Shapes	The expansion MUST emit one SHACL property shape node `PS` with:
3684	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.5 ChildRules → SHACL Property Shapes	`PS` MUST be `propertyShapeIri(NS, Q)`.
3688	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.5 ChildRules → SHACL Property Shapes	- `RequiresChildConcept` MUST emit `(PS, sh:minCount, "1"^^xsd:integer)`.
3689	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.5 ChildRules → SHACL Property Shapes	- `ForbidsChildConcept` MUST emit `(PS, sh:maxCount, "0"^^xsd:integer)`.
3691	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.5 ChildRules → SHACL Property Shapes	When the child relationship restricts child type, the expansion MUST emit `(PS, sh:class, Q)`.
3695	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints	ConstraintDefinitions MUST expand to SHACL constraints.
3699	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.1 General Rule	Each Codex constraint type defined by the schema-definition specification MUST map to either:
3704	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.1 General Rule	If a constraint type cannot be expressed without inventing semantics not defined by this specification and the schema-definition specification, expansion MUST fail with a `SchemaError` (§14).
3706	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.1 General Rule	Atomic constraint mappings that are defined by this specification MUST follow §9.9.
3712	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total)	If the rule algebra tree contains an atomic constraint whose required mapping is undefined, expansion MUST fail with a `SchemaError` (§14).
3716	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	For any `ConstraintDefinition`, expansion MUST emit exactly one SHACL-SPARQL constraint query per target shape.
3718	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	The query MUST be a `SELECT` query that returns one row per violating focus node using the SHACL-SPARQL convention:
3720	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	- The focus node variable MUST be `?this`.
3721	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	- A row returned by the query MUST indicate a violation.
3723	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	The query MUST have the following canonical structure:
3733	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	`<TARGET_BINDING>` MUST bind `?this` to the set of focus nodes implied by the constraint's targets.
3735	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	The target binding MUST be:
3742	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	If target binding cannot be expressed without ambiguity (for example, the target selector is not resolvable), expansion MUST fail with a `SchemaError` (§14).
3744	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	`<HOLD_EXPR>` MUST be computed by the function `H(rule, ctx, focusVar)` defined below, with `focusVar` set to `?this`.
3748	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.2 Deterministic Variable Allocation	Expansion MUST allocate internal variable names deterministically.
3750	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.2 Deterministic Variable Allocation	Expansion MUST walk the rule tree in pre-order.
3752	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.2 Deterministic Variable Allocation	For the k-th node visited (1-indexed), the expansion context `ctx` MUST define a node-local suffix `k`.
3754	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.2 Deterministic Variable Allocation	Any internal variable introduced while translating that node MUST be named by appending `k` to a base name.
3761	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.2 Deterministic Variable Allocation	Variables introduced for one rule node MUST NOT be referenced outside the `EXISTS { ... }` block created for that node.
3767	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.3 The `H(rule, ctx, focusVar)` Function	If `focusVar` is omitted, it MUST be `?this`.
3769	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.3 The `H(rule, ctx, focusVar)` Function	`H(rule, ctx, focusVar)` MUST be computed as follows.
3799	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.4 Atomic Rules as `EXISTS` Blocks	If `rule` is atomic, `H(rule, ctx, focusVar)` MUST be a SPARQL `EXISTS { ... }` form or an `EXISTS`-free boolean constant.
3801	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.4 Atomic Rules as `EXISTS` Blocks	For atomic rules whose SHACL Core mapping is defined in §9.9, expansion MUST define `H(rule, ctx, focusVar)` using only SPARQL 1.1 constructs.
3803	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.4 Atomic Rules as `EXISTS` Blocks	If an atomic rule cannot be expressed as a SPARQL boolean expression without inventing additional semantics, expansion MUST fail with a `SchemaError` (§14).
3805	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.4 Atomic Rules as `EXISTS` Blocks	For atomic rules mapped in §9.9, the `H` translation MUST be:
3811	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.4 Atomic Rules as `EXISTS` Blocks	Here `?vK` MUST follow the deterministic variable allocation rule in §9.11.6.2.2.
3813	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.4 Atomic Rules as `EXISTS` Blocks	If `value` in a `TraitEquals` rule is a collection value (List, Set, Map, Record, Tuple, or Range), derived validation artifact generation MUST fail with a `SchemaError` (§14). Collection equality is not expressible as a single-triple SPARQL pattern.
3817	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.5 One-Way Representation Rule	When a `ConstraintDefinition` uses rule algebra (i.e., contains `AllOf`, `AnyOf`, `Not`, or `ConditionalConstraint` anywhere in its rule tree), expansion MUST express that constraint definition using SHACL-SPARQL only.
3819	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.5 One-Way Representation Rule	Expansion MUST NOT additionally emit independent SHACL Core constraints for the same `ConstraintDefinition`.
3823	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total)	The path operators (`TraitPath`, `ChildPath`, `DescendantPath`, `ContentPath`) and quantifier operators (`OnPathExists`, `OnPathForAll`, `OnPathCount`) MUST be expressed using SHACL-SPARQL.
3829	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.1 Path Binding Function	`B` MUST be computed as follows.
3865	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.1 Path Binding Function	If `conceptSelector` cannot be resolved to a unique `ConceptDefinition`, expansion MUST fail with a `SchemaError` (§14).
3877	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	The nested rule MUST be evaluated with `focusVar` set to `xVar`.
3881	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	`OnPathExists(path, r)` MUST translate to:
3892	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	`OnPathForAll(path, r)` MUST translate to:
3903	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	`OnPathCount(path, r, minCount=m?, maxCount=n?)` MUST translate to a COUNT-based boolean condition.
3905	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	If both `minCount` and `maxCount` are absent, expansion MUST fail with a `SchemaError` (§14).
3907	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	The expansion MUST introduce a subquery that binds a single variable `?countK` and MUST then apply all required comparisons to `?countK` using a `FILTER` expression.
3909	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	A conforming translation MUST have the following canonical form:
3928	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	* `?countK` MUST be deterministically allocated according to §9.11.6.2.2.
3929	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	* The subquery MUST appear in the same `WHERE` block as the enclosing constraint.
3930	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	* The `FILTER` expression applying the count comparisons MUST appear immediately after the subquery.
3931	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	* Other bindings or filters MUST NOT intervene between the subquery and its associated `FILTER`.
3935	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.4 SPARQL Constraint Shape	When a constraint is expressed using SHACL-SPARQL, the expansion MUST emit:
3942	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.4 SPARQL Constraint Shape	`sparqlConstraintIri` MUST be computed according to §9.6.9.
3944	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.4 SPARQL Constraint Shape	When the source constraint has a `title` or `description`, the expansion MUST emit `sh:message`.
3946	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.4 SPARQL Constraint Shape	The SPARQL query MUST be deterministic given the source constraint.
3950	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.5 Pattern Constraints (SPARQL 1.1 REGEX)	For the pattern-bearing constraints (`ValueMatchesPattern`, `PatternConstraint`, `ContentMatchesPattern`), the expansion MUST use SPARQL 1.1 `REGEX` semantics.
3952	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.5 Pattern Constraints (SPARQL 1.1 REGEX)	If `flags` is present, it MUST be projected to `sh:flags` when using `sh:pattern`, and it MUST be passed as the third argument to `REGEX` when using `sh:sparql`.
3956	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.6 `ValueIsValid` via Explicit `ValidatorDefinition`	For `ValueIsValid validatorName=$X`, expansion MUST:
3961	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.6 `ValueIsValid` via Explicit `ValidatorDefinition`	The embedding contract MUST be:
3963	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.6 `ValueIsValid` via Explicit `ValidatorDefinition`	- The validator content MUST be a SPARQL `SELECT` query text whose results follow the SHACL-SPARQL convention (returning a row per violation with `?this`).
3965	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.6 `ValueIsValid` via Explicit `ValidatorDefinition`	The derived `sh:select` text MUST be exactly the validator content.
3973	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases	Conforming implementations MUST support two pipelines:
3978	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases	Formatting and canonicalization MUST be performed in the full pipeline.
3981	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases > 10.1.1 Schema-Less Formatting Mode (Required)	An implementation MUST provide a schema-less formatting / canonicalization mode that can be run without a governing schema.
3985	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases > 10.1.1 Schema-Less Formatting Mode (Required)	- MUST NOT claim that its output is valid under any schema
3986	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases > 10.1.1 Schema-Less Formatting Mode (Required)	- MUST NOT report schema/semantic error classes (e.g., `SchemaError`, `IdentityError`, `ReferenceError`, `ConstraintError`)
3987	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases > 10.1.1 Schema-Less Formatting Mode (Required)	- MUST normalize encoding and line endings as defined by the surface form requirements (§8)
3988	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases > 10.1.1 Schema-Less Formatting Mode (Required)	- MUST apply the canonical form requirement defined in §10.3
3989	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases > 10.1.1 Schema-Less Formatting Mode (Required)	- MUST normalize whitespace, blank-line layout, trait layout, and annotation whitespace
3992	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases > 10.1.1 Schema-Less Formatting Mode (Required) > 10.1.1.1 Schema-less Content Mode Determination	In schema-less formatting and canonicalization mode, the parser MUST determine a Concept instance’s body mode mechanically as follows:
3998	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases > 10.1.1 Schema-Less Formatting Mode (Required) > 10.1.1.1 Schema-less Content Mode Determination	The body MUST be classified according to the following rules:
4000	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases > 10.1.1 Schema-Less Formatting Mode (Required) > 10.1.1.1 Schema-less Content Mode Determination	* If there are no non-blank body lines, the body MUST be treated as children mode.
4001	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases > 10.1.1 Schema-Less Formatting Mode (Required) > 10.1.1.1 Schema-less Content Mode Determination	* If any non-blank considered line begins with `<` (Concept marker) or `[` (annotation), the body MUST be treated as children mode.
4002	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases > 10.1.1 Schema-Less Formatting Mode (Required) > 10.1.1.1 Schema-less Content Mode Determination	* Otherwise, the body MUST be treated as content mode.
4006	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases > 10.1.1 Schema-Less Formatting Mode (Required) > 10.1.1.1 Schema-less Content Mode Determination	If the body is classified as children mode but contains any non-blank considered line that is neither a valid Concept marker line (§8.5) nor a valid annotation line (§8.9), the document MUST be rejected with a `ParseError` (§14).
4008	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases > 10.1.1 Schema-Less Formatting Mode (Required) > 10.1.1.1 Schema-less Content Mode Determination	When subsequent schema-based validation determines that the mechanically determined body mode is not authorized for the Concept, validation MUST fail with a `SchemaError` (§14).
4011	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.1 Processing Phases > 10.1.2 Full Validation Pipeline	To validate a document under a schema, a conforming tool MUST follow this sequence:
4021	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.2 Parse Errors vs Formatting Errors > 10.2.1 Parse Errors	During formatting + canonicalization, a failure MUST be classified as `ParseError` (§14) when input cannot be read into the syntactic structure required to produce a parsed document model (AST) as defined by the Codex surface form.
4025	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.2 Parse Errors vs Formatting Errors > 10.2.2 Formatting Errors	During formatting + canonicalization, a failure MUST be classified as `FormattingError` (§14) when input can be structurally read, but cannot be transformed into canonical surface form deterministically.
4028	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.3 Canonical Form Requirement	Every valid Codex document MUST normalize to exactly one canonical textual form.
4030	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.3 Canonical Form Requirement	When canonicalization cannot be performed unambiguously, the document MUST be rejected with a `FormattingError` (§14). Formatting errors MUST NOT be downgraded to warnings.
4048	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.4 Canonicalization Rules	- canonical Value literal formatting (exactly one space MUST follow each comma separator; all other optional whitespace MUST be removed; mandatory whitespace required by a specific production MUST be preserved; case-insensitive components MUST be normalized to their canonical case as defined by each value type in §5)
4058	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.4 Canonicalization Rules	- namespace label normalization: the `namespace` trait on each `SchemaImport` MUST be normalized to the imported schema's declared `namespace` value (§11.2.1)
4059	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.4 Canonicalization Rules	- `SchemaImport` ordering: within a `SchemaImports` block, `SchemaImport` children MUST be sorted alphabetically by their canonical `namespace` value (lexicographic ascending)
4061	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.4 Canonicalization Rules	Schema-less processing MUST complete Phase 1 only. Schema-directed processing MUST complete both phases.
4063	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.4 Canonicalization Rules	Canonicalization MUST NOT:
4070	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.4 Canonicalization Rules > 10.4.1 Deterministic Ordering for Unordered Collections	In canonical surface form, children of an `$Unordered` collection MUST be sorted according to the following deterministic algorithm:
4078	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.4 Canonicalization Rules > 10.4.2 Canonical Text Value Formatting	Text Values have a single semantic value after whitespace normalization (§5.1). Canonical surface form MUST be chosen deterministically as follows.
4083	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.4 Canonicalization Rules > 10.4.2 Canonical Text Value Formatting	2. If rendering the trait as `<trait>=q` on a single line would result in a line length of at most 100 columns, the Text Value MUST be rendered using the quoted spelling `q`.
4084	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.4 Canonicalization Rules > 10.4.2 Canonical Text Value Formatting	3. Otherwise, the Text Value MUST be rendered as a backtick block:
4088	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.4 Canonicalization Rules > 10.4.2 Canonical Text Value Formatting	Canonical backtick blocks are always multi-line: the opening and closing backticks MUST appear on their own lines.
4090	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.4 Canonicalization Rules > 10.4.2 Canonical Text Value Formatting	- The trait MUST appear on its own line.
4093	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.4 Canonicalization Rules > 10.4.2 Canonical Text Value Formatting	- The normalized text `t` MUST be wrapped into lines by breaking at spaces. Each line (including indentation) MUST be at most 100 columns, counting tabs as 2 columns. If a single word exceeds 100 columns, it MUST appear on its own line without splitting.
4095	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.4 Canonicalization Rules > 10.4.2 Canonical Text Value Formatting	- Within backtick blocks, a literal backtick in `t` MUST be escaped as `` \` ``. No other escapes are permitted.
4100	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.5 Annotation Canonicalization	Annotation canonicalization MUST follow the surface form requirements (§8).
4104	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.5 Annotation Canonicalization	- Block annotations with `CODE:` or `MARKDOWN:` directives are byte-preserving: tools MUST NOT reindent, trim, strip trailing whitespace, wrap, or interpret escapes within those blocks
4106	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.5 Annotation Canonicalization	When attachment cannot be determined deterministically, canonicalization MUST fail with a `FormattingError` (§14).
4126	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.7 Prohibited Behaviors	Codex tools MUST NOT:
4136	Codex Language Specification — Version 1.0.0 > 10. Formatting and Canonicalization > 10.8 Reporting Requirements	Formatting error reports MUST include:
4152	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.1 Core Principles	* Schema semantics MUST be **closed-world**, **deterministic**, and **free of heuristics**.
4154	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.1 Core Principles	Schema validation, schema expansion, and derived-artifact generation MUST satisfy the schema-first requirements defined in §9.
4163	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Traits	A `Schema` Concept MUST declare the following Traits:
4190	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Traits	The canonical namespace label for this schema. The value MUST be a camelCase name (§4.1). This label is used by importing documents to construct qualified names (§4.1.1) that reference Concept and Trait definitions from this schema. Each schema's `namespace` value MUST be unique among all schemas loaded together (governing schema plus imported schemas); if two schemas declare the same `namespace` value, processing MUST fail with a `SchemaError` (§14).
4199	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	A `Schema` MUST satisfy the mode-conditional child-Concept rules defined in §9.4.
4203	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` MUST contain exactly one `ConceptDefinitions` child Concept.
4213	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` MUST NOT contain `RdfGraph`.
4217	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` MUST contain exactly one `RdfGraph` child Concept.
4218	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` MUST NOT contain any of the following child Concepts:
4227	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` in `$CanonicalMode` is allowed to contain a `SchemaImports` child Concept. The parser MUST merge imported SHACL shapes at the RDF level.
4233	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Semantic Requirements	* Any schema whose structure or semantics cannot be interpreted deterministically under this specification MUST be rejected with a `SchemaError` (§14).
4243	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImports`	`SchemaImports` MUST only appear as a direct child of a root Concept.
4245	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImports`	A root Concept MUST NOT contain more than one `SchemaImports` child.
4247	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImports`	If `SchemaImports` appears on a non-root Concept, the document MUST be rejected with a `ParseError` (§14).
4255	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImports` > Canonical Ordering	Within a `SchemaImports` block, `SchemaImport` children MUST be sorted alphabetically by their canonical `namespace` value (lexicographic ascending) in canonical form.
4263	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Traits	The IRI of the imported schema. This MUST be the `Schema.id` of an imported schema provided via the `importedSchemas` input (§12.2). The value MUST be an IRI Reference Value.
4267	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Traits	The namespace label used in qualified names (§4.1.1) to reference Concepts and Traits from this imported schema. The value MUST be a camelCase name (§4.1). In canonical form, this value MUST be normalized to the imported schema's declared `namespace` Trait value (§10.4).
4271	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Semantic Requirements	* The `reference` IRI MUST appear as a key in the `importedSchemas` map provided to `validate()` (§12.2). If the IRI is not present in `importedSchemas`, processing MUST fail with a `SchemaError` (§14).
4272	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Semantic Requirements	* After namespace label normalization, all `SchemaImport` entries within a `SchemaImports` block MUST have distinct canonical `namespace` values. If two entries produce the same canonical namespace label, processing MUST fail with a `SchemaError` (§14).
4273	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Semantic Requirements	* A qualified name using a namespace label MUST resolve to a Concept or Trait definition within the corresponding imported schema. If the qualified name references a Concept or Trait not defined in the imported schema, processing MUST fail with a `SchemaError` (§14).
4279	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > Governing Schema as Default Namespace	Trait names on Concept instances in data documents MUST be unqualified. The Concept definition (from the governing schema or the imported schema that defines the Concept) determines which `TraitDefinition` each Trait name refers to.
4281	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > Governing Schema as Default Namespace	Enumerated Tokens (`$Value`) and Lookup Tokens (`~key`) MUST NOT be namespace-qualified. The Trait's constraint determines the `EnumeratedValueSet`; the document's resolution table (§9.8) resolves Lookup Tokens.
4285	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > Namespace Qualification in Schema Documents	In schema documents, references to Concepts and Traits from imported schemas in meta-language constructs (`RequiresTrait`, `AllowsTrait`, `AllowsChildConcept`, `RequiresChildConcept`, `ForbidsChildConcept`, `ForbidsTrait`, `conceptSelector`, etc.) MUST use qualified names (`namespace:name`). Local definitions MUST be unqualified.
4291	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > Data Documents with Imports	The `SchemaImports` in a data document MUST be consistent with the governing schema: any schema imported by the data document MUST also be imported by the governing schema (or be the governing schema itself).
4342	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.2 `ContentRules` > Children > `AllowsContent`	`whitespaceMode` MUST be one of:
4344	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.2 `ContentRules` > Children > `AllowsContent`	* `$Preformatted` — content whitespace is significant and MUST be preserved exactly
4345	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.2 `ContentRules` > Children > `AllowsContent`	* `$Flow` — content whitespace is not significant; Codex-conforming tools MUST collapse runs of whitespace to single spaces and trim leading/trailing whitespace
4398	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.3 `TraitRules` > Children > Concept-Level `AllowedValues` Narrowing	When `AllowedValues` appears as a child of `RequiresTrait` or `AllowsTrait`, it further narrows the `AllowedValues` declared on the referenced `TraitDefinition`. The concept-level allowed values MUST be a subset of the `TraitDefinition`-level allowed values. If both exist, the concept-level constraint governs.
4447	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.4 `ChildRules` > Children > `ExactlyOneChildOf`	Declares that exactly one of the listed Concept types MUST appear as a child of the governed instance.
4479	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Form	`CollectionRules` MUST be self-closing and MUST NOT have children.
4483	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Applicability	When `CollectionRules` is present, child ordering and duplication semantics MUST be enforced as declared.
4489	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics	Ordering MUST be exactly one of:
4495	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Ordered`	Source order MUST be preserved through all conforming processing.
4497	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Ordered`	Two `$Ordered` collections with identical children in different orders MUST be treated as semantically distinct.
4499	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Ordered`	Validation and comparison of `$Ordered` collections MUST be order-sensitive.
4505	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Unordered`	Conforming implementations MUST preserve source order during parsing and general processing.
4507	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Unordered`	Validation of `$Unordered` collections MUST be order-insensitive.
4509	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Unordered`	Semantic comparison of `$Unordered` collections MUST be order-insensitive: two `$Unordered` collections with identical children in different orders MUST be treated as semantically equivalent.
4511	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Unordered`	In canonical surface form, children of an `$Unordered` collection MUST be sorted according to the deterministic ordering defined in §10.4.1.
4532	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Allowed Traits	When both `defaultValueType` and `defaultValueTypes` are provided, schema processing MUST fail with a `SchemaError` (§14).
4534	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Allowed Traits	`priority` is a meta-schema concern. Implementations MUST NOT use `priority` to change validation or compilation semantics. Meta-schemas are allowed to constrain `priority` values.
4537	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Value Type Semantics	When a trait is present on a Concept instance, its value MUST conform to the declared value type.
4539	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Value Type Semantics	When `defaultValueTypes` specifies multiple types, the value MUST conform to exactly one of the listed types.
4542	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Collection Type Semantics	When a trait's value type is a parameterized collection type, each element of the collection MUST conform to the declared item type.
4546	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Collection Type Semantics	When a trait's value type is a union containing both scalar and collection types, the value MUST conform to exactly one member of the union.
4608	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types	Value type checking MUST be deterministic and MUST NOT perform implicit evaluation.
4669	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.1 Built-In Value Type Tokens	When a schema constrains a Trait value using a built-in value type token, semantic validation MUST convert that value into the corresponding typed IR value and MUST reject values that are syntactically well-formed but semantically invalid for the expected type.
4689	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.2 `ValueTypeDefinition` > Allowed Traits	`ValueTypeDefinition` names MUST be unique within the Schema.
4691	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.2 `ValueTypeDefinition` > Allowed Traits	When `validatorName` is present, schema-driven validation MUST apply the referenced validator as specified in §9.5.2 and §9.11.6.6.
4693	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.2 `ValueTypeDefinition` > Allowed Traits	When `validatorName` cannot be resolved to exactly one `ValidatorDefinition`, schema processing MUST fail with a `SchemaError` (§14).
4695	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.2 `ValueTypeDefinition` > Allowed Traits	A `ValueTypeDefinition` MUST NOT change the surface grammar of its `baseValueType`.
4731	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.3 Enumerated Value Sets > `Member` > Allowed Traits	Each `value` MUST be unique within its `EnumeratedValueSet`.
4736	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.4 Built-In Enumerated Value Sets	The following enumerated value sets are defined by the Codex language itself and MUST be recognized by all conforming implementations.
4766	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.4 Built-In Enumerated Value Sets > `Cardinality`	These enumerated sets MUST NOT be redefined by schemas.
4777	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.1 `ConstraintDefinitions` > Children	The order of `ConstraintDefinition` children MUST be preserved but MUST NOT affect semantics.
4798	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.2 `ConstraintDefinition` > Children	When either child is missing or appears more than once, schema processing MUST fail with a `SchemaError` (§14).
4810	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > Children	When `Targets` contains no children, schema processing MUST fail with a `SchemaError` (§14).
4819	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > 11.6.3.1 `TargetConcept` > Traits	The selector MUST resolve to exactly one `ConceptDefinition`.
4820	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > 11.6.3.1 `TargetConcept` > Traits	Otherwise, schema processing MUST fail with a `SchemaError` (§14).
4829	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > 11.6.3.2 `TargetContext` > Traits	When `contextSelector` is not `"Document"`, it MUST resolve to exactly one `ConceptDefinition`.
4830	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > 11.6.3.2 `TargetContext` > Traits	Otherwise, schema processing MUST fail with a `SchemaError` (§14).
4837	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.4 `Rule` > Children	Exactly one child, which MUST be one of:
4843	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.4 `Rule` > Children	When `Rule` contains zero or more than one child, schema processing MUST fail with a `SchemaError` (§14).
4845	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.4 `Rule` > Children	`Rule` nodes are purely structural and MUST NOT carry Traits.
4851	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra	Rule algebra MUST be translatable to a total, deterministic validation form.
4857	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.1 General Rules	* Rule algebra nodes MUST NOT carry Traits.
4858	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.1 General Rules	* `AllOf`, `AnyOf`, and `Not` MUST contain only `Rule` nodes as children.
4859	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.1 General Rules	* Any rule tree MUST be finite and acyclic.
4861	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.1 General Rules	When a rule algebra structure cannot be translated deterministically, schema processing MUST fail with a `SchemaError` (§14).
4917	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.6 Determinism Requirement	Rule algebra evaluation MUST be:
4922	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.6 Determinism Requirement	When rule algebra composition cannot be evaluated deterministically, schema processing MUST fail with a `SchemaError` (§14).
4928	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers	All path and quantifier semantics MUST be compatible with the instance-graph mapping defined in §9.7 and the rule-to-SPARQL translation defined in §9.11.
4934	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.1 Paths	Each path node MUST declare exactly the traits required for its form.
4983	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.2 Quantifiers	Quantifiers MUST appear only in rule nodes that explicitly bind a Path to a nested Rule (see §9.5.3).
5009	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.2 Quantifiers > `Count` > Allowed Traits	At least one of `minCount` or `maxCount` MUST be present.
5019	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	* Paths MUST select a well-defined set of elements.
5020	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	* Quantifiers MUST evaluate to a single boolean outcome.
5021	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	* When a path selector cannot be resolved uniquely, schema processing MUST fail with a `SchemaError` (§14).
5022	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	* When a quantifier cannot be evaluated without guessing, schema processing MUST fail with a `SchemaError` (§14).
5024	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	Paths and quantifiers MUST NOT be evaluated outside the schema-driven validation pipeline defined in §9.
5030	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints	When an atomic constraint cannot be expressed under the instance-graph mapping (§9.7) and the constraint-to-artifact rules (§9.9–§9.11), schema processing MUST fail with a `SchemaError` (§14).
5038	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Trait Constraints > `TraitExists`	The named Trait MUST be present.
5047	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Trait Constraints > `TraitMissing`	The named Trait MUST be absent.
5056	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Trait Constraints > `TraitEquals`	The named Trait MUST have at least one value equal to the specified value.
5073	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Trait Constraints > `TraitCardinality` > Allowed Traits	At least one of `min` or `max` MUST be present.
5111	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsOneOf`	The value MUST be one of the explicitly listed values.
5120	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueMatchesPattern`	The value MUST match a regular expression.
5147	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueLength` > Allowed Traits	At least one of `min` or `max` MUST be present.
5157	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueInNumericRange` > Allowed Traits	At least one of `min` or `max` MUST be present.
5159	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueInNumericRange` > Allowed Traits	This constraint MUST apply only to numeric value types that support ordered comparison.
5160	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueInNumericRange` > Allowed Traits	When comparison semantics are not explicitly defined for the active value type, schema processing MUST fail with a `SchemaError` (§14).
5166	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsNonEmpty`	The value MUST be present and non-empty.
5169	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsNonEmpty`	If applied to an incompatible value type, schema processing MUST fail with a `SchemaError` (§14).
5175	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsValid`	The value MUST satisfy a named validator.
5180	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsValid` > Traits	The validator MUST resolve to exactly one `ValidatorDefinition` in the governing schema.
5181	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsValid` > Traits	If resolution fails, schema processing MUST fail with a `SchemaError` (§14).
5193	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.2 Child Constraints > `ChildConstraint` > Traits	Its semantics MUST be equivalent to the corresponding explicit child-rule form defined in §11.3.4.
5205	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.2 Child Constraints > `ChildSatisfies` > Children	The rule MUST be evaluated for each matching child Concept instance.
5239	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.3 Collection Constraints > `CollectionAllowsDuplicates` > Allowed Traits	When `allowed` is `false`, `keyTrait` MUST be present.
5252	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.3 Collection Constraints > `MemberCount` > Allowed Traits	At least one of `min` or `max` MUST be present.
5261	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.3 Collection Constraints > `EachMemberSatisfies`	Each collection member MUST satisfy a nested rule.
5267	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.3 Collection Constraints > `EachMemberSatisfies` > Children	The rule MUST be evaluated for each matching collection member.
5279	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.4 Uniqueness Constraints > `UniqueConstraint` > Traits	Uniqueness semantics MUST follow the deterministic scope rules defined in §9.9.7.
5292	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.5 Order Constraints > `OrderConstraint` > Types	* `Ascending`: Elements MUST be in ascending order by the specified trait value.
5293	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.5 Order Constraints > `OrderConstraint` > Types	* `Descending`: Elements MUST be in descending order by the specified trait value.
5298	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.5 Order Constraints > `OrderConstraint` > Children	Order constraint semantics apply to `$Ordered` collections only. When an `OrderConstraint` is applied to an `$Unordered` collection, schema processing MUST fail with a `SchemaError` (§14).
5310	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceTargetsEntity`: Target MUST be an Entity. The `conceptSelector` and `traitName` traits MUST NOT be present.
5311	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceMustResolve`: Reference MUST resolve. The `conceptSelector` and `traitName` traits MUST NOT be present.
5312	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceSingleton`: At most one reference Trait MUST be present. The `conceptSelector` and `traitName` traits MUST NOT be present.
5313	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceTargetsConcept`: Target MUST be a specific Concept type. The `conceptSelector` trait MUST be present.
5314	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceTraitAllowed`: A specific reference Trait is allowed. The `traitName` trait MUST be present.
5316	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	Reference constraint semantics MUST follow §9.9.9–§9.9.12 exactly.
5328	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	* `MustBeEntity`: Instance MUST be an Entity. The `scope`, `pattern`, and `flags` traits MUST NOT be present.
5329	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	* `MustNotBeEntity`: Instance MUST NOT be an Entity. The `scope`, `pattern`, and `flags` traits MUST NOT be present.
5330	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	* `IdentifierUniqueness`: Identifiers MUST be unique within scope. The `scope` trait MUST be present. The `pattern` and `flags` traits MUST NOT be present.
5331	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	* `IdentifierForm`: Identifier MUST match pattern. The `pattern` trait MUST be present. The `scope` trait MUST NOT be present.
5333	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	Identity constraint semantics MUST follow the entity and identity model defined in §§3.5 and 6.
5335	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	`IdentityConstraint(type=MustBeEntity)` MUST report an `IdentityError` (§14) unless the focus Concept instance is an Entity under §3.5.
5337	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	`IdentityConstraint(type=MustNotBeEntity)` MUST report an `IdentityError` (§14) if the focus Concept instance declares an `id` Trait.
5340	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	Its semantics MUST be identical to `UniqueConstraint(trait=id, scope=S)` as defined in §9.9.7 (where `id` refers to `codex:declaredId`).
5343	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	When the focus Concept instance is an Entity, its declared `id` value MUST match the regular expression `p` under SPARQL 1.1 `REGEX` semantics (see §9.5.1).
5345	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	When `pattern` is not provided for `IdentityConstraint(type=IdentifierForm)`, schema processing MUST fail with a `SchemaError` (§14).
5358	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.8 Context Constraints > `ContextConstraint` > Types	* `OnlyValidUnderParent`: Requires the immediate parent is of the type specified by the `TargetContext` in this constraint's `Targets` block. The `ContextConstraint` itself MUST NOT have a `contextSelector` trait.
5359	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.8 Context Constraints > `ContextConstraint` > Types	* `OnlyValidUnderContext`: Requires an ancestor of the specified type exists in the parent chain. The `contextSelector` trait MUST be present.
5361	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.8 Context Constraints > `ContextConstraint` > Types	Context constraint semantics MUST follow §9.9.8.
5373	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.10 Content Constraints > `ContentConstraint` > Types	* `ForbidsContent`: Requires content is absent. The `pattern` and `flags` traits MUST NOT be present.
5374	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.10 Content Constraints > `ContentConstraint` > Types	* `ContentRequired`: Requires content exists. The `pattern` and `flags` traits MUST NOT be present.
5375	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.10 Content Constraints > `ContentConstraint` > Types	* `ContentMatchesPattern`: Requires content matches a pattern. The `pattern` trait MUST be present. The `flags` trait is allowed.
5377	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.10 Content Constraints > `ContentConstraint` > Types	Content constraint semantics MUST follow the content model defined in §3.4 and the validation rules defined in §9.9.5.
5440	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.11 Relationship to External Systems	* Any derived representation (including SHACL, SHACL-SPARQL, or OWL) MUST be a pure, deterministic projection of the Codex schema.
5441	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.11 Relationship to External Systems	* Derived artifacts MUST NOT introduce semantics, defaults, inference rules, or interpretation not explicitly defined by:
5445	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.11 Relationship to External Systems	* Derived artifacts MUST NOT override, weaken, or contradict Codex validation semantics.
5446	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.11 Relationship to External Systems	* When a Codex constraint or rule cannot be expressed faithfully in the chosen external system, derivation MUST fail with a `SchemaError` (§14) rather than approximate.
5458	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.1 Purpose	A Codex document MUST NOT be semantically validated without an explicit governing schema.
5460	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.1 Purpose	Codex permits schema-less formatting and well-formedness checks that do not require a governing schema, but such checks MUST NOT perform semantic interpretation or validation (see §9.2 and §10.1.1).
5473	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.2 Schema Provision	A conforming implementation MUST require explicit provision of a governing schema for semantic validation.
5475	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.2 Schema Provision	Schema-less formatting and well-formedness checks (§9.2, §10.1.1) do not require a governing schema and MUST NOT be blocked by the absence of one.
5485	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.2 Schema Provision	`documentBaseIri` is the base IRI for instance graph mapping (§9.7). It MUST be an IRI. If `documentBaseIri` is missing, semantic validation MUST fail with a `SchemaError` (§14).
5487	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.2 Schema Provision	The implementation MUST use the provided schema and MUST NOT attempt to substitute, infer, or override it.
5489	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.2 Schema Provision	If no governing schema is provided and semantic validation is requested, the implementation MUST fail with a `SchemaError` (§14).
5491	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.2 Schema Provision	If the document or governing schema declares a `SchemaImport` whose `reference` IRI is not present in `importedSchemas`, the implementation MUST fail with a `SchemaError` (§14).
5503	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas	The bootstrap schema-of-schemas MUST NOT be substituted for a missing governing schema when processing an instance document.
5507	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.1 Requirements	Every conforming implementation MUST:
5513	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.1 Requirements	An explicitly provided governing schema for a schema document MUST either be the bootstrap schema-of-schemas itself or a schema that is valid under the bootstrap schema-of-schemas. An implementation MUST NOT partially extend, modify, or augment the bootstrap schema-of-schemas.
5515	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.1 Requirements	The bootstrap schema-of-schemas MUST itself conform to the Codex language invariants (§2) and the schema-first architecture (§9).
5521	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.2 Schema Document Detection	A document whose root Concept is `Schema` MUST be treated as a schema document and MUST NOT be parsed as an instance document under any schema other than the bootstrap schema-of-schemas or an explicitly provided governing schema.
5525	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.2 Schema Document Detection	1. If an explicit governing schema was provided by the caller, that schema MUST be used.
5526	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.2 Schema Document Detection	2. Otherwise, the built-in bootstrap schema-of-schemas MUST be used.
5528	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.2 Schema Document Detection	An implementation MUST NOT use any other detection, inference, or fallback mechanisms.
5534	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.3 Validation and Error Classification	* If the document cannot be decoded, tokenized, or structurally parsed, the failure MUST be classified as `ParseError` (§14).
5535	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.3 Validation and Error Classification	* If the document is structurally readable but violates the bootstrap schema-of-schemas or an explicitly provided governing schema, the failure MUST be classified as `SchemaError` (§14).
5537	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.3 Validation and Error Classification	Implementations MUST NOT attempt partial validation, recovery, or best-effort interpretation.
5545	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.4 Canonical Authority	The bootstrap schema-of-schemas MUST accept exactly those schema documents that conform to §11, and MUST reject all others with a `SchemaError` (§14).
5547	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.4 Canonical Authority	The bootstrap schema-of-schemas MUST NOT introduce additional constructs, defaults, or semantics beyond those defined in §11.
5553	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.4 Schema Caching	Caching MUST NOT change observable parsing, validation, or error-reporting behavior.
5561	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.1 Schema Unavailable	* The report MUST indicate that the governing schema was unavailable
5562	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.1 Schema Unavailable	* Validation MUST NOT proceed
5569	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.2 Schema Load Failure	* The report MUST indicate that the schema could not be loaded
5570	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.2 Schema Load Failure	* The report MUST include the schema identifier
5577	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.3 Invalid Schema	* The report MUST indicate that schema validation failed
5578	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.3 Invalid Schema	* Underlying schema validation errors MUST be reported
5585	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.4 Imported Schema Unavailable	* The report MUST indicate which imported schema IRI was unavailable
5586	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.4 Imported Schema Unavailable	* Validation MUST NOT proceed
5593	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.5 Duplicate Namespace Label	* The report MUST indicate the duplicate namespace label and the conflicting schema IRIs
5594	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.5 Duplicate Namespace Label	* Validation MUST NOT proceed
5601	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.6 Unresolved Qualified Name	* The report MUST indicate the unresolved qualified name and the imported schema IRI
5636	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.2 Core Principles	Schemas MUST make their versioning intent explicit.
5639	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	Every Codex schema MUST declare its identity and version explicitly.
5650	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	All versions of the same schema MUST share the same schema identifier.
5654	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	A schema document that omits any of the `id`, `version`, or `versionScheme` Traits on the root `Schema` Concept MUST be rejected with a `SchemaError` (§14).
5656	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	A schema document MUST NOT declare more than one schema identifier.
5658	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	Within a schema lineage, the schema identifier MUST NOT be redefined or aliased.
5660	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	Schema identity and version information MUST be treated as authoritative and MUST NOT be inferred, synthesized, or substituted by tooling.
5663	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics	Schemas MUST use monotonic versioning within a schema lineage.
5665	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics	Within a schema lineage, all schema versions MUST use the same `versionScheme` value; a schema that changes the `versionScheme` within a lineage MUST be rejected with a `SchemaError` (§14).
5667	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics	Regardless of scheme, schema versions MUST form a **total, unambiguous ordering**. A schema whose version ordering is ambiguous or non-comparable MUST be rejected with a `SchemaError` (§14).
5669	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics	Tools MUST compare schema versions mechanically according to the comparison rules defined in this section for the declared `versionScheme`, and MUST NOT apply heuristics, coercion, or fallback rules.
5672	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics > 13.4.1 Version Schemes	The root `Schema` Concept’s `versionScheme` Trait MUST be one of the following Enumerated Token Values:
5679	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics > 13.4.1 Version Schemes	If `versionScheme` is not one of these values, schema processing MUST fail with a `SchemaError` (§14).
5682	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics > 13.4.2 Version Comparison Rules	For all schemes below, if a `version` text does not conform to the required scheme-specific syntax, schema processing MUST fail with a `SchemaError` (§14).
5705	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes	Each schema version MUST declare exactly one compatibility class. For all versions except the first, the compatibility class declares the relationship to the immediately preceding version in the same schema lineage.
5709	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes	The `compatibilityClass` Trait MUST be one of the following Enumerated Token Values:
5716	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes	If `compatibilityClass` is not one of these values, schema processing MUST fail with a `SchemaError` (§14).
5720	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes	If a schema version's declared compatibility class is contradicted by its actual effects on validation semantics, the schema MUST be rejected with a `SchemaError` (§14).
5724	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.1 Initial	The first version in a schema lineage MUST declare `compatibilityClass=$Initial`.
5726	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.1 Initial	A schema version that declares `$Initial` MUST be the first version in its lineage; if a non-first version declares `$Initial`, schema processing MUST fail with a `SchemaError` (§14).
5732	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.2 BackwardCompatible	* all Codex data that passed schema validation under the immediately preceding version MUST also pass schema validation under this version
5733	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.2 BackwardCompatible	* the meaning of existing Concepts and Traits MUST be preserved
5737	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.2 BackwardCompatible	If any previously valid data becomes invalid under a schema version declared as backward-compatible, the schema MUST be rejected with a `SchemaError` (§14).
5749	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.3 ForwardCompatible	If data authored for a forward-compatible version cannot pass schema validation under the preceding version without loss of meaning, the schema MUST be rejected with a `SchemaError` (§14).
5759	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.4 Breaking	Any schema version that introduces a breaking change MUST be declared as breaking.
5764	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.6 What Constitutes a Breaking Change	The following changes are breaking and MUST require `compatibilityClass=$Breaking`:
5778	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.6 What Constitutes a Breaking Change	A schema version that introduces any breaking change without declaring `compatibilityClass=$Breaking` is invalid and MUST be rejected with a `SchemaError` (§14).
5794	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.7 Non-Breaking Changes	Non-breaking changes MUST NOT:
5800	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.7 Non-Breaking Changes	If any change classified as non-breaking would cause previously valid data to fail validation, the schema version MUST instead be declared as `compatibilityClass=$Breaking`.
5803	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	When validating a Codex document, the governing schema version MUST be explicitly known.
5805	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	Validation MUST be performed strictly according to the rules of that schema version.
5807	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	A conforming implementation MUST:
5814	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	A conforming implementation MUST NOT:
5821	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	If schema version resolution fails for any reason, validation MUST fail with a `SchemaError` (§14).
5826	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	A breaking schema version declaration MUST be treated as a statement that migration is required for existing data to validate under the new schema version.
5828	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	Codex schemas MUST:
5834	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	Codex tooling MUST:
5840	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	Any migrated data MUST validate cleanly under the target schema version using ordinary schema validation rules.
5842	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	Migration tooling, if provided, is outside the scope of this specification and MUST be explicit, deterministic, and non-heuristic.
5845	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.10 Tooling Responsibilities	Codex tooling MUST:
5853	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.10 Tooling Responsibilities	Codex tooling MUST NOT:
5860	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.10 Tooling Responsibilities	All version handling MUST be explicit, deterministic, and free of heuristics.
5880	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.2 Primary Error Class Requirement	Every Codex failure MUST belong to exactly one primary error class.
5882	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.2 Primary Error Class Requirement	Tools MUST report exactly one primary error class; additional diagnostic details MUST NOT obscure or replace the primary classification.
5897	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.3 Closed Set of Error Classes (Top Level)	An implementation MUST NOT define additional top-level error classes.
5899	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.3 Closed Set of Error Classes (Top Level)	Validation MUST proceed in the following order:
5906	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.3 Closed Set of Error Classes (Top Level)	Processing MUST halt at the first failure. A failure in an earlier phase MUST NOT be reported as a later-phase error class.
5908	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.3 Closed Set of Error Classes (Top Level)	When a violation matches multiple schema-level error classes (4–9), the implementation MUST classify it as the earliest matching class in the enumerated order.
5920	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.4 Error Class Definitions > 14.4.1 ParseError	- well-formedness checks MUST NOT require a governing schema
5956	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.4 Error Class Definitions > 14.4.3 FormattingError	- canonicalization MUST be deterministic or MUST fail
5957	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.4 Error Class Definitions > 14.4.3 FormattingError	- tools MUST NOT guess or “best-effort” normalize
5999	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.4 Error Class Definitions > 14.4.5 IdentityError	- `id` declared on a Concept that MUST NOT be an Entity
6074	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.5 Reporting Requirements	Tools MUST report validation failures with:
6082	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.5 Reporting Requirements	If any of the above information is not applicable, the tool MUST omit it explicitly rather than infer or guess.
6084	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.5 Reporting Requirements	Error wording, formatting, and presentation are tool-defined, but classification and attribution MUST be precise and deterministic.
6095	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.5 Reporting Requirements > 14.5.1 Error Payload Shape (Recommended)	- `code` values MUST be stable across patch releases.
6096	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.5 Reporting Requirements > 14.5.1 Error Payload Shape (Recommended)	- A `code` MUST NOT depend on message text.
6108	Codex Language Specification — Version 1.0.0 > 14. Validation Errors > 14.5 Reporting Requirements > 14.5.1 Error Payload Shape (Recommended)	When an error payload includes both a `span` and a `conceptPath`, the `span` MUST identify the precise surface-form location for the same failing construct.
6171	Codex Language Specification — Version 1.0.0 > Appendix A. Formal Grammar > A.1 EBNF > A.1.2 Document Structure	(* A Codex document contains exactly one root Concept and MUST end with
6763	Codex Language Specification — Version 1.0.0 > Appendix A. Formal Grammar > A.1 EBNF > A.1.15 Color Values	(* Color values are accepted as declarative spellings; tools MUST NOT normalize,
6765	Codex Language Specification — Version 1.0.0 > Appendix A. Formal Grammar > A.1 EBNF > A.1.15 Color Values	tools MUST interpret and convert a color value to a semantic color type for the
6766	Codex Language Specification — Version 1.0.0 > Appendix A. Formal Grammar > A.1 EBNF > A.1.15 Color Values	purposes of schema validation and evaluation, but this MUST NOT change the
6781	Codex Language Specification — Version 1.0.0 > Appendix A. Formal Grammar > A.1 EBNF > A.1.15 Color Values	(* §5.7.2, Appendix B: Name MUST be a named color keyword; unrecognized names are a ParseError (§14). *)
7357	Codex Language Specification — Version 1.0.0 > Appendix A. Formal Grammar > A.1 EBNF > A.1.25 Annotations	block annotation; such a line MUST NOT be consumed as an AnnotationBlockLine.
8061	Codex Language Specification — Version 1.0.0 > Appendix B. Codex Named Colors > B.1 Named Color Keyword Table	During schema-driven semantic validation (§5.7), a Named Color Value MUST be interpreted as the sRGB color given by its `sRGB hex` value in this table:
