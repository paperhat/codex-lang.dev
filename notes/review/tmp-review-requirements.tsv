2730	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface)	To support a total, deterministic projection to derived validation artifacts, simplified-mode schema authoring MUST support the following extensions.
2734	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.1 Pattern Flags	The following atomic constraints MUST support an optional `flags` trait whose value is text:
2740	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.1 Pattern Flags	If `flags` is omitted, it MUST be treated as empty text.
2742	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.1 Pattern Flags	The `pattern` and `flags` semantics MUST be SPARQL 1.1 `REGEX` semantics.
2746	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	Simplified Authoring Mode MUST support explicit validator definitions that make `ValueIsValid` deterministic.
2754	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	Each `ValidatorDefinition` MUST have these traits:
2760	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	`ValidatorDefinition` names MUST be unique within the Schema.
2762	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	Each `ValidatorDefinition` MUST be in content mode.
2764	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	The content of `ValidatorDefinition` MUST be a SPARQL `SELECT` query text.
2766	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	The `SELECT` results MUST follow the SHACL-SPARQL convention (returning one row per violation with `?this` bound to the focus node).
2768	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	If a derived validation artifact is expressed using SHACL-SPARQL, the embedding contract for `ValueIsValid validatorName=$X` MUST be:
2773	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	If `$X` cannot be resolved to exactly one `ValidatorDefinition`, schema processing MUST fail with a `SchemaError` (§14).
2779	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	To produce a total, deterministic mapping, Simplified Authoring Mode MUST provide explicit rule-node forms that bind exactly one path to exactly one nested rule.
2781	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	Simplified Authoring Mode MUST provide the following rule nodes:
2787	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	Each of these MUST have exactly one `Path` child and exactly one `Rule` child.
2789	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	`OnPathCount` MUST additionally have:
2794	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	The `Path` child MUST be exactly one of:
2801	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	`ChildSatisfies(conceptSelector=X, Rule=R)` MUST be interpreted as equivalent to `OnPathForAll(Path=ChildPath(X), Rule=R)`.
2814	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	the constraint node MUST have exactly one `Path` child that selects the collection members the constraint applies to.
2816	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	That member-selection path MUST be either `ChildPath` or `DescendantPath`.
2818	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	If the member-selection path is not one of these, expansion MUST fail with a `SchemaError` (§14).
2820	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	For `CollectionAllowsDuplicates` with `allowed=false`, the constraint node MUST include a required `keyTrait` trait whose value is a Trait name.
2822	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	If `keyTrait` is `id`, it MUST refer to the declared identifier as specified by the instance-graph identity rules.
4152	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.1 Core Principles	* Schema semantics MUST be **closed-world**, **deterministic**, and **free of heuristics**.
4154	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.1 Core Principles	Schema validation, schema expansion, and derived-artifact generation MUST satisfy the schema-first requirements defined in §9.
4163	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Traits	A `Schema` Concept MUST declare the following Traits:
4190	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Traits	The canonical namespace label for this schema. The value MUST be a camelCase name (§4.1). This label is used by importing documents to construct qualified names (§4.1.1) that reference Concept and Trait definitions from this schema. Each schema's `namespace` value MUST be unique among all schemas loaded together (governing schema plus imported schemas); if two schemas declare the same `namespace` value, processing MUST fail with a `SchemaError` (§14).
4199	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	A `Schema` MUST satisfy the mode-conditional child-Concept rules defined in §9.4.
4203	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` MUST contain exactly one `ConceptDefinitions` child Concept.
4213	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` MUST NOT contain `RdfGraph`.
4217	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` MUST contain exactly one `RdfGraph` child Concept.
4218	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` MUST NOT contain any of the following child Concepts:
4227	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Children	* A `Schema` in `$CanonicalMode` is allowed to contain a `SchemaImports` child Concept. The parser MUST merge imported SHACL shapes at the RDF level.
4233	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2 Schema > Semantic Requirements	* Any schema whose structure or semantics cannot be interpreted deterministically under this specification MUST be rejected with a `SchemaError` (§14).
4243	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImports`	`SchemaImports` MUST only appear as a direct child of a root Concept.
4245	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImports`	A root Concept MUST NOT contain more than one `SchemaImports` child.
4247	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImports`	If `SchemaImports` appears on a non-root Concept, the document MUST be rejected with a `ParseError` (§14).
4255	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImports` > Canonical Ordering	Within a `SchemaImports` block, `SchemaImport` children MUST be sorted alphabetically by their canonical `namespace` value (lexicographic ascending) in canonical form.
4263	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Traits	The IRI of the imported schema. This MUST be the `Schema.id` of an imported schema provided via the `importedSchemas` input (§12.2). The value MUST be an IRI Reference Value.
4267	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Traits	The namespace label used in qualified names (§4.1.1) to reference Concepts and Traits from this imported schema. The value MUST be a camelCase name (§4.1). In canonical form, this value MUST be normalized to the imported schema's declared `namespace` Trait value (§10.4).
4271	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Semantic Requirements	* The `reference` IRI MUST appear as a key in the `importedSchemas` map provided to `validate()` (§12.2). If the IRI is not present in `importedSchemas`, processing MUST fail with a `SchemaError` (§14).
4272	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Semantic Requirements	* After namespace label normalization, all `SchemaImport` entries within a `SchemaImports` block MUST have distinct canonical `namespace` values. If two entries produce the same canonical namespace label, processing MUST fail with a `SchemaError` (§14).
4273	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > `SchemaImport` > Semantic Requirements	* A qualified name using a namespace label MUST resolve to a Concept or Trait definition within the corresponding imported schema. If the qualified name references a Concept or Trait not defined in the imported schema, processing MUST fail with a `SchemaError` (§14).
4279	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > Governing Schema as Default Namespace	Trait names on Concept instances in data documents MUST be unqualified. The Concept definition (from the governing schema or the imported schema that defines the Concept) determines which `TraitDefinition` each Trait name refers to.
4281	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > Governing Schema as Default Namespace	Enumerated Tokens (`$Value`) and Lookup Tokens (`~key`) MUST NOT be namespace-qualified. The Trait's constraint determines the `EnumeratedValueSet`; the document's resolution table (§9.8) resolves Lookup Tokens.
4285	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > Namespace Qualification in Schema Documents	In schema documents, references to Concepts and Traits from imported schemas in meta-language constructs (`RequiresTrait`, `AllowsTrait`, `AllowsChildConcept`, `RequiresChildConcept`, `ForbidsChildConcept`, `ForbidsTrait`, `conceptSelector`, etc.) MUST use qualified names (`namespace:name`). Local definitions MUST be unqualified.
4291	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.2.1 Schema Imports > Data Documents with Imports	The `SchemaImports` in a data document MUST be consistent with the governing schema: any schema imported by the data document MUST also be imported by the governing schema (or be the governing schema itself).
4342	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.2 `ContentRules` > Children > `AllowsContent`	`whitespaceMode` MUST be one of:
4344	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.2 `ContentRules` > Children > `AllowsContent`	* `$Preformatted` — content whitespace is significant and MUST be preserved exactly
4345	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.2 `ContentRules` > Children > `AllowsContent`	* `$Flow` — content whitespace is not significant; Codex-conforming tools MUST collapse runs of whitespace to single spaces and trim leading/trailing whitespace
4398	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.3 `TraitRules` > Children > Concept-Level `AllowedValues` Narrowing	When `AllowedValues` appears as a child of `RequiresTrait` or `AllowsTrait`, it further narrows the `AllowedValues` declared on the referenced `TraitDefinition`. The concept-level allowed values MUST be a subset of the `TraitDefinition`-level allowed values. If both exist, the concept-level constraint governs.
4447	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.4 `ChildRules` > Children > `ExactlyOneChildOf`	Declares that exactly one of the listed Concept types MUST appear as a child of the governed instance.
4479	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Form	`CollectionRules` MUST be self-closing and MUST NOT have children.
4483	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Applicability	When `CollectionRules` is present, child ordering and duplication semantics MUST be enforced as declared.
4489	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics	Ordering MUST be exactly one of:
4495	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Ordered`	Source order MUST be preserved through all conforming processing.
4497	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Ordered`	Two `$Ordered` collections with identical children in different orders MUST be treated as semantically distinct.
4499	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Ordered`	Validation and comparison of `$Ordered` collections MUST be order-sensitive.
4505	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Unordered`	Conforming implementations MUST preserve source order during parsing and general processing.
4507	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Unordered`	Validation of `$Unordered` collections MUST be order-insensitive.
4509	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Unordered`	Semantic comparison of `$Unordered` collections MUST be order-insensitive: two `$Unordered` collections with identical children in different orders MUST be treated as semantically equivalent.
4511	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.3 Concept Definitions > 11.3.5 `CollectionRules` > Ordering Semantics > `$Unordered`	In canonical surface form, children of an `$Unordered` collection MUST be sorted according to the deterministic ordering defined in §10.4.1.
4532	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Allowed Traits	When both `defaultValueType` and `defaultValueTypes` are provided, schema processing MUST fail with a `SchemaError` (§14).
4534	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Allowed Traits	`priority` is a meta-schema concern. Implementations MUST NOT use `priority` to change validation or compilation semantics. Meta-schemas are allowed to constrain `priority` values.
4537	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Value Type Semantics	When a trait is present on a Concept instance, its value MUST conform to the declared value type.
4539	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Value Type Semantics	When `defaultValueTypes` specifies multiple types, the value MUST conform to exactly one of the listed types.
4542	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Collection Type Semantics	When a trait's value type is a parameterized collection type, each element of the collection MUST conform to the declared item type.
4546	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.4. Trait Definitions > 11.4.1 `TraitDefinition` > Collection Type Semantics	When a trait's value type is a union containing both scalar and collection types, the value MUST conform to exactly one member of the union.
4608	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types	Value type checking MUST be deterministic and MUST NOT perform implicit evaluation.
4669	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.1 Built-In Value Type Tokens	When a schema constrains a Trait value using a built-in value type token, semantic validation MUST convert that value into the corresponding typed IR value and MUST reject values that are syntactically well-formed but semantically invalid for the expected type.
4689	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.2 `ValueTypeDefinition` > Allowed Traits	`ValueTypeDefinition` names MUST be unique within the Schema.
4691	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.2 `ValueTypeDefinition` > Allowed Traits	When `validatorName` is present, schema-driven validation MUST apply the referenced validator as specified in §9.5.2 and §9.11.6.6.
4693	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.2 `ValueTypeDefinition` > Allowed Traits	When `validatorName` cannot be resolved to exactly one `ValidatorDefinition`, schema processing MUST fail with a `SchemaError` (§14).
4695	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.2 `ValueTypeDefinition` > Allowed Traits	A `ValueTypeDefinition` MUST NOT change the surface grammar of its `baseValueType`.
4731	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.3 Enumerated Value Sets > `Member` > Allowed Traits	Each `value` MUST be unique within its `EnumeratedValueSet`.
4736	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.4 Built-In Enumerated Value Sets	The following enumerated value sets are defined by the Codex language itself and MUST be recognized by all conforming implementations.
4766	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.5 Value Types > 11.5.4 Built-In Enumerated Value Sets > `Cardinality`	These enumerated sets MUST NOT be redefined by schemas.
4777	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.1 `ConstraintDefinitions` > Children	The order of `ConstraintDefinition` children MUST be preserved but MUST NOT affect semantics.
4798	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.2 `ConstraintDefinition` > Children	When either child is missing or appears more than once, schema processing MUST fail with a `SchemaError` (§14).
4810	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > Children	When `Targets` contains no children, schema processing MUST fail with a `SchemaError` (§14).
4819	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > 11.6.3.1 `TargetConcept` > Traits	The selector MUST resolve to exactly one `ConceptDefinition`.
4820	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > 11.6.3.1 `TargetConcept` > Traits	Otherwise, schema processing MUST fail with a `SchemaError` (§14).
4829	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > 11.6.3.2 `TargetContext` > Traits	When `contextSelector` is not `"Document"`, it MUST resolve to exactly one `ConceptDefinition`.
4830	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.3 `Targets` > 11.6.3.2 `TargetContext` > Traits	Otherwise, schema processing MUST fail with a `SchemaError` (§14).
4837	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.4 `Rule` > Children	Exactly one child, which MUST be one of:
4843	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.4 `Rule` > Children	When `Rule` contains zero or more than one child, schema processing MUST fail with a `SchemaError` (§14).
4845	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.6 Constraint Model > 11.6.4 `Rule` > Children	`Rule` nodes are purely structural and MUST NOT carry Traits.
4851	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra	Rule algebra MUST be translatable to a total, deterministic validation form.
4857	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.1 General Rules	* Rule algebra nodes MUST NOT carry Traits.
4858	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.1 General Rules	* `AllOf`, `AnyOf`, and `Not` MUST contain only `Rule` nodes as children.
4859	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.1 General Rules	* Any rule tree MUST be finite and acyclic.
4861	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.1 General Rules	When a rule algebra structure cannot be translated deterministically, schema processing MUST fail with a `SchemaError` (§14).
4917	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.6 Determinism Requirement	Rule algebra evaluation MUST be:
4922	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.7 Rule Algebra > 11.7.6 Determinism Requirement	When rule algebra composition cannot be evaluated deterministically, schema processing MUST fail with a `SchemaError` (§14).
4928	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers	All path and quantifier semantics MUST be compatible with the instance-graph mapping defined in §9.7 and the rule-to-SPARQL translation defined in §9.11.
4934	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.1 Paths	Each path node MUST declare exactly the traits required for its form.
4983	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.2 Quantifiers	Quantifiers MUST appear only in rule nodes that explicitly bind a Path to a nested Rule (see §9.5.3).
5009	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.2 Quantifiers > `Count` > Allowed Traits	At least one of `minCount` or `maxCount` MUST be present.
5019	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	* Paths MUST select a well-defined set of elements.
5020	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	* Quantifiers MUST evaluate to a single boolean outcome.
5021	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	* When a path selector cannot be resolved uniquely, schema processing MUST fail with a `SchemaError` (§14).
5022	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	* When a quantifier cannot be evaluated without guessing, schema processing MUST fail with a `SchemaError` (§14).
5024	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.8 Paths and Quantifiers > 11.8.3 Determinism and Totality	Paths and quantifiers MUST NOT be evaluated outside the schema-driven validation pipeline defined in §9.
5030	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints	When an atomic constraint cannot be expressed under the instance-graph mapping (§9.7) and the constraint-to-artifact rules (§9.9–§9.11), schema processing MUST fail with a `SchemaError` (§14).
5038	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Trait Constraints > `TraitExists`	The named Trait MUST be present.
5047	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Trait Constraints > `TraitMissing`	The named Trait MUST be absent.
5056	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Trait Constraints > `TraitEquals`	The named Trait MUST have at least one value equal to the specified value.
5073	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Trait Constraints > `TraitCardinality` > Allowed Traits	At least one of `min` or `max` MUST be present.
5111	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsOneOf`	The value MUST be one of the explicitly listed values.
5120	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueMatchesPattern`	The value MUST match a regular expression.
5147	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueLength` > Allowed Traits	At least one of `min` or `max` MUST be present.
5157	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueInNumericRange` > Allowed Traits	At least one of `min` or `max` MUST be present.
5159	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueInNumericRange` > Allowed Traits	This constraint MUST apply only to numeric value types that support ordered comparison.
5160	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueInNumericRange` > Allowed Traits	When comparison semantics are not explicitly defined for the active value type, schema processing MUST fail with a `SchemaError` (§14).
5166	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsNonEmpty`	The value MUST be present and non-empty.
5169	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsNonEmpty`	If applied to an incompatible value type, schema processing MUST fail with a `SchemaError` (§14).
5175	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsValid`	The value MUST satisfy a named validator.
5180	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsValid` > Traits	The validator MUST resolve to exactly one `ValidatorDefinition` in the governing schema.
5181	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.1 Value Constraints > `ValueIsValid` > Traits	If resolution fails, schema processing MUST fail with a `SchemaError` (§14).
5193	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.2 Child Constraints > `ChildConstraint` > Traits	Its semantics MUST be equivalent to the corresponding explicit child-rule form defined in §11.3.4.
5205	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.2 Child Constraints > `ChildSatisfies` > Children	The rule MUST be evaluated for each matching child Concept instance.
5239	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.3 Collection Constraints > `CollectionAllowsDuplicates` > Allowed Traits	When `allowed` is `false`, `keyTrait` MUST be present.
5252	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.3 Collection Constraints > `MemberCount` > Allowed Traits	At least one of `min` or `max` MUST be present.
5261	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.3 Collection Constraints > `EachMemberSatisfies`	Each collection member MUST satisfy a nested rule.
5267	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.3 Collection Constraints > `EachMemberSatisfies` > Children	The rule MUST be evaluated for each matching collection member.
5279	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.4 Uniqueness Constraints > `UniqueConstraint` > Traits	Uniqueness semantics MUST follow the deterministic scope rules defined in §9.9.7.
5292	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.5 Order Constraints > `OrderConstraint` > Types	* `Ascending`: Elements MUST be in ascending order by the specified trait value.
5293	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.5 Order Constraints > `OrderConstraint` > Types	* `Descending`: Elements MUST be in descending order by the specified trait value.
5298	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.5 Order Constraints > `OrderConstraint` > Children	Order constraint semantics apply to `$Ordered` collections only. When an `OrderConstraint` is applied to an `$Unordered` collection, schema processing MUST fail with a `SchemaError` (§14).
5310	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceTargetsEntity`: Target MUST be an Entity. The `conceptSelector` and `traitName` traits MUST NOT be present.
5311	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceMustResolve`: Reference MUST resolve. The `conceptSelector` and `traitName` traits MUST NOT be present.
5312	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceSingleton`: At most one reference Trait MUST be present. The `conceptSelector` and `traitName` traits MUST NOT be present.
5313	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceTargetsConcept`: Target MUST be a specific Concept type. The `conceptSelector` trait MUST be present.
5314	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	* `ReferenceTraitAllowed`: A specific reference Trait is allowed. The `traitName` trait MUST be present.
5316	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.6 Reference Constraints > `ReferenceConstraint` > Types	Reference constraint semantics MUST follow §9.9.9–§9.9.12 exactly.
5328	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	* `MustBeEntity`: Instance MUST be an Entity. The `scope`, `pattern`, and `flags` traits MUST NOT be present.
5329	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	* `MustNotBeEntity`: Instance MUST NOT be an Entity. The `scope`, `pattern`, and `flags` traits MUST NOT be present.
5330	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	* `IdentifierUniqueness`: Identifiers MUST be unique within scope. The `scope` trait MUST be present. The `pattern` and `flags` traits MUST NOT be present.
5331	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	* `IdentifierForm`: Identifier MUST match pattern. The `pattern` trait MUST be present. The `scope` trait MUST NOT be present.
5333	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	Identity constraint semantics MUST follow the entity and identity model defined in §§3.5 and 6.
5335	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	`IdentityConstraint(type=MustBeEntity)` MUST report an `IdentityError` (§14) unless the focus Concept instance is an Entity under §3.5.
5337	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	`IdentityConstraint(type=MustNotBeEntity)` MUST report an `IdentityError` (§14) if the focus Concept instance declares an `id` Trait.
5340	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	Its semantics MUST be identical to `UniqueConstraint(trait=id, scope=S)` as defined in §9.9.7 (where `id` refers to `codex:declaredId`).
5343	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	When the focus Concept instance is an Entity, its declared `id` value MUST match the regular expression `p` under SPARQL 1.1 `REGEX` semantics (see §9.5.1).
5345	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.7 Identity Constraints > `IdentityConstraint` > Types	When `pattern` is not provided for `IdentityConstraint(type=IdentifierForm)`, schema processing MUST fail with a `SchemaError` (§14).
5358	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.8 Context Constraints > `ContextConstraint` > Types	* `OnlyValidUnderParent`: Requires the immediate parent is of the type specified by the `TargetContext` in this constraint's `Targets` block. The `ContextConstraint` itself MUST NOT have a `contextSelector` trait.
5359	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.8 Context Constraints > `ContextConstraint` > Types	* `OnlyValidUnderContext`: Requires an ancestor of the specified type exists in the parent chain. The `contextSelector` trait MUST be present.
5361	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.8 Context Constraints > `ContextConstraint` > Types	Context constraint semantics MUST follow §9.9.8.
5373	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.10 Content Constraints > `ContentConstraint` > Types	* `ForbidsContent`: Requires content is absent. The `pattern` and `flags` traits MUST NOT be present.
5374	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.10 Content Constraints > `ContentConstraint` > Types	* `ContentRequired`: Requires content exists. The `pattern` and `flags` traits MUST NOT be present.
5375	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.10 Content Constraints > `ContentConstraint` > Types	* `ContentMatchesPattern`: Requires content matches a pattern. The `pattern` trait MUST be present. The `flags` trait is allowed.
5377	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.9 Atomic Constraints > 11.9.10 Content Constraints > `ContentConstraint` > Types	Content constraint semantics MUST follow the content model defined in §3.4 and the validation rules defined in §9.9.5.
5440	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.11 Relationship to External Systems	* Any derived representation (including SHACL, SHACL-SPARQL, or OWL) MUST be a pure, deterministic projection of the Codex schema.
5441	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.11 Relationship to External Systems	* Derived artifacts MUST NOT introduce semantics, defaults, inference rules, or interpretation not explicitly defined by:
5445	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.11 Relationship to External Systems	* Derived artifacts MUST NOT override, weaken, or contradict Codex validation semantics.
5446	Codex Language Specification — Version 1.0.0 > 11. Schema Definition Language > 11.11 Relationship to External Systems	* When a Codex constraint or rule cannot be expressed faithfully in the chosen external system, derivation MUST fail with a `SchemaError` (§14) rather than approximate.
5503	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas	The bootstrap schema-of-schemas MUST NOT be substituted for a missing governing schema when processing an instance document.
5507	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.1 Requirements	Every conforming implementation MUST:
5513	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.1 Requirements	An explicitly provided governing schema for a schema document MUST either be the bootstrap schema-of-schemas itself or a schema that is valid under the bootstrap schema-of-schemas. An implementation MUST NOT partially extend, modify, or augment the bootstrap schema-of-schemas.
5515	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.1 Requirements	The bootstrap schema-of-schemas MUST itself conform to the Codex language invariants (§2) and the schema-first architecture (§9).
5521	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.2 Schema Document Detection	A document whose root Concept is `Schema` MUST be treated as a schema document and MUST NOT be parsed as an instance document under any schema other than the bootstrap schema-of-schemas or an explicitly provided governing schema.
5525	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.2 Schema Document Detection	1. If an explicit governing schema was provided by the caller, that schema MUST be used.
5526	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.2 Schema Document Detection	2. Otherwise, the built-in bootstrap schema-of-schemas MUST be used.
5528	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.2 Schema Document Detection	An implementation MUST NOT use any other detection, inference, or fallback mechanisms.
5534	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.3 Validation and Error Classification	* If the document cannot be decoded, tokenized, or structurally parsed, the failure MUST be classified as `ParseError` (§14).
5535	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.3 Validation and Error Classification	* If the document is structurally readable but violates the bootstrap schema-of-schemas or an explicitly provided governing schema, the failure MUST be classified as `SchemaError` (§14).
5537	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.3 Validation and Error Classification	Implementations MUST NOT attempt partial validation, recovery, or best-effort interpretation.
5545	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.4 Canonical Authority	The bootstrap schema-of-schemas MUST accept exactly those schema documents that conform to §11, and MUST reject all others with a `SchemaError` (§14).
5547	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.4 Canonical Authority	The bootstrap schema-of-schemas MUST NOT introduce additional constructs, defaults, or semantics beyond those defined in §11.
5636	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.2 Core Principles	Schemas MUST make their versioning intent explicit.
5639	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	Every Codex schema MUST declare its identity and version explicitly.
5650	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	All versions of the same schema MUST share the same schema identifier.
5654	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	A schema document that omits any of the `id`, `version`, or `versionScheme` Traits on the root `Schema` Concept MUST be rejected with a `SchemaError` (§14).
5656	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	A schema document MUST NOT declare more than one schema identifier.
5658	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	Within a schema lineage, the schema identifier MUST NOT be redefined or aliased.
5660	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	Schema identity and version information MUST be treated as authoritative and MUST NOT be inferred, synthesized, or substituted by tooling.
5663	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics	Schemas MUST use monotonic versioning within a schema lineage.
5665	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics	Within a schema lineage, all schema versions MUST use the same `versionScheme` value; a schema that changes the `versionScheme` within a lineage MUST be rejected with a `SchemaError` (§14).
5667	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics	Regardless of scheme, schema versions MUST form a **total, unambiguous ordering**. A schema whose version ordering is ambiguous or non-comparable MUST be rejected with a `SchemaError` (§14).
5669	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics	Tools MUST compare schema versions mechanically according to the comparison rules defined in this section for the declared `versionScheme`, and MUST NOT apply heuristics, coercion, or fallback rules.
5672	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics > 13.4.1 Version Schemes	The root `Schema` Concept’s `versionScheme` Trait MUST be one of the following Enumerated Token Values:
5679	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics > 13.4.1 Version Schemes	If `versionScheme` is not one of these values, schema processing MUST fail with a `SchemaError` (§14).
5682	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics > 13.4.2 Version Comparison Rules	For all schemes below, if a `version` text does not conform to the required scheme-specific syntax, schema processing MUST fail with a `SchemaError` (§14).
5705	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes	Each schema version MUST declare exactly one compatibility class. For all versions except the first, the compatibility class declares the relationship to the immediately preceding version in the same schema lineage.
5709	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes	The `compatibilityClass` Trait MUST be one of the following Enumerated Token Values:
5716	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes	If `compatibilityClass` is not one of these values, schema processing MUST fail with a `SchemaError` (§14).
5720	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes	If a schema version's declared compatibility class is contradicted by its actual effects on validation semantics, the schema MUST be rejected with a `SchemaError` (§14).
5724	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.1 Initial	The first version in a schema lineage MUST declare `compatibilityClass=$Initial`.
5726	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.1 Initial	A schema version that declares `$Initial` MUST be the first version in its lineage; if a non-first version declares `$Initial`, schema processing MUST fail with a `SchemaError` (§14).
5732	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.2 BackwardCompatible	* all Codex data that passed schema validation under the immediately preceding version MUST also pass schema validation under this version
5733	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.2 BackwardCompatible	* the meaning of existing Concepts and Traits MUST be preserved
5737	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.2 BackwardCompatible	If any previously valid data becomes invalid under a schema version declared as backward-compatible, the schema MUST be rejected with a `SchemaError` (§14).
5749	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.3 ForwardCompatible	If data authored for a forward-compatible version cannot pass schema validation under the preceding version without loss of meaning, the schema MUST be rejected with a `SchemaError` (§14).
5759	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.4 Breaking	Any schema version that introduces a breaking change MUST be declared as breaking.
5764	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.6 What Constitutes a Breaking Change	The following changes are breaking and MUST require `compatibilityClass=$Breaking`:
5778	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.6 What Constitutes a Breaking Change	A schema version that introduces any breaking change without declaring `compatibilityClass=$Breaking` is invalid and MUST be rejected with a `SchemaError` (§14).
5794	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.7 Non-Breaking Changes	Non-breaking changes MUST NOT:
5800	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.7 Non-Breaking Changes	If any change classified as non-breaking would cause previously valid data to fail validation, the schema version MUST instead be declared as `compatibilityClass=$Breaking`.
5803	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	When validating a Codex document, the governing schema version MUST be explicitly known.
5805	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	Validation MUST be performed strictly according to the rules of that schema version.
5807	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	A conforming implementation MUST:
5814	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	A conforming implementation MUST NOT:
5821	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	If schema version resolution fails for any reason, validation MUST fail with a `SchemaError` (§14).
5826	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	A breaking schema version declaration MUST be treated as a statement that migration is required for existing data to validate under the new schema version.
5828	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	Codex schemas MUST:
5834	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	Codex tooling MUST:
5840	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	Any migrated data MUST validate cleanly under the target schema version using ordinary schema validation rules.
5842	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	Migration tooling, if provided, is outside the scope of this specification and MUST be explicit, deterministic, and non-heuristic.
5845	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.10 Tooling Responsibilities	Codex tooling MUST:
5853	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.10 Tooling Responsibilities	Codex tooling MUST NOT:
5860	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.10 Tooling Responsibilities	All version handling MUST be explicit, deterministic, and free of heuristics.
