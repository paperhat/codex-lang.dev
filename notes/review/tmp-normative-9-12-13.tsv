2640	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture	A conforming implementation MUST provide schema-directed validation.
2644	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture	Canonical Authoring Mode permits authors to write the canonical RDF representation directly. Simplified Authoring Mode permits authors to write a Codex-native surface form that has no independent semantics and exists only as a deterministic, lossless authoring convenience; documents written in Simplified Authoring Mode MUST expand to a byte-identical canonical RDF representation.
2646	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture	No other semantic layers, representations, or interpretive stages exist in Codex, and implementations MUST treat the canonical RDF representation as the sole source of truth.
2650	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.1 Scope and Inputs	Given the same required inputs, a conforming implementation MUST produce the same validation and canonicalization results.
2659	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.1 Scope and Inputs	Other external inputs—including environment state, configuration, registries, network access, clocks, or randomness—MUST NOT influence processing.
2661	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.1 Scope and Inputs	If any required input is missing, schema-directed processing MUST fail with a `SchemaError` (§14).
2663	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.1 Scope and Inputs	Given a Codex document and a governing schema, a conforming implementation MUST dispatch validation according to that schema.
2667	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.2 Schema-Less Formatting / Well-Formedness Checks	Schema-less checks MUST be limited to rules that are explicitly defined by this specification as independent of schema semantics.
2677	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.2 Schema-Less Formatting / Well-Formedness Checks	Without a governing schema, an implementation MUST NOT:
2686	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.3 Schema-Required Semantic Validation	An implementation MUST NOT perform semantic validation without a governing schema.
2688	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.3 Schema-Required Semantic Validation	Given a governing schema, an implementation MUST perform semantic validation as defined by that schema.
2690	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.3 Schema-Required Semantic Validation	Schema-driven semantic validation MUST be traceable to the specific schema rule(s) applied.
2692	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.3 Schema-Required Semantic Validation	Schema-driven semantic validation MUST include evaluation of all schema-defined authorizations and constraints:
2706	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	A schema document MUST be validated under exactly one authoring mode.
2713	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	All conforming implementations MUST support both authoring modes.
2715	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	The schema document's root `Schema` concept MUST have an `authoringMode` trait.
2717	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	`authoringMode` MUST be exactly one of `$SimplifiedMode` or `$CanonicalMode`; any other value or a missing `authoringMode` trait is a `SchemaError` (§14).
2719	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	The following mode-specific constraints MUST hold:
2721	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	- Simplified mode schemas MUST contain exactly one `ConceptDefinitions` and MUST NOT contain `RdfGraph`.
2722	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	- Canonical mode schemas MUST contain exactly one `RdfGraph` and MUST NOT contain Codex-native schema-definition concepts (including `ConceptDefinitions`, `TraitDefinitions`, `EnumeratedValueSets`, `ConstraintDefinitions`, `ValueTypeDefinitions`, and `ValidatorDefinitions`).
2723	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	- Simplified-mode expansion MUST generate the Canonical Representation as a canonical RDF graph; different simplified spellings that are semantically identical MUST expand to byte-identical canonical RDF graphs.
2724	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.4 Authoring Modes	- Canonicalization of the Canonical Representation MUST make semantically identical graphs byte-identical.
2730	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface)	To support a total, deterministic projection to derived validation artifacts, simplified-mode schema authoring MUST support the following extensions.
2734	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.1 Pattern Flags	The following atomic constraints MUST support an optional `flags` trait whose value is text:
2740	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.1 Pattern Flags	If `flags` is omitted, it MUST be treated as empty text.
2742	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.1 Pattern Flags	The `pattern` and `flags` semantics MUST be SPARQL 1.1 `REGEX` semantics.
2746	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	Simplified Authoring Mode MUST support explicit validator definitions that make `ValueIsValid` deterministic.
2754	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	Each `ValidatorDefinition` MUST have these traits:
2760	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	`ValidatorDefinition` names MUST be unique within the Schema.
2762	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	Each `ValidatorDefinition` MUST be in content mode.
2764	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	The content of `ValidatorDefinition` MUST be a SPARQL `SELECT` query text.
2766	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	The `SELECT` results MUST follow the SHACL-SPARQL convention (returning one row per violation with `?this` bound to the focus node).
2768	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	If a derived validation artifact is expressed using SHACL-SPARQL, the embedding contract for `ValueIsValid validatorName=$X` MUST be:
2773	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.2 Explicit Validator Definitions	If `$X` cannot be resolved to exactly one `ValidatorDefinition`, schema processing MUST fail with a `SchemaError` (§14).
2779	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	To produce a total, deterministic mapping, Simplified Authoring Mode MUST provide explicit rule-node forms that bind exactly one path to exactly one nested rule.
2781	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	Simplified Authoring Mode MUST provide the following rule nodes:
2787	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	Each of these MUST have exactly one `Path` child and exactly one `Rule` child.
2789	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	`OnPathCount` MUST additionally have:
2794	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	The `Path` child MUST be exactly one of:
2801	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.3 Explicit Path and Quantifier Rule Forms	`ChildSatisfies(conceptSelector=X, Rule=R)` MUST be interpreted as equivalent to `OnPathForAll(Path=ChildPath(X), Rule=R)`.
2814	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	the constraint node MUST have exactly one `Path` child that selects the collection members the constraint applies to.
2816	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	That member-selection path MUST be either `ChildPath` or `DescendantPath`.
2818	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	If the member-selection path is not one of these, expansion MUST fail with a `SchemaError` (§14).
2820	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	For `CollectionAllowsDuplicates` with `allowed=false`, the constraint node MUST include a required `keyTrait` trait whose value is a Trait name.
2822	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.5 Simplified Authoring Mode (Codex-Native Schema Authoring Surface) > 9.5.4 Collection and Order Constraint Scoping	If `keyTrait` is `id`, it MUST refer to the declared identifier as specified by the instance-graph identity rules.
2828	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL)	The Canonical Representation MUST be deterministic and canonical:
2830	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL)	- The Canonical Representation MUST NOT contain RDF blank nodes.
2831	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL)	- All RDF nodes in the Canonical Representation MUST be IRIs.
2832	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL)	- Where SHACL commonly uses blank nodes (for example, `sh:property` values and RDF lists), the Canonical Representation MUST use deterministically derived skolem IRIs instead.
2833	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL)	- The Canonical Representation MUST be treated as a set of RDF triples.
2834	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL)	- The Canonical Representation MUST NOT contain duplicate triples.
2838	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.1 Canonical Triple Form	When the Canonical Representation is authored as a Codex graph form, it MUST use:
2843	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.1 Canonical Triple Form	`RdfGraph` MUST be in children mode.
2845	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.1 Canonical Triple Form	`RdfGraph` children MUST include one or more `RdfTriple`. `RdfGraph` children MUST be `RdfTriple` children and annotations only; no other Concept children are allowed.
2847	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.1 Canonical Triple Form	Each `RdfTriple` MUST have these traits:
2862	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.1 Canonical Triple Form	If `language` is present, `datatype` MUST be absent.
2864	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.1 Canonical Triple Form	If `datatype` is absent and `language` is absent, the literal datatype MUST be `xsd:string`.
2870	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	`objectKey` MUST be:
2875	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	`datatypeOrDefault` MUST be: `datatype` if present; otherwise `rdf:langString` if `language` is present; otherwise `xsd:string`.
2877	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	`languageOrEmpty` MUST be: `language` if present; otherwise the empty string.
2879	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	If two triples have identical sort keys, the duplicate MUST be removed.
2881	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	When an `RdfGraph` contains no grouping annotations (§8.9.7), all `RdfTriple` children MUST be sorted by sort key.
2885	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	1. Within each group, `RdfTriple` children MUST be sorted by sort key.
2886	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	2. Groups at the same nesting level MUST be sorted in ascending lexicographic order of their canonical group label.
2887	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	3. `RdfTriple` children not enclosed in any group MUST be sorted by sort key and MUST appear before all groups at the same nesting level.
2888	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.2 Canonical Ordering and Duplicate Removal	4. An attached annotation (§8.9.6.1) on an `RdfTriple` MUST move with that triple during sorting.
2892	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.3 RDF List Encoding (No Blank Nodes)	If the Canonical Representation includes an RDF list (for example, as the object of `sh:in`), it MUST be encoded using the standard RDF list vocabulary (`rdf:first`, `rdf:rest`, `rdf:nil`).
2894	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.3 RDF List Encoding (No Blank Nodes)	All RDF list nodes MUST be IRIs.
2896	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.3 RDF List Encoding (No Blank Nodes)	Where the RDF list encoding would otherwise use blank nodes, the Canonical Representation MUST use deterministically derived skolem IRIs instead.
2898	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.3 RDF List Encoding (No Blank Nodes)	At most one RDF list MUST be attached as the object of triples sharing a given `(subject, predicate)` pair.
2900	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.3 RDF List Encoding (No Blank Nodes)	For an RDF list attached as the object of a triple `(subject, predicate, _)`, list node IRIs MUST be derived as follows:
2905	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.3 RDF List Encoding (No Blank Nodes)	- The final list node's `rdf:rest` MUST be `rdf:nil`.
2909	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.4 Deterministic IRI Hashing	When a derived IRI embeds another IRI or name as a path component, the embedded value MUST be hashed to produce fixed-length, path-safe text.
2911	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.4 Deterministic IRI Hashing	`iriHash(value)` MUST be computed as:
2919	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.5 Deterministic Derived IRIs (One Way To Say It)	To preserve "one way to say it", every derived IRI used by schema processing, instance graph mapping, and derived validation artifact generation MUST be computed by a single deterministic algorithm.
2930	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.6 Node Shape IRIs	The node shape IRI for a concept class IRI `K` MUST be deterministically derived as:
2936	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.7 Property Shape IRIs	Each property shape MUST have a deterministic IRI.
2952	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.8 Document Node Shape IRI	The document node shape IRI MUST be deterministically derived as:
2958	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.6 Canonical Representation (RDF / SHACL) > 9.6.9 SPARQL Constraint IRIs	Each SHACL-SPARQL constraint node emitted for a `ConstraintDefinition` MUST have a deterministic IRI.
2968	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping	The mapping MUST be deterministic and MUST NOT use RDF blank nodes.
2972	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping	If `documentBaseIri` is missing, the mapping MUST fail with a `SchemaError` (§14).
2976	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.1 Document Node	The instance graph MUST include a single document node.
2978	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.1 Document Node	The RDF node IRI for the Document context MUST be exactly `documentBaseIri`.
2982	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.2 Node Identity and Declared Identifiers	Each Concept instance in the Codex document MUST map to exactly one RDF node whose identity is a deterministic skolem IRI derived from its structural position within the document. The `codex:` prefix used in this section is shorthand; full IRI derivations are defined in §9.7.5.
2999	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.2 Node Identity and Declared Identifiers > 9.7.2.1 Skolem IRI Derivation (`nodeIri`)	`ordinalIndex(C)` MUST be zero-based.
3001	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.2 Node Identity and Declared Identifiers > 9.7.2.1 Skolem IRI Derivation (`nodeIri`)	`ordinalIndex(C)` MUST be expressed in base-10 with no leading zeros (except that `0` is permitted).
3011	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.2 Node Identity and Declared Identifiers > 9.7.2.1 Skolem IRI Derivation (`nodeIri`)	The RDF node IRI MUST NOT be derived from the Concept instance's declared `id` trait value.
3013	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.2 Node Identity and Declared Identifiers > 9.7.2.1 Skolem IRI Derivation (`nodeIri`)	If a Concept instance declares an `id` trait, that declared identifier MUST be represented as data via a dedicated predicate `codex:declaredId`.
3015	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.2 Node Identity and Declared Identifiers > 9.7.2.1 Skolem IRI Derivation (`nodeIri`)	If a concept instance `C` declares an `id` trait with value `v`, the mapping MUST emit:
3021	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.3 Entity Marker	If and only if a Concept instance is an Entity, the mapped RDF node MUST be marked as an Entity using a dedicated predicate `codex:isEntity`.
3023	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.3 Entity Marker	The mapping MUST emit an entity marker for every Concept instance node:
3030	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.4 Parent Link and Ordered Children	For each non-root Concept instance, the instance graph MUST include a parent link using a dedicated predicate `codex:parentNode`.
3032	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.4 Parent Link and Ordered Children	For each parent Concept instance `C` and each direct child Concept instance `D`, the instance graph MUST emit:
3036	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.4 Parent Link and Ordered Children	For each child Concept instance `D` of parent Concept instance `C`, the instance graph MUST emit the structural child triple:
3040	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.4 Parent Link and Ordered Children	The instance graph MUST additionally represent the ordered child sequence using explicit edge nodes that carry a stable numeric index (see §9.7.6).
3068	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	Their IRIs MUST be deterministically derived from `schemaIri` as follows:
3070	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:parent` MUST be `schemaIri + "#codex/parent"`
3071	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:child` MUST be `schemaIri + "#codex/child"`
3072	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:index` MUST be `schemaIri + "#codex/index"`
3073	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:parentNode` MUST be `schemaIri + "#codex/parentNode"`
3074	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:isEntity` MUST be `schemaIri + "#codex/isEntity"`
3075	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:declaredId` MUST be `schemaIri + "#codex/declaredId"`
3076	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:content` MUST be `schemaIri + "#codex/content"`
3077	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:annotationParent` MUST be `schemaIri + "#codex/annotationParent"`
3078	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:annotationIndex` MUST be `schemaIri + "#codex/annotationIndex"`
3079	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:annotationText` MUST be `schemaIri + "#codex/annotationText"`
3080	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:annotationForm` MUST be `schemaIri + "#codex/annotationForm"`
3081	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:annotationKind` MUST be `schemaIri + "#codex/annotationKind"`
3082	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:annotationDirective` MUST be `schemaIri + "#codex/annotationDirective"`
3083	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:annotationTarget` MUST be `schemaIri + "#codex/annotationTarget"`
3084	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:mapKey` MUST be `schemaIri + "#codex/mapKey"`
3085	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:mapValue` MUST be `schemaIri + "#codex/mapValue"`
3086	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:rangeStart` MUST be `schemaIri + "#codex/rangeStart"`
3087	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:rangeEnd` MUST be `schemaIri + "#codex/rangeEnd"`
3088	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.5 Reserved Predicates	- `codex:rangeStep` MUST be `schemaIri + "#codex/rangeStep"`
3098	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.6 Ordered Children Encoding	The mapping MUST emit an edge node `e` and three triples:
3104	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.6 Ordered Children Encoding	The edge node IRI MUST be:
3115	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.7 Annotation Nodes	The mapping MUST emit an annotation edge node `e` with the following triples:
3123	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.7 Annotation Nodes	The annotation edge node IRI MUST be:
3127	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.7 Annotation Nodes	If the annotation has a block directive (§8.9.5), the mapping MUST additionally emit:
3133	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.7 Annotation Nodes	If the annotation is an attached annotation (§8.9.6.1), the mapping MUST additionally emit:
3139	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	For each trait `t=v` on a concept instance `C`, the instance graph MUST emit exactly one triple:
3145	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	- If `t` is `id`, the mapping MUST NOT emit a `traitPredicateIri("id")` triple.
3146	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	- Instead, `id` MUST be represented only by `codex:declaredId`, with the `id` value as an IRI (not a literal).
3148	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	Because `id` has no `traitPredicateIri` representation in the instance graph, schema definitions MUST NOT target `id` through generic trait mechanisms (`TraitRules`, `TraitPath`, `TraitExists`, `TraitMissing`, `TraitEquals`). The `id` trait is governed by `entityEligibility` (§6.1) and identity constraints (§9.9.6, §9.9.7). If a generic trait mechanism references `id`, derived validation artifact generation MUST fail with a `SchemaError` (§14).
3150	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	`valueTerm(v)` MUST be:
3157	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	For typed literals, the datatype IRI MUST be computed by `valueDatatypeIri(v)` and the lexical form MUST be computed by `valueLex(v)`.
3159	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	Both `valueDatatypeIri(v)` and `valueLex(v)` MUST be derived by parsing `v` according to the Codex value catalog.
3161	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	`valueDatatypeIri(v)` MUST be:
3168	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	For all other scalar value types, `valueDatatypeIri(v)` MUST be the deterministic URN:
3176	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	`valueLex(v)` MUST be:
3183	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	For all other scalar value types, `valueLex(v)` MUST be the canonical surface spelling of `v`.
3185	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	Lookup Token Values MUST be represented as typed literals with:
3190	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	When an Enumerated Token Value `v` appears on a trait that is constrained by an `EnumeratedValueSet` `E` (via `AllowedValues` containing an `EnumeratedConstraint` referencing `E`), `valueTerm(v)` MUST be the IRI:
3202	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms	If a schema constraint requires an interpreted value (for example, numeric comparisons or text length), schema processing MUST provide the interpreted value in a deterministic RDF representation.
3206	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	When a trait value `v` is a collection (List, Set, Map, Record, Tuple, or Range), `valueTerm(v)` MUST NOT be a typed literal. Instead, the value MUST be represented as a structured collection graph using the standard RDF list vocabulary (`rdf:first`, `rdf:rest`, `rdf:nil`) and reserved Codex predicates.
3208	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	All collection graph nodes MUST be IRIs. No blank nodes are permitted (§9.6.1).
3217	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	List node IRIs MUST follow the same pattern as §9.6.3:
3221	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	The list head node is at position 0. `valueTerm(v)` for the trait MUST be `listNodeIri(collectionAnchor, 0)`.
3223	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	If the collection is empty (zero elements), `valueTerm(v)` MUST be `rdf:nil`.
3229	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	For each position `i` from 0 to n-1, the mapping MUST emit:
3236	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	Sets use the same RDF list encoding as Lists. Element order in the RDF list MUST match canonical source order (§5.14).
3242	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	For each position `i` from 0 to n-1, let `entryIri = listNodeIri(collectionAnchor, i) + "/__entry"`. The mapping MUST emit:
3249	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	Entry order in the RDF list MUST match canonical source order.
3253	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	For a Range `start..end` (with optional step), let the components be `start`, `end`, and (if present) `step`. A Range MUST be encoded as a single RDF resource (not a list). Let `rangeIri = nodeIri(C) + "/range/" + iriHash(traitPredIri)`. The mapping MUST emit:
3259	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	`valueTerm(v)` for a Range MUST be `rangeIri`.
3263	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	Each element `e` within a collection MUST be mapped to an RDF term as follows:
3265	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	- If `e` is an IRI Reference Value, `elementTerm(e)` MUST be the IRI.
3266	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	- If `e` is an Enumerated Token Value and the governing trait is constrained by an `EnumeratedValueSet` `E`, `elementTerm(e)` MUST be the IRI `E.id + "#" + tokenName(e)`.
3267	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	- If `e` is a nested collection (List, Set, Map, Record, Tuple, or Range), `elementTerm(e)` MUST be the head IRI of the nested collection's graph. Let `nestedAnchor = listNodeIri(collectionAnchor, i) + "/__value"`, where `i` is the position of the element in the parent collection. For nested List, Set, Map, Record, or Tuple collections, the nested collection anchor is `nestedAnchor` and the list head IRI is `nestedAnchor + "/0"`. For a nested Range, the range IRI is `nestedAnchor` directly. The nested collection graph MUST be emitted following the same rules defined in this section.
3268	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	- Otherwise, `elementTerm(e)` MUST be the typed literal `valueLex(e)^^valueDatatypeIri(e)`, using the scalar rules defined in §9.7.8.
3270	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.8 Traits and Value Terms > 9.7.8.1 Collection Value Graphs	This rule replaces the typed-literal representation for collection values. A collection value on a trait MUST always produce a collection graph; it MUST NOT produce a typed literal.
3274	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.9 Content	If a concept instance is in content mode, the mapping MUST emit:
3278	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.9 Content	`contentText` MUST be an `xsd:string` literal containing the concept's content after applying the Codex content escaping rules.
3282	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	Trait predicate IRIs MUST be derived as follows.
3286	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	- If the governing schema contains exactly one `TraitDefinition` for `t`, `traitPredicateIri(t)` MUST be that `TraitDefinition`'s `id`.
3287	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	- If an imported schema contains the `TraitDefinition` for `t` (resolved via a qualified Trait name in the governing schema's `ConceptDefinition`), `traitPredicateIri(t)` MUST be the imported schema's `TraitDefinition.id` for `t`.
3288	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	- If the governing schema contains zero `TraitDefinition` entries for `t` (including imported schemas), validation MUST fail with a `SchemaError` (§14).
3289	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	- If the governing schema contains more than one `TraitDefinition` for `t`, validation MUST fail with a `SchemaError` (§14).
3291	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	Child predicate IRIs MUST be derived as follows.
3295	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	- `childPredicateIri(P,Q)` MUST be `P + "#child/" + iriHash(Q)`.
3297	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.10 Deterministic Predicate IRIs	When the child Concept `Q` is from an imported schema (referenced via a qualified Concept name per §4.1.1), `Q` MUST be the `ConceptDefinition.id` from the imported schema. The child predicate IRI derivation MUST use the imported schema's `ConceptDefinition.id`.
3301	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.11 RDF Types	Each Concept instance MUST emit an RDF type triple:
3305	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.11 RDF Types	`conceptClassIri(X)` MUST be the `ConceptDefinition.id` for concept name `X` in the governing schema, or in the imported schema if `X` is a qualified Concept name (§4.1.1).
3307	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.11 RDF Types	If `conceptClassIri(X)` cannot be resolved to exactly one `ConceptDefinition`, schema-driven validation MUST fail with a `SchemaError` (§14).
3313	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.7 Codex→RDF Instance Graph Mapping > 9.7.12 Conformance Graph (`G₁`)	A conforming implementation MUST emit `G₁` in the Codex `RdfGraph` form defined in §9.6.1 and MUST apply the canonical ordering and duplicate-removal rules defined in §9.6.2.
3321	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.1 Resolution Table	The resolution table MUST be constructed solely from explicit `key` and `id` trait declarations. Resolution entries MUST NOT be inferred, synthesized, or imported implicitly.
3327	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.2 Resolution Semantics	* A lookup token MUST resolve to exactly one identifier in the resolution table.
3328	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.2 Resolution Semantics	* If no matching entry is found for a required lookup token, validation MUST fail with a `ReferenceError` (§14).
3330	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.2 Resolution Semantics	Lookup token resolution is declarative only and MUST NOT imply loading, dereferencing, or execution.
3334	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.3 Schema Interaction	A governing schema MUST specify, for each context where lookup token values are permitted, one of the following resolution requirements:
3336	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.3 Schema Interaction	* The lookup token MUST be resolvable.
3337	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.3 Schema Interaction	* The lookup token MUST NOT appear in the context.
3338	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.8 Lookup Token Resolution > 9.8.3 Schema Interaction	* The lookup token MUST pass through without resolution.
3342	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	Derived validation artifacts MUST be generated deterministically.
3344	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	Any derived validation artifact MUST be a pure function of:
3349	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	Derived validation artifact generation MUST fail with a `SchemaError` (§14) if any of the following hold:
3357	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	Derived validation artifacts MUST be expressed as SHACL, including SHACL-SPARQL constraints.
3359	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	A derived SHACL artifact MUST apply each constraint to the target node shape(s) determined as follows:
3361	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- For `TargetConcept conceptSelector="X"`, the constraint MUST be applied to the node shape derived from the `ConceptDefinition` whose `name` is `X`.
3362	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- For `TargetContext contextSelector="Document"`, the constraint MUST be applied to a special node shape with IRI `schemaIri + "#shape/Document"` and MUST include at least:
3365	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	If `documentBaseIri` is not available as an external input, derived validation artifact generation MUST fail with a `SchemaError` (§14).
3366	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- If `contextSelector` is a concept name (not `Document`), the constraint MUST be applied to the node shape for that concept.
3368	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	If a derived validation artifact is produced as a SHACL graph, it MUST be canonical and MUST include the following structural shape triples:
3370	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- For each `ConceptDefinition` in the governing schema with concept name `X`, let `K = conceptClassIri(X)` and let `S = nodeShapeIri(K)`. The derived artifact MUST include:
3373	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- If the derived artifact includes any constraint expressed on a property shape `PS`, it MUST include:
3376	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	and `PS` MUST be deterministically derived as follows:
3377	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- for a trait name `t`: `PS = propertyShapeIri(S,t)` and the artifact MUST include `(PS, sh:path, traitPredicateIri(t))`
3378	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- for a child class IRI `Q`: `PS = propertyShapeIri(S,Q)` and the artifact MUST include `(PS, sh:path, childPredicateIri(K,Q))`
3379	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- for a predicate IRI `p`: `PS = predicatePropertyShapeIri(S,p)` and the artifact MUST include `(PS, sh:path, p)`
3381	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	If a derived validation artifact expresses any constraint using SHACL-SPARQL, the `sh:select` text MUST be a SPARQL 1.1 `SELECT` query that returns one row per violating focus node using the SHACL-SPARQL convention:
3383	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- the focus node variable MUST be `?this`
3384	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- a row returned by the query MUST indicate a violation
3386	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	SPARQL text in derived artifacts MUST be canonically formatted. Internal SPARQL variables introduced during constraint translation MUST be allocated as follows:
3390	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- Any internal variable introduced while translating that node MUST append suffix `$k$` to a base name.
3391	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts	- Variables introduced for one rule node MUST NOT be referenced outside the `EXISTS { ... }` block created for that node.
3395	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.1 Enumerated Value Sets (`sh:in`)	A derived SHACL artifact encoding an enumerated value-set constraint MUST emit a triple `(PS, sh:in, listHead)` on the property shape `PS`.
3397	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.1 Enumerated Value Sets (`sh:in`)	The list encoding MUST conform to §9.6.3.
3401	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.2 Pattern Constraints (`sh:pattern`, `sh:flags`)	A derived SHACL artifact encoding a pattern constraint MUST emit a triple `(PS, sh:pattern, p)` on the property shape `PS`.
3403	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.2 Pattern Constraints (`sh:pattern`, `sh:flags`)	When `flags` is present and non-empty, the artifact MUST also emit a triple `(PS, sh:flags, f)`.
3405	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.2 Pattern Constraints (`sh:pattern`, `sh:flags`)	The `pattern` and `flags` semantics MUST be SPARQL 1.1 `REGEX` semantics (see §9.5.1).
3409	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.3 SHACL Core Value Constraints	A derived SHACL artifact encoding a value-length constraint on a property shape `PS` MUST emit:
3414	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.3 SHACL Core Value Constraints	A derived SHACL artifact encoding a non-empty constraint on a property shape `PS` MUST emit:
3418	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.3 SHACL Core Value Constraints	A derived SHACL artifact encoding a numeric-range constraint on a property shape `PS` MUST use SHACL Core numeric bounds. The active value datatype MUST be `xsd:integer`; any other active datatype is a `SchemaError` (§14).
3420	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.3 SHACL Core Value Constraints	The artifact MUST emit:
3429	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.4 Child Constraints	A derived SHACL artifact encoding a required-child constraint for a child concept selector `X` on a property shape `PS` MUST emit:
3435	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.4 Child Constraints	A derived SHACL artifact encoding a forbidden-child constraint for a child concept selector `X` on a property shape `PS` MUST emit:
3440	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.4 Child Constraints	An allowed-without-required child relationship MUST NOT produce a constraint in the derived SHACL artifact.
3444	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.5 Content Constraints	For content constraints, let `S` be the owning node shape. The property shape IRI MUST be `PS = predicatePropertyShapeIri(S, codex:content)`.
3446	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.5 Content Constraints	A derived SHACL artifact encoding a content-required constraint MUST emit:
3451	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.5 Content Constraints	A derived SHACL artifact encoding a content pattern constraint MUST emit:
3456	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.5 Content Constraints	When `flags` is present and non-empty, the artifact MUST also emit `(PS, sh:flags, f)`.
3458	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.5 Content Constraints	The `pattern` and `flags` semantics MUST be SPARQL 1.1 `REGEX` semantics (see §9.5.1).
3462	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	For identity constraints, let `S` be the owning node shape. The property shape IRI MUST be `PS = predicatePropertyShapeIri(S, codex:isEntity)`.
3464	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	A derived SHACL artifact encoding an identity constraint requiring an entity MUST emit:
3469	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	A derived SHACL artifact encoding an identity constraint requiring a non-entity MUST emit:
3474	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	Derived validation artifacts MUST support `IdentityConstraint(type=IdentifierUniqueness, scope=S)`.
3476	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	The `scope` trait MUST be present. For derived artifact purposes, `IdentityConstraint(type=IdentifierUniqueness, scope=S)` MUST be treated as `UniqueConstraint(trait=id, scope=S)` and MUST follow §9.9.7.
3478	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	Derived validation artifacts MUST support `IdentityConstraint(type=IdentifierForm, pattern=p, flags=f)`.
3480	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	This constraint MUST be expressed using SHACL-SPARQL.
3481	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	It MUST report a violation if the focus node is an Entity and either:
3486	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	The SHACL-SPARQL constraint MUST use the following boolean condition:
3497	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.6 Identity Constraints	where `p` is the required pattern and `f` is the flags text if present. When `flags` is absent, the generated constraint MUST use the 2-argument `REGEX(text, pattern)` form.
3501	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.7 Uniqueness Constraints	Derived validation artifacts MUST support the `UniqueConstraint` constraint (§11.9.4).
3503	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.7 Uniqueness Constraints	When a uniqueness constraint refers to `t = id`, it MUST refer to the declared identifier as represented by `codex:declaredId`.
3505	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.7 Uniqueness Constraints	For nearest-scope uniqueness, `UniqueConstraint(trait=t, scope=S)` MUST mean:
3519	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.7 Uniqueness Constraints	Derived validation artifact generation MUST fail with a `SchemaError` (§14) if no nearest scope node exists.
3521	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.7 Uniqueness Constraints	Derived validation artifacts MUST also enforce the document-wide uniqueness invariants for `id` (§6.2.2) and `key` (§6.3.2). Within a single document, two nodes MUST NOT share the same value for `codex:declaredId`, and two nodes MUST NOT share the same `key` trait value.
3525	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.8 Context Constraints	Derived validation artifacts MUST express `ContextConstraint(type=OnlyValidUnderParent)`.
3527	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.8 Context Constraints	The `contextSelector` trait MUST NOT be present. The SHACL-SPARQL constraint MUST use the following boolean condition:
3536	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.8 Context Constraints	Derived validation artifacts MUST express `ContextConstraint(type=OnlyValidUnderContext, contextSelector=A)`.
3538	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.8 Context Constraints	The `contextSelector` trait MUST be present. The SHACL-SPARQL constraint MUST use the following boolean condition:
3549	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.9 Reference Constraints (Reference Trait Predicates)	The set of reference-trait predicates MUST be exactly:
3555	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.9 Reference Constraints (Reference Trait Predicates)	Derived validation artifacts MUST support `ReferenceConstraint(type=ReferenceSingleton)`. The constraint MUST report a violation when more than one reference-trait predicate is present on the same focus node.
3557	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.9 Reference Constraints (Reference Trait Predicates)	Derived validation artifacts MUST support `ReferenceConstraint(type=ReferenceTraitAllowed)`. The constraint MUST provide a `traitName` trait whose value is one of `reference`, `target`, or `for`; a missing or invalid `traitName` is a `SchemaError` (§14).
3561	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	For the purposes of reference constraints, a reference value `v` MUST be one of:
3566	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	Given a reference value `v`, its resolved IRI `r` MUST be computed as follows:
3571	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	- Otherwise, `v` MUST be treated as unresolved.
3572	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	- Otherwise, `v` MUST be treated as unresolved.
3574	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	Derived validation artifacts MUST support `ReferenceConstraint(type=ReferenceTargetsEntity)`.
3576	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	`ReferenceTargetsEntity` MUST mean:
3579	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	- A violation MUST be reported if `v` is treated as unresolved.
3580	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.10 Reference Constraints (Deterministic Resolution and Targets)	- A violation MUST be reported unless there exists a node `n` in the same Document such that:
3586	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.11 Reference Constraints (Targets a Concept)	Derived validation artifacts MUST support `ReferenceConstraint(type=ReferenceTargetsConcept, conceptSelector=X)`.
3588	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.11 Reference Constraints (Targets a Concept)	`ReferenceTargetsConcept` MUST mean:
3591	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.11 Reference Constraints (Targets a Concept)	- A violation MUST be reported if `v` is treated as unresolved.
3592	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.11 Reference Constraints (Targets a Concept)	- A violation MUST be reported unless there exists a node `n` in the same Document such that:
3598	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.12 Reference Constraints (Must Resolve)	Derived validation artifacts MUST support `ReferenceConstraint(type=ReferenceMustResolve)`.
3600	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.12 Reference Constraints (Must Resolve)	`ReferenceMustResolve` MUST mean:
3603	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.12 Reference Constraints (Must Resolve)	- A violation MUST be reported if `v` is treated as unresolved.
3604	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.12 Reference Constraints (Must Resolve)	- A violation MUST be reported unless there exists a node `n` in the same Document such that `(n, codex:declaredId, r)` holds.
3606	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.9 Deterministic Projection to Derived Validation Artifacts > 9.9.12 Reference Constraints (Must Resolve)	The projection of a derived validation artifact to a concrete RDF syntax MUST be exactly:
3613	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.10 Failure Rules (No Guessing)	Schema processing, schema-driven validation, instance-graph mapping, and derived-artifact projection MUST fail with an appropriate error rather than guess when required information is missing or ambiguous.
3615	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.10 Failure Rules (No Guessing)	Processing MUST fail in any of the following cases:
3634	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.2 Preconditions	The expansion MUST fail with a `SchemaError` (§14) if any precondition defined in §9.9 is violated.
3654	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.4 TraitRules → SHACL Property Shapes	The expansion MUST emit one SHACL property shape node `PS` with:
3660	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.4 TraitRules → SHACL Property Shapes	`PS` MUST be `propertyShapeIri(NS, t)`.
3664	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.4 TraitRules → SHACL Property Shapes	- `RequiresTrait` MUST emit `(PS, sh:minCount, "1"^^xsd:integer)`.
3665	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.4 TraitRules → SHACL Property Shapes	- `ForbidsTrait` MUST emit `(PS, sh:maxCount, "0"^^xsd:integer)`.
3669	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.4 TraitRules → SHACL Property Shapes	- When a value type token maps to an RDF datatype IRI, the expansion MUST emit `(PS, sh:datatype, datatypeIri)`.
3670	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.4 TraitRules → SHACL Property Shapes	- When a value type token constrains by enumerated set, the expansion MUST emit `(PS, sh:in, listNodeIri)` and MUST emit the RDF list structure using deterministic skolem IRIs (see §9.6.3).
3672	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.4 TraitRules → SHACL Property Shapes	Any value-type token without a defined mapping MUST cause expansion failure with a `SchemaError` (§14).
3678	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.5 ChildRules → SHACL Property Shapes	The expansion MUST emit one SHACL property shape node `PS` with:
3684	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.5 ChildRules → SHACL Property Shapes	`PS` MUST be `propertyShapeIri(NS, Q)`.
3688	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.5 ChildRules → SHACL Property Shapes	- `RequiresChildConcept` MUST emit `(PS, sh:minCount, "1"^^xsd:integer)`.
3689	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.5 ChildRules → SHACL Property Shapes	- `ForbidsChildConcept` MUST emit `(PS, sh:maxCount, "0"^^xsd:integer)`.
3691	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.5 ChildRules → SHACL Property Shapes	When the child relationship restricts child type, the expansion MUST emit `(PS, sh:class, Q)`.
3695	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints	ConstraintDefinitions MUST expand to SHACL constraints.
3699	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.1 General Rule	Each Codex constraint type defined by the schema-definition specification MUST map to either:
3704	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.1 General Rule	If a constraint type cannot be expressed without inventing semantics not defined by this specification and the schema-definition specification, expansion MUST fail with a `SchemaError` (§14).
3706	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.1 General Rule	Atomic constraint mappings that are defined by this specification MUST follow §9.9.
3712	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total)	If the rule algebra tree contains an atomic constraint whose required mapping is undefined, expansion MUST fail with a `SchemaError` (§14).
3716	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	For any `ConstraintDefinition`, expansion MUST emit exactly one SHACL-SPARQL constraint query per target shape.
3718	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	The query MUST be a `SELECT` query that returns one row per violating focus node using the SHACL-SPARQL convention:
3720	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	- The focus node variable MUST be `?this`.
3721	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	- A row returned by the query MUST indicate a violation.
3723	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	The query MUST have the following canonical structure:
3733	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	`<TARGET_BINDING>` MUST bind `?this` to the set of focus nodes implied by the constraint's targets.
3735	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	The target binding MUST be:
3742	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	If target binding cannot be expressed without ambiguity (for example, the target selector is not resolvable), expansion MUST fail with a `SchemaError` (§14).
3744	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.1 Canonical SPARQL Form	`<HOLD_EXPR>` MUST be computed by the function `H(rule, ctx, focusVar)` defined below, with `focusVar` set to `?this`.
3748	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.2 Deterministic Variable Allocation	Expansion MUST allocate internal variable names deterministically.
3750	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.2 Deterministic Variable Allocation	Expansion MUST walk the rule tree in pre-order.
3752	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.2 Deterministic Variable Allocation	For the k-th node visited (1-indexed), the expansion context `ctx` MUST define a node-local suffix `k`.
3754	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.2 Deterministic Variable Allocation	Any internal variable introduced while translating that node MUST be named by appending `k` to a base name.
3761	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.2 Deterministic Variable Allocation	Variables introduced for one rule node MUST NOT be referenced outside the `EXISTS { ... }` block created for that node.
3767	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.3 The `H(rule, ctx, focusVar)` Function	If `focusVar` is omitted, it MUST be `?this`.
3769	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.3 The `H(rule, ctx, focusVar)` Function	`H(rule, ctx, focusVar)` MUST be computed as follows.
3799	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.4 Atomic Rules as `EXISTS` Blocks	If `rule` is atomic, `H(rule, ctx, focusVar)` MUST be a SPARQL `EXISTS { ... }` form or an `EXISTS`-free boolean constant.
3801	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.4 Atomic Rules as `EXISTS` Blocks	For atomic rules whose SHACL Core mapping is defined in §9.9, expansion MUST define `H(rule, ctx, focusVar)` using only SPARQL 1.1 constructs.
3803	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.4 Atomic Rules as `EXISTS` Blocks	If an atomic rule cannot be expressed as a SPARQL boolean expression without inventing additional semantics, expansion MUST fail with a `SchemaError` (§14).
3805	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.4 Atomic Rules as `EXISTS` Blocks	For atomic rules mapped in §9.9, the `H` translation MUST be:
3811	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.4 Atomic Rules as `EXISTS` Blocks	Here `?vK` MUST follow the deterministic variable allocation rule in §9.11.6.2.2.
3813	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.4 Atomic Rules as `EXISTS` Blocks	If `value` in a `TraitEquals` rule is a collection value (List, Set, Map, Record, Tuple, or Range), derived validation artifact generation MUST fail with a `SchemaError` (§14). Collection equality is not expressible as a single-triple SPARQL pattern.
3817	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.5 One-Way Representation Rule	When a `ConstraintDefinition` uses rule algebra (i.e., contains `AllOf`, `AnyOf`, `Not`, or `ConditionalConstraint` anywhere in its rule tree), expansion MUST express that constraint definition using SHACL-SPARQL only.
3819	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.2 Rule Algebra → SHACL-SPARQL (Total) > 9.11.6.2.5 One-Way Representation Rule	Expansion MUST NOT additionally emit independent SHACL Core constraints for the same `ConstraintDefinition`.
3823	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total)	The path operators (`TraitPath`, `ChildPath`, `DescendantPath`, `ContentPath`) and quantifier operators (`OnPathExists`, `OnPathForAll`, `OnPathCount`) MUST be expressed using SHACL-SPARQL.
3829	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.1 Path Binding Function	`B` MUST be computed as follows.
3865	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.1 Path Binding Function	If `conceptSelector` cannot be resolved to a unique `ConceptDefinition`, expansion MUST fail with a `SchemaError` (§14).
3877	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	The nested rule MUST be evaluated with `focusVar` set to `xVar`.
3881	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	`OnPathExists(path, r)` MUST translate to:
3892	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	`OnPathForAll(path, r)` MUST translate to:
3903	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	`OnPathCount(path, r, minCount=m?, maxCount=n?)` MUST translate to a COUNT-based boolean condition.
3905	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	If both `minCount` and `maxCount` are absent, expansion MUST fail with a `SchemaError` (§14).
3907	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	The expansion MUST introduce a subquery that binds a single variable `?countK` and MUST then apply all required comparisons to `?countK` using a `FILTER` expression.
3909	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	A conforming translation MUST have the following canonical form:
3928	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	* `?countK` MUST be deterministically allocated according to §9.11.6.2.2.
3929	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	* The subquery MUST appear in the same `WHERE` block as the enclosing constraint.
3930	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	* The `FILTER` expression applying the count comparisons MUST appear immediately after the subquery.
3931	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.3 Paths and Quantifiers → SHACL-SPARQL (Total) > 9.11.6.3.2 Quantifier Semantics (Revised — `OnPathCount`)	* Other bindings or filters MUST NOT intervene between the subquery and its associated `FILTER`.
3935	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.4 SPARQL Constraint Shape	When a constraint is expressed using SHACL-SPARQL, the expansion MUST emit:
3942	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.4 SPARQL Constraint Shape	`sparqlConstraintIri` MUST be computed according to §9.6.9.
3944	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.4 SPARQL Constraint Shape	When the source constraint has a `title` or `description`, the expansion MUST emit `sh:message`.
3946	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.4 SPARQL Constraint Shape	The SPARQL query MUST be deterministic given the source constraint.
3950	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.5 Pattern Constraints (SPARQL 1.1 REGEX)	For the pattern-bearing constraints (`ValueMatchesPattern`, `PatternConstraint`, `ContentMatchesPattern`), the expansion MUST use SPARQL 1.1 `REGEX` semantics.
3952	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.5 Pattern Constraints (SPARQL 1.1 REGEX)	If `flags` is present, it MUST be projected to `sh:flags` when using `sh:pattern`, and it MUST be passed as the third argument to `REGEX` when using `sh:sparql`.
3956	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.6 `ValueIsValid` via Explicit `ValidatorDefinition`	For `ValueIsValid validatorName=$X`, expansion MUST:
3961	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.6 `ValueIsValid` via Explicit `ValidatorDefinition`	The embedding contract MUST be:
3963	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.6 `ValueIsValid` via Explicit `ValidatorDefinition`	- The validator content MUST be a SPARQL `SELECT` query text whose results follow the SHACL-SPARQL convention (returning a row per violation with `?this`).
3965	Codex Language Specification — Version 1.0.0 > 9. Schema-First Architecture > 9.11 Simplified Authoring Mode → Canonical Representation Expansion Algorithm (Total) > 9.11.6 ConstraintDefinitions → SHACL Constraints > 9.11.6.6 `ValueIsValid` via Explicit `ValidatorDefinition`	The derived `sh:select` text MUST be exactly the validator content.
5458	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.1 Purpose	A Codex document MUST NOT be semantically validated without an explicit governing schema.
5460	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.1 Purpose	Codex permits schema-less formatting and well-formedness checks that do not require a governing schema, but such checks MUST NOT perform semantic interpretation or validation (see §9.2 and §10.1.1).
5473	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.2 Schema Provision	A conforming implementation MUST require explicit provision of a governing schema for semantic validation.
5475	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.2 Schema Provision	Schema-less formatting and well-formedness checks (§9.2, §10.1.1) do not require a governing schema and MUST NOT be blocked by the absence of one.
5485	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.2 Schema Provision	`documentBaseIri` is the base IRI for instance graph mapping (§9.7). It MUST be an IRI. If `documentBaseIri` is missing, semantic validation MUST fail with a `SchemaError` (§14).
5487	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.2 Schema Provision	The implementation MUST use the provided schema and MUST NOT attempt to substitute, infer, or override it.
5489	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.2 Schema Provision	If no governing schema is provided and semantic validation is requested, the implementation MUST fail with a `SchemaError` (§14).
5491	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.2 Schema Provision	If the document or governing schema declares a `SchemaImport` whose `reference` IRI is not present in `importedSchemas`, the implementation MUST fail with a `SchemaError` (§14).
5503	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas	The bootstrap schema-of-schemas MUST NOT be substituted for a missing governing schema when processing an instance document.
5507	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.1 Requirements	Every conforming implementation MUST:
5513	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.1 Requirements	An explicitly provided governing schema for a schema document MUST either be the bootstrap schema-of-schemas itself or a schema that is valid under the bootstrap schema-of-schemas. An implementation MUST NOT partially extend, modify, or augment the bootstrap schema-of-schemas.
5515	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.1 Requirements	The bootstrap schema-of-schemas MUST itself conform to the Codex language invariants (§2) and the schema-first architecture (§9).
5521	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.2 Schema Document Detection	A document whose root Concept is `Schema` MUST be treated as a schema document and MUST NOT be parsed as an instance document under any schema other than the bootstrap schema-of-schemas or an explicitly provided governing schema.
5525	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.2 Schema Document Detection	1. If an explicit governing schema was provided by the caller, that schema MUST be used.
5526	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.2 Schema Document Detection	2. Otherwise, the built-in bootstrap schema-of-schemas MUST be used.
5528	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.2 Schema Document Detection	An implementation MUST NOT use any other detection, inference, or fallback mechanisms.
5534	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.3 Validation and Error Classification	* If the document cannot be decoded, tokenized, or structurally parsed, the failure MUST be classified as `ParseError` (§14).
5535	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.3 Validation and Error Classification	* If the document is structurally readable but violates the bootstrap schema-of-schemas or an explicitly provided governing schema, the failure MUST be classified as `SchemaError` (§14).
5537	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.3 Validation and Error Classification	Implementations MUST NOT attempt partial validation, recovery, or best-effort interpretation.
5545	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.4 Canonical Authority	The bootstrap schema-of-schemas MUST accept exactly those schema documents that conform to §11, and MUST reject all others with a `SchemaError` (§14).
5547	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.3 Bootstrap Schema-of-Schemas > 12.3.4 Canonical Authority	The bootstrap schema-of-schemas MUST NOT introduce additional constructs, defaults, or semantics beyond those defined in §11.
5553	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.4 Schema Caching	Caching MUST NOT change observable parsing, validation, or error-reporting behavior.
5561	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.1 Schema Unavailable	* The report MUST indicate that the governing schema was unavailable
5562	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.1 Schema Unavailable	* Validation MUST NOT proceed
5569	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.2 Schema Load Failure	* The report MUST indicate that the schema could not be loaded
5570	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.2 Schema Load Failure	* The report MUST include the schema identifier
5577	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.3 Invalid Schema	* The report MUST indicate that schema validation failed
5578	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.3 Invalid Schema	* Underlying schema validation errors MUST be reported
5585	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.4 Imported Schema Unavailable	* The report MUST indicate which imported schema IRI was unavailable
5586	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.4 Imported Schema Unavailable	* Validation MUST NOT proceed
5593	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.5 Duplicate Namespace Label	* The report MUST indicate the duplicate namespace label and the conflicting schema IRIs
5594	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.5 Duplicate Namespace Label	* Validation MUST NOT proceed
5601	Codex Language Specification — Version 1.0.0 > 12. Schema Loading and Bootstrapping > 12.5 Error Handling > 12.5.6 Unresolved Qualified Name	* The report MUST indicate the unresolved qualified name and the imported schema IRI
5636	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.2 Core Principles	Schemas MUST make their versioning intent explicit.
5639	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	Every Codex schema MUST declare its identity and version explicitly.
5650	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	All versions of the same schema MUST share the same schema identifier.
5654	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	A schema document that omits any of the `id`, `version`, or `versionScheme` Traits on the root `Schema` Concept MUST be rejected with a `SchemaError` (§14).
5656	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	A schema document MUST NOT declare more than one schema identifier.
5658	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	Within a schema lineage, the schema identifier MUST NOT be redefined or aliased.
5660	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.3 Schema Identity	Schema identity and version information MUST be treated as authoritative and MUST NOT be inferred, synthesized, or substituted by tooling.
5663	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics	Schemas MUST use monotonic versioning within a schema lineage.
5665	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics	Within a schema lineage, all schema versions MUST use the same `versionScheme` value; a schema that changes the `versionScheme` within a lineage MUST be rejected with a `SchemaError` (§14).
5667	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics	Regardless of scheme, schema versions MUST form a **total, unambiguous ordering**. A schema whose version ordering is ambiguous or non-comparable MUST be rejected with a `SchemaError` (§14).
5669	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics	Tools MUST compare schema versions mechanically according to the comparison rules defined in this section for the declared `versionScheme`, and MUST NOT apply heuristics, coercion, or fallback rules.
5672	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics > 13.4.1 Version Schemes	The root `Schema` Concept’s `versionScheme` Trait MUST be one of the following Enumerated Token Values:
5679	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics > 13.4.1 Version Schemes	If `versionScheme` is not one of these values, schema processing MUST fail with a `SchemaError` (§14).
5682	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.4 Version Semantics > 13.4.2 Version Comparison Rules	For all schemes below, if a `version` text does not conform to the required scheme-specific syntax, schema processing MUST fail with a `SchemaError` (§14).
5705	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes	Each schema version MUST declare exactly one compatibility class. For all versions except the first, the compatibility class declares the relationship to the immediately preceding version in the same schema lineage.
5709	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes	The `compatibilityClass` Trait MUST be one of the following Enumerated Token Values:
5716	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes	If `compatibilityClass` is not one of these values, schema processing MUST fail with a `SchemaError` (§14).
5720	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes	If a schema version's declared compatibility class is contradicted by its actual effects on validation semantics, the schema MUST be rejected with a `SchemaError` (§14).
5724	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.1 Initial	The first version in a schema lineage MUST declare `compatibilityClass=$Initial`.
5726	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.1 Initial	A schema version that declares `$Initial` MUST be the first version in its lineage; if a non-first version declares `$Initial`, schema processing MUST fail with a `SchemaError` (§14).
5732	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.2 BackwardCompatible	* all Codex data that passed schema validation under the immediately preceding version MUST also pass schema validation under this version
5733	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.2 BackwardCompatible	* the meaning of existing Concepts and Traits MUST be preserved
5737	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.2 BackwardCompatible	If any previously valid data becomes invalid under a schema version declared as backward-compatible, the schema MUST be rejected with a `SchemaError` (§14).
5749	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.3 ForwardCompatible	If data authored for a forward-compatible version cannot pass schema validation under the preceding version without loss of meaning, the schema MUST be rejected with a `SchemaError` (§14).
5759	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.5 Compatibility Classes > 13.5.4 Breaking	Any schema version that introduces a breaking change MUST be declared as breaking.
5764	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.6 What Constitutes a Breaking Change	The following changes are breaking and MUST require `compatibilityClass=$Breaking`:
5778	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.6 What Constitutes a Breaking Change	A schema version that introduces any breaking change without declaring `compatibilityClass=$Breaking` is invalid and MUST be rejected with a `SchemaError` (§14).
5794	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.7 Non-Breaking Changes	Non-breaking changes MUST NOT:
5800	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.7 Non-Breaking Changes	If any change classified as non-breaking would cause previously valid data to fail validation, the schema version MUST instead be declared as `compatibilityClass=$Breaking`.
5803	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	When validating a Codex document, the governing schema version MUST be explicitly known.
5805	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	Validation MUST be performed strictly according to the rules of that schema version.
5807	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	A conforming implementation MUST:
5814	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	A conforming implementation MUST NOT:
5821	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.8 Schema Validation Behavior	If schema version resolution fails for any reason, validation MUST fail with a `SchemaError` (§14).
5826	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	A breaking schema version declaration MUST be treated as a statement that migration is required for existing data to validate under the new schema version.
5828	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	Codex schemas MUST:
5834	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	Codex tooling MUST:
5840	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	Any migrated data MUST validate cleanly under the target schema version using ordinary schema validation rules.
5842	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.9 Relationship to Data Migration	Migration tooling, if provided, is outside the scope of this specification and MUST be explicit, deterministic, and non-heuristic.
5845	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.10 Tooling Responsibilities	Codex tooling MUST:
5853	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.10 Tooling Responsibilities	Codex tooling MUST NOT:
5860	Codex Language Specification — Version 1.0.0 > 13. Schema Versioning > 13.10 Tooling Responsibilities	All version handling MUST be explicit, deterministic, and free of heuristics.
